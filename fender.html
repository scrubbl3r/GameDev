<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Defender-ish SFX Generator</title>
  <style>
    :root{
      --bg:#030506;
      --ink:#e8fff2;

      /* HOT REACTOR CONSOLE */
      --g:#35ff7a;
      --y:#ffe35a;
      --o:#ff9a2f;
      --r:#ff3b2f;

      /* Brutalist bevel palette */
      --panel:#070b0d;
      --plate:#05080a;
      --stroke:rgba(53,255,122,.18);
      --stroke2:rgba(255,227,90,.14);
      --shadow:rgba(0,0,0,.78);
    }

    html,body{height:100%;}
    body{
      margin:0;
      background: linear-gradient(180deg, #030506 0%, #020304 70%, #010203 100%);
      color:var(--ink);
      font:14px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      letter-spacing:.2px;
      overflow-x:hidden;
    }

    .wrap{max-width:1120px;margin:24px auto;padding:0 14px;}

    /* =========================================================
       CHAMFERED / BEVELED SHAPE SYSTEM (NO ROUNDED CORNERS)
       - Uses clip-path to make harsh chamfer corners.
       - "Big chunky bevels" are sized via --ch.
       ========================================================= */
    .chamfer{
      --ch: 18px;              /* corner cut size (chunky) */
      --b: 1px;                /* outer border */
      --hi: rgba(255,255,255,.06);
      --lo: rgba(0,0,0,.62);

      position:relative;
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.015));
      box-shadow: 0 18px 46px var(--shadow);
      border: var(--b) solid var(--stroke);

      /* Harsh beveled corners */
      -webkit-clip-path: polygon(
        var(--ch) 0,
        calc(100% - var(--ch)) 0,
        100% var(--ch),
        100% calc(100% - var(--ch)),
        calc(100% - var(--ch)) 100%,
        var(--ch) 100%,
        0 calc(100% - var(--ch)),
        0 var(--ch)
      );
      clip-path: polygon(
        var(--ch) 0,
        calc(100% - var(--ch)) 0,
        100% var(--ch),
        100% calc(100% - var(--ch)),
        calc(100% - var(--ch)) 100%,
        var(--ch) 100%,
        0 calc(100% - var(--ch)),
        0 var(--ch)
      );
    }

    /* Inner bevel + plate */
    .chamfer::before{
      content:"";
      position:absolute;
      inset:0;
      pointer-events:none;

      /* match chamfer shape */
      -webkit-clip-path: inherit;
      clip-path: inherit;

      /* big chunky inner bevel */
      box-shadow:
        inset 0 0 0 2px rgba(255,255,255,.03),
        inset 12px 12px 0 rgba(0,0,0,.55),
        inset -12px -12px 0 rgba(255,255,255,.06),
        inset 0 12px 0 rgba(255,255,255,.02),
        inset 0 -12px 0 rgba(0,0,0,.62);
    }

    /* Smaller chamfer for tight elements */
    .ch-sm{ --ch: 14px; }
    .ch-xs{ --ch: 10px; }
    .ch-lg{ --ch: 22px; }

    .card{ overflow:hidden; }
    .card .body{padding:14px;}

    .sfxRow{
      display:flex;
      gap:10px;
      justify-content:center;
      align-items:center;
      flex-wrap:wrap;
      padding-bottom:6px;
    }

    /* =========================================================
       BUTTONS / CONTROLS (ALL CHAMFERED)
       ========================================================= */
    button{
      appearance:none;
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
      text-transform:uppercase;
      letter-spacing:.7px;
      font-weight:900;
      font-size:12px;

      color:var(--ink);
      background:linear-gradient(180deg, rgba(0,0,0,.72), rgba(0,0,0,.38));
      border:1px solid rgba(53,255,122,.22);
      box-shadow: 0 12px 26px rgba(0,0,0,.78);
      padding:10px 12px;

      position:relative;
      --ch: 14px;
      -webkit-clip-path: polygon(
        var(--ch) 0, calc(100% - var(--ch)) 0, 100% var(--ch),
        100% calc(100% - var(--ch)), calc(100% - var(--ch)) 100%,
        var(--ch) 100%, 0 calc(100% - var(--ch)), 0 var(--ch)
      );
      clip-path: polygon(
        var(--ch) 0, calc(100% - var(--ch)) 0, 100% var(--ch),
        100% calc(100% - var(--ch)), calc(100% - var(--ch)) 100%,
        var(--ch) 100%, 0 calc(100% - var(--ch)), 0 var(--ch)
      );
    }

    button::before{
      content:"";
      position:absolute; inset:0;
      pointer-events:none;
      -webkit-clip-path: inherit;
      clip-path: inherit;
      box-shadow:
        inset 10px 10px 0 rgba(0,0,0,.58),
        inset -10px -10px 0 rgba(255,255,255,.07),
        inset 0 0 0 2px rgba(255,255,255,.02);
    }

    button:hover{
      border-color:rgba(255,227,90,.32);
      background:linear-gradient(180deg, rgba(0,0,0,.64), rgba(0,0,0,.34));
    }
    button:active{ transform:translateY(1px); filter:contrast(1.05); }
    button:disabled{opacity:.45;cursor:not-allowed;transform:none;}

    /* color hints */
    #explosion, #smartbomb{ border-color: rgba(255,59,47,.34); }
    #hyperspace, #teleport{ border-color: rgba(255,154,47,.32); }
    #laser, #zap{ border-color: rgba(53,255,122,.30); }

    .randWrap{
      display:flex;
      justify-content:center;
      margin:12px 0 12px 0;
    }
    #randAll{
      min-width:300px;
      padding:15px 18px;
      font-weight:1000;
      letter-spacing:1.1px;
      font-size:13px;
      border:1px solid rgba(255,227,90,.48);
      background:linear-gradient(180deg, rgba(255,227,90,.16), rgba(0,0,0,.40));
      box-shadow: 0 18px 44px rgba(0,0,0,.82);
      --ch: 18px; /* chunkier for primary */
    }
    #randAll:hover{ border-color:rgba(255,227,90,.74); }

    .controls{
      border-top:1px solid rgba(255,255,255,.06);
      padding-top:12px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px 12px;
      align-items:center;
    }
    @media (max-width: 860px){
      .controls{grid-template-columns:1fr;}
      input[type="range"]{max-width:58vw;}
    }

    .ctl{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;

      background:linear-gradient(180deg, rgba(0,0,0,.64), rgba(0,0,0,.34));
      border:1px solid rgba(53,255,122,.16);
      box-shadow:0 12px 28px rgba(0,0,0,.74);

      position:relative;
      --ch: 18px;
      -webkit-clip-path: polygon(
        var(--ch) 0, calc(100% - var(--ch)) 0, 100% var(--ch),
        100% calc(100% - var(--ch)), calc(100% - var(--ch)) 100%,
        var(--ch) 100%, 0 calc(100% - var(--ch)), 0 var(--ch)
      );
      clip-path: polygon(
        var(--ch) 0, calc(100% - var(--ch)) 0, 100% var(--ch),
        100% calc(100% - var(--ch)), calc(100% - var(--ch)) 100%,
        var(--ch) 100%, 0 calc(100% - var(--ch)), 0 var(--ch)
      );
    }
    .ctl::before{
      content:"";
      position:absolute; inset:0;
      pointer-events:none;
      -webkit-clip-path: inherit;
      clip-path: inherit;
      box-shadow:
        inset 12px 12px 0 rgba(0,0,0,.58),
        inset -12px -12px 0 rgba(255,255,255,.06),
        inset 0 0 0 2px rgba(255,255,255,.02);
    }

    .ctl .left{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width:120px;
      position:relative;
      z-index:1;
    }
    .label{
      color:rgba(255,227,90,.85);
      font-size:11px;
      line-height:1;
      text-transform:uppercase;
      letter-spacing:.9px;
    }
    .value{
      font:12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      color:rgba(53,255,122,.95);
    }

    /* Inputs / selects: chamfered too */
    input[type="text"], select{
      background:rgba(0,0,0,.60);
      border:1px solid rgba(255,227,90,.16);
      color:var(--ink);
      padding:8px 10px;
      outline:none;

      position:relative;
      z-index:1;
      --ch: 14px;
      -webkit-clip-path: polygon(
        var(--ch) 0, calc(100% - var(--ch)) 0, 100% var(--ch),
        100% calc(100% - var(--ch)), calc(100% - var(--ch)) 100%,
        var(--ch) 100%, 0 calc(100% - var(--ch)), 0 var(--ch)
      );
      clip-path: polygon(
        var(--ch) 0, calc(100% - var(--ch)) 0, 100% var(--ch),
        100% calc(100% - var(--ch)), calc(100% - var(--ch)) 100%,
        var(--ch) 100%, 0 calc(100% - var(--ch)), 0 var(--ch)
      );
    }
    select{cursor:pointer;}
    .row2{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    .mono{font:12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;}

    .status{
      margin-top:10px;
      color:rgba(255,227,90,.75);
      font-size:12px;
      border-top:1px solid rgba(255,255,255,.06);
      padding-top:10px;
      min-height:16px;
      letter-spacing:.5px;
      text-transform:uppercase;
    }

    /* START overlay */
    .startOverlay{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.88);
      z-index:9999;
    }
    .bigStartBtn{
      width:min(360px, calc(100vw - 28px));
      padding:18px 14px;
      font-size:18px;
      font-weight:1000;
      letter-spacing:1.6px;
      text-transform:uppercase;

      background:linear-gradient(180deg, rgba(255,227,90,.16), rgba(0,0,0,.50));
      border:1px solid rgba(255,227,90,.58);
      box-shadow: 0 28px 80px rgba(0,0,0,.80);

      position:relative;
      --ch: 26px;
      -webkit-clip-path: polygon(
        var(--ch) 0, calc(100% - var(--ch)) 0, 100% var(--ch),
        100% calc(100% - var(--ch)), calc(100% - var(--ch)) 100%,
        var(--ch) 100%, 0 calc(100% - var(--ch)), 0 var(--ch)
      );
      clip-path: polygon(
        var(--ch) 0, calc(100% - var(--ch)) 0, 100% var(--ch),
        100% calc(100% - var(--ch)), calc(100% - var(--ch)) 100%,
        var(--ch) 100%, 0 calc(100% - var(--ch)), 0 var(--ch)
      );
    }
    .bigStartBtn::before{
      content:"";
      position:absolute; inset:0;
      pointer-events:none;
      -webkit-clip-path: inherit;
      clip-path: inherit;
      box-shadow:
        inset 16px 16px 0 rgba(0,0,0,.62),
        inset -16px -16px 0 rgba(255,255,255,.06),
        inset 0 0 0 2px rgba(255,255,255,.02);
    }
    .bigStartBtn:hover{ border-color:rgba(255,227,90,.88); }

    /* ------------------------------------------------------------
       SLIDERS: track + thumb same green as values (no glow)
       Also chamfer thumb (approx) by using square+shadow; browsers limit shapes.
       ------------------------------------------------------------ */
    input[type="range"]{
      width:220px;
      position:relative;
      z-index:1;
      -webkit-appearance:none;
      appearance:none;
      background:transparent;
    }

    /* WebKit track */
    input[type="range"]::-webkit-slider-runnable-track{
      height:12px;
      background: linear-gradient(180deg, rgba(53,255,122,.22), rgba(53,255,122,.10));
      border:1px solid rgba(53,255,122,.35);
      box-shadow:
        inset 6px 6px 0 rgba(0,0,0,.55),
        inset -6px -6px 0 rgba(255,255,255,.06);
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:20px; height:20px;
      background: linear-gradient(180deg, rgba(53,255,122,.40), rgba(53,255,122,.18));
      border:1px solid rgba(53,255,122,.70);
      margin-top:-5px;
      box-shadow:
        inset 6px 6px 0 rgba(0,0,0,.50),
        inset -6px -6px 0 rgba(255,255,255,.08),
        0 10px 18px rgba(0,0,0,.65);
    }

    /* Firefox track */
    input[type="range"]::-moz-range-track{
      height:12px;
      background: linear-gradient(180deg, rgba(53,255,122,.22), rgba(53,255,122,.10));
      border:1px solid rgba(53,255,122,.35);
      box-shadow:
        inset 6px 6px 0 rgba(0,0,0,.55),
        inset -6px -6px 0 rgba(255,255,255,.06);
    }
    input[type="range"]::-moz-range-thumb{
      width:20px; height:20px;
      background: linear-gradient(180deg, rgba(53,255,122,.40), rgba(53,255,122,.18));
      border:1px solid rgba(53,255,122,.70);
      box-shadow:
        inset 6px 6px 0 rgba(0,0,0,.50),
        inset -6px -6px 0 rgba(255,255,255,.08),
        0 10px 18px rgba(0,0,0,.65);
    }

    @media (max-width: 420px){
      #randAll{ min-width: 0; width:100%; }
      input[type="range"]{ width:180px; }
    }
  </style>
</head>
<body>

  <div class="startOverlay" id="startOverlay" role="dialog" aria-modal="true">
    <button class="bigStartBtn" id="bigStartBtn">start</button>
  </div>

  <div class="wrap">
    <div class="card chamfer ch-lg">
      <div class="body">

        <div class="sfxRow" id="sfxRow">
          <button id="laser">Laser</button>
          <button id="zap">Zap</button>
          <button id="thrust">Thrust</button>
          <button id="explosion">Explosion</button>
          <button id="pickup">Pickup</button>
          <button id="alarm">Alarm</button>
          <button id="smartbomb">Smart Bomb</button>
          <button id="hyperspace">Hyperspace</button>
          <button id="teleport">Teleport</button>
        </div>

        <div class="randWrap">
          <button id="randAll">Randomize All</button>
        </div>

        <div class="controls">
          <div class="ctl">
            <div class="left">
              <div class="label">Master</div>
              <div class="value mono" id="masterVal">0.85</div>
            </div>
            <input id="master" type="range" min="0" max="1" step="0.001" value="0.85">
          </div>

          <div class="ctl">
            <div class="left">
              <div class="label">Lo-Fi</div>
              <div class="value mono" id="crushVal">1.00</div>
            </div>
            <input id="crush" type="range" min="0" max="1" step="0.001" value="1.00">
          </div>

          <div class="ctl">
            <div class="left">
              <div class="label">Mode</div>
              <div class="value mono" id="modeVal">chaos</div>
            </div>
            <select id="mode">
              <option value="faithful">Faithful</option>
              <option value="spicy">Spicy</option>
              <option value="chaos" selected>Chaos</option>
            </select>
          </div>

          <div class="ctl">
            <div class="left">
              <div class="label">Mutation</div>
              <div class="value mono" id="mutAmtVal">1.00</div>
            </div>
            <input id="mutAmt" type="range" min="0" max="1" step="0.001" value="1.00">
          </div>

          <div class="ctl" style="grid-column:1 / -1;">
            <div class="left">
              <div class="label">Seed</div>
              <div class="value mono" id="revTag">rev#0</div>
            </div>
            <div class="row2" style="justify-content:flex-end; width:100%; position:relative; z-index:1;">
              <input id="seed" type="text" value="DEFENDER" class="mono" style="width:220px; max-width:52vw;">
              <button id="resetBase">Reset</button>
            </div>
          </div>
        </div>

        <div class="status mono" id="status"></div>

      </div>
    </div>
  </div>

<script>
(() => {
  const $ = (q) => document.querySelector(q);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp  = (a, b, t) => a + (b - a) * t;

  function hash32(str){
    let h = 2166136261 >>> 0;
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }
  function mulberry32(seed){
    let t = seed >>> 0;
    return function(){
      t += 0x6D2B79F5;
      let r = Math.imul(t ^ (t >>> 15), 1 | t);
      r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
      return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
    };
  }
  function triRand(rng){ return (rng() + rng()) * 0.5; }
  function randSym(rng){ return (triRand(rng) - 0.5) * 2.0; }

  function makeDriveCurve(amount){
    const n = 1024;
    const curve = new Float32Array(n);
    const k = amount;
    for (let i=0;i<n;i++){
      const x = (i * 2 / (n - 1)) - 1;
      curve[i] = (1 + k) * x / (1 + k * Math.abs(x));
    }
    return curve;
  }

  function adsrToZeroLinear(param, t0, A, D, S, R, peak=1.0){
    const a = Math.max(0.0005, A);
    const d = Math.max(0.001, D);
    const r = Math.max(0.001, R);

    const tA = t0 + a;
    const tD = tA + d;
    const tS = tD + Math.max(0, S);
    const tR = tS + r;

    param.cancelScheduledValues(t0);
    param.setValueAtTime(0, t0);
    param.linearRampToValueAtTime(peak, tA);
    param.linearRampToValueAtTime(0, tD);
    param.setValueAtTime(0, tS);
    param.linearRampToValueAtTime(0, tR);
    return tR;
  }

  function modeConfig(mode){
    if (mode === "faithful") return { wide: 0.75, jumpP: 0.08, jumpScale: 0.55 };
    if (mode === "chaos")   return { wide: 3.00, jumpP: 0.28, jumpScale: 1.65 };
    return { wide: 1.55, jumpP: 0.16, jumpScale: 1.00 };
  }
  function pickVal(rng, base, min, max, mutAmt, modeWide, jumpP, jumpScale){
    const span = (max - min);
    const jitter = randSym(rng) * span * 0.42 * modeWide;
    const jump = (rng() < (jumpP * (0.35 + 0.65 * mutAmt)))
      ? randSym(rng) * span * 0.70 * modeWide * jumpScale
      : 0;

    const rerollP = (0.03 + 0.10 * (modeWide/3.0)) * (0.25 + 0.75 * mutAmt);
    if (rng() < rerollP) return min + rng() * span;

    const v = base + (jitter + jump) * (0.25 + 0.75 * mutAmt);
    return clamp(v, min, max);
  }
  function pickDur(rng, base, min, max, mutAmt, modeWide){
    const span = max - min;
    const pTail = clamp(0.10 + 0.25 * mutAmt + 0.12 * (modeWide/3.0), 0.10, 0.55);
    const pUni  = clamp(0.10 + 0.20 * mutAmt, 0.10, 0.35);
    const rr = rng();

    let v;
    if (rr < pTail){
      const u = Math.pow(rng(), 0.35);
      v = min + u * span;
    } else if (rr < pTail + pUni){
      v = min + rng() * span;
    } else {
      const tri = triRand(rng);
      const jitter = (tri - 0.5) * 2.0 * span * (0.35 + 0.45 * mutAmt) * modeWide;
      v = base + jitter;
    }
    return clamp(v, min, max);
  }

  let ctx = null;
  let masterGain, compressor, postGain, crusher = null;
  let globalStop = [];
  let audioReady = false;

  const STEREO = { entry:null, bands:[], dry:null };

  function ensureAudio(){
    if (ctx) return ctx;
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    masterGain = ctx.createGain();
    compressor = ctx.createDynamicsCompressor();
    postGain = ctx.createGain();

    masterGain.gain.value = parseFloat($("#master").value);
    compressor.threshold.value = -18;
    compressor.knee.value = 24;
    compressor.ratio.value = 8;
    compressor.attack.value = 0.003;
    compressor.release.value = 0.12;
    postGain.gain.value = 0.95;

    masterGain.connect(compressor);
    compressor.connect(postGain);
    postGain.connect(ctx.destination);

    buildStereoBands();
    return ctx;
  }

  const now = () => ctx.currentTime;

  function makeBitcrusher(ctx){
    const inGain = ctx.createGain();
    const outGain = ctx.createGain();
    const proc = ctx.createScriptProcessor(1024, 1, 1);
    proc._ph = 0;
    proc._last = 0;

    proc.onaudioprocess = (e) => {
      const input = e.inputBuffer.getChannelData(0);
      const output = e.outputBuffer.getChannelData(0);

      const amount = parseFloat($("#crush").value);
      const step = Math.floor(lerp(1, 20, amount));
      const bits = Math.floor(lerp(16, 5, amount));
      const levels = (1 << bits) - 1;

      let ph = proc._ph;
      let last = proc._last;

      for (let i=0;i<input.length;i++){
        ph++;
        if (ph >= step){
          ph = 0;
          const q = Math.round((input[i] * 0.5 + 0.5) * levels) / levels;
          last = (q - 0.5) * 2.0;
        }
        output[i] = last;
      }
      proc._ph = ph;
      proc._last = last;
    };

    inGain.connect(proc);
    proc.connect(outGain);
    return { input: inGain, output: outGain, node: proc };
  }

  function ensureCrusher(){
    if (!crusher){
      crusher = makeBitcrusher(ctx);
      crusher.output.connect(STEREO.entry);
    }
  }

  function buildStereoBands(){
    STEREO.entry = ctx.createGain();
    STEREO.entry.gain.value = 1.0;

    const centers = [80, 120, 180, 260, 380, 560, 820, 1200, 2000, 3800, 6500, 9000];
    const Qs      = [1.2,1.4,1.6,1.8,2.0,2.2,2.4,2.6,2.8,3.0,3.2,3.4];

    centers.forEach((fc, i) => {
      const bp = ctx.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.value = fc;
      bp.Q.value = Qs[i % Qs.length];

      const pan = ctx.createStereoPanner();
      pan.pan.value = 0;

      const g = ctx.createGain();
      g.gain.value = 0.16;

      STEREO.entry.connect(bp);
      bp.connect(g);
      g.connect(pan);
      pan.connect(masterGain);

      STEREO.bands.push({ bp, pan, gain:g, fc });
    });

    STEREO.dry = ctx.createGain();
    STEREO.dry.gain.value = 0.55;
    STEREO.entry.connect(STEREO.dry);
    STEREO.dry.connect(masterGain);
  }

  function randomizeStereoByFreq(rng){
    if (!STEREO.entry || !STEREO.bands.length) return;
    STEREO.bands.forEach((b) => {
      const fNorm = clamp((Math.log(b.fc) - Math.log(80)) / (Math.log(9000) - Math.log(80)), 0, 1);
      const maxPan = lerp(0.35, 1.0, fNorm);
      const pan = (rng()*2 - 1) * maxPan;

      const gJ = lerp(0.10, 0.26, rng());
      b.gain.gain.setValueAtTime(gJ, now());
      b.pan.pan.setValueAtTime(pan, now());
    });
  }

  function scheduleStopDisconnect(node, tStop){
    globalStop.push(() => { try{ node.disconnect(); }catch(e){} });
    if (tStop != null){
      setTimeout(() => { try{ node.disconnect(); }catch(e){} }, Math.max(0, (tStop - now()) * 1000));
    }
  }

  function stopAll(){
    globalStop.forEach(fn => { try{ fn(); }catch(e){} });
    globalStop.length = 0;
  }

  let noiseBuf = null;
  function getNoiseBuffer(){
    if (noiseBuf) return noiseBuf;
    const dur = 2.0;
    const len = Math.floor(ctx.sampleRate * dur);
    const buf = ctx.createBuffer(1, len, ctx.sampleRate);
    const d = buf.getChannelData(0);

    let lfsr = 0xACE1;
    for (let i=0;i<len;i++){
      const bit = ((lfsr >> 0) ^ (lfsr >> 2) ^ (lfsr >> 3) ^ (lfsr >> 5)) & 1;
      lfsr = (lfsr >> 1) | (bit << 15);
      d[i] = ((lfsr & 1) ? 1 : -1) * 0.9;
    }
    noiseBuf = buf;
    return noiseBuf;
  }
  function noiseSource(){
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    src.loop = true;
    return src;
  }

  function feedbackDelay(input, timeSec, feedback, wet){
    const d = ctx.createDelay(1.0);
    d.delayTime.value = timeSec;
    const fb = ctx.createGain();
    fb.gain.value = feedback;

    const wetG = ctx.createGain();
    wetG.gain.value = wet;

    const dryG = ctx.createGain();
    dryG.gain.value = 1.0 - wet;

    input.connect(dryG);
    input.connect(d);
    d.connect(fb);
    fb.connect(d);

    const out = ctx.createGain();
    dryG.connect(out);
    d.connect(wetG);
    wetG.connect(out);

    return { out, delay:d, fb, wetG, dryG };
  }

  const BASE = {
    laser:      { baseHz: 900,  sweepHz: 520,  sweepTime: 0.055, bite: 0.55, click: 0.12, noise: 0.08, hp: 260, dur: 0.14 },
    zap:        { baseHz: 220,  sweepHz: 1400, sweepTime: 0.090, fmAmt: 180, fmHz: 32, noise: 0.18, bp: 1200, q: 8, dur: 0.22 },
    thrust:     { noise: 0.75,  lp: 520, q: 0.8, flutterHz: 16, flutterAmt: 0.18, dur: 0.45 },
    explosion:  { noise: 1.0,   lp0: 3800, lp1: 240, sweepTime: 0.32, boomHz: 62, boomAmt: 0.65, crackle: 0.25, dur: 0.95 },
    pickup:     { baseHz: 660,  upHz: 1320, glide: 0.12, vibHz: 10, vibAmt: 0.02, twang: 0.35, dur: 0.35 },
    alarm:      { aHz: 520,     bHz: 860,  rate: 9.0, edge: 0.6, dur: 0.95 },

    smartbomb:  { dur: 1.40, boomHz: 44, boomAmt: 0.9, sweep0: 5200, sweep1: 180, sweepTime: 0.75, ringHz: 220, ringAmt: 0.35, noise: 1.0, crackle: 0.35 },
    hyperspace: { dur: 1.20, whooshLP0: 4200, whooshLP1: 220, whooshTime: 0.75, tone0: 180, tone1: 1500, toneTime: 0.55, edge: 0.55, delayT: 0.075, delayFb: 0.45, wet: 0.35 },
    teleport:   { dur: 0.60, chirp0: 420, chirp1: 2200, chirpTime: 0.14, sparkleBP: 1800, sparkleQ: 9, sparkle: 0.28, edge: 0.45, delayT: 0.045, delayFb: 0.25, wet: 0.22 }
  };
  let patch = JSON.parse(JSON.stringify(BASE));

  let REV = 0;
  function resetToBase(){ patch = JSON.parse(JSON.stringify(BASE)); }

  function randomizeAll(){
    REV++;
    $("#revTag").textContent = `rev#${REV}`;

    const mode = $("#mode").value;
    const mutAmt = parseFloat($("#mutAmt").value);
    const { wide, jumpP, jumpScale } = modeConfig(mode);

    const seedStr = `${$("#seed").value}|${mode}|${REV}`;
    const rng = mulberry32(hash32(seedStr));

    const r  = (name, key, min, max) => patch[name][key] = pickVal(rng, BASE[name][key], min, max, mutAmt, wide, jumpP, jumpScale);
    const rd = (name, key, min, max) => patch[name][key] = pickDur(rng, BASE[name][key], min, max, mutAmt, wide);

    r("laser","baseHz",   260, 2200); r("laser","sweepHz",  60,  2600); r("laser","sweepTime",0.018,0.22);
    r("laser","bite",     0.02,1.00); r("laser","click",    0.00,0.45); r("laser","noise",    0.00,0.65);
    r("laser","hp",       30,  2200); rd("laser","dur",     0.05,2.20);

    r("zap","baseHz",     50,  900);  r("zap","sweepHz",    180, 5000); r("zap","sweepTime",  0.020,0.35);
    r("zap","fmAmt",      0,   2200); r("zap","fmHz",       2,   220);  r("zap","noise",      0.00,0.90);
    r("zap","bp",         160, 5200); r("zap","q",          0.6, 40);   rd("zap","dur",       0.07,2.60);

    r("thrust","noise",     0.10,1.00); r("thrust","lp",        80,  2400); r("thrust","q",         0.2, 10.0);
    r("thrust","flutterHz", 0.5, 60);   r("thrust","flutterAmt",0.00,0.75); rd("thrust","dur",      0.12,3.20);

    r("explosion","noise",     0.15,1.00); r("explosion","lp0",       600, 10000); r("explosion","lp1",       40,  1200);
    r("explosion","sweepTime", 0.10,2.20); r("explosion","boomHz",    16,  220);   r("explosion","boomAmt",   0.05,1.00);
    r("explosion","crackle",   0.00,1.00); rd("explosion","dur",      0.18,4.20);

    r("pickup","baseHz",  120, 2200); r("pickup","upHz",    220, 8200); r("pickup","glide",   0.02,0.70);
    r("pickup","vibHz",   0.5, 50);   r("pickup","vibAmt",  0.0, 0.20); r("pickup","twang",   0.00,1.00);
    rd("pickup","dur",    0.05,2.80);

    r("alarm","aHz",  80,  2200); r("alarm","bHz",  120, 5200); r("alarm","rate", 0.5, 40.0);
    r("alarm","edge", 0.00,1.00); rd("alarm","dur", 0.12,5.00);

    rd("smartbomb","dur",      0.25,5.50); r("smartbomb","boomHz",    10,  160); r("smartbomb","boomAmt",   0.05,1.00);
    r("smartbomb","sweep0",    700, 12000); r("smartbomb","sweep1",    30,  1800); r("smartbomb","sweepTime", 0.12,4.00);
    r("smartbomb","ringHz",    30,  1600);  r("smartbomb","ringAmt",   0.00,1.00); r("smartbomb","noise",     0.10,1.00);
    r("smartbomb","crackle",   0.00,1.00);

    rd("hyperspace","dur",       0.18,4.50); r("hyperspace","whooshLP0",  500, 12000); r("hyperspace","whooshLP1",  40,  2200);
    r("hyperspace","whooshTime", 0.10,3.20); r("hyperspace","tone0",      20,  900);   r("hyperspace","tone1",      80,  9000);
    r("hyperspace","toneTime",   0.06,2.60); r("hyperspace","edge",       0.00,1.00);  r("hyperspace","delayT",     0.010,0.250);
    r("hyperspace","delayFb",    0.00,0.88); r("hyperspace","wet",        0.00,0.85);

    rd("teleport","dur",         0.06,2.80); r("teleport","chirp0",       40,  2200); r("teleport","chirp1",       120, 12000);
    r("teleport","chirpTime",    0.02,0.95); r("teleport","sparkleBP",    120, 9000); r("teleport","sparkleQ",     0.6, 55.0);
    r("teleport","sparkle",      0.00,1.00); r("teleport","edge",         0.00,1.00); r("teleport","delayT",       0.005,0.180);
    r("teleport","delayFb",      0.00,0.78); r("teleport","wet",          0.00,0.80);
  }

  function routeToConsoleStereo(node){
    ensureCrusher();
    const local = ctx.createGain();
    local.gain.value = 1.0;
    node.connect(local);
    local.connect(crusher.input);
    globalStop.push(() => { try{ local.disconnect(); }catch(e){} });
    return local;
  }

  function playLaser(rng){
    const p = patch.laser, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const osc = ctx.createOscillator();
    osc.type = "square";
    osc.frequency.setValueAtTime(p.baseHz + p.sweepHz, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(20, p.baseHz), t0 + p.sweepTime);

    const shaper = ctx.createWaveShaper();
    shaper.curve = makeDriveCurve(lerp(10, 900, p.bite));
    shaper.oversample = "2x";

    const n = noiseSource();
    const nG = ctx.createGain(); nG.gain.value = 0;

    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.value = p.hp;

    const mixTone = ctx.createGain(); mixTone.gain.value = 1.0 - p.noise;
    const mixNoise = ctx.createGain(); mixNoise.gain.value = p.noise;

    const tEnd = adsrToZeroLinear(g.gain, t0, 0.002, Math.max(0.04, p.dur), 0, 0.001, 0.9);
    adsrToZeroLinear(nG.gain, t0, 0.001, Math.min(0.12, 0.02 + p.dur*0.25), 0, 0.001, Math.max(0.001, p.click));

    osc.connect(shaper); shaper.connect(mixTone);
    n.connect(hp); hp.connect(nG); nG.connect(mixNoise);
    mixTone.connect(g); mixNoise.connect(g);

    g.connect(out);
    routeToConsoleStereo(out);

    osc.start(t0); osc.stop(tEnd + 0.05);
    n.start(t0);   n.stop(tEnd + 0.05);

    scheduleStopDisconnect(out, tEnd + 0.25);
  }

  function playZap(rng){
    const p = patch.zap, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const osc = ctx.createOscillator();
    osc.type = "sawtooth";
    osc.frequency.setValueAtTime(p.baseHz, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(30, p.sweepHz), t0 + p.sweepTime);

    const mod = ctx.createOscillator();
    mod.type = "sine";
    mod.frequency.value = p.fmHz;
    const modG = ctx.createGain();
    modG.gain.value = p.fmAmt;
    mod.connect(modG);
    modG.connect(osc.frequency);

    const n = noiseSource();
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = p.bp;
    bp.Q.value = p.q;

    const mixTone = ctx.createGain(); mixTone.gain.value = 0.85;
    const mixNoise= ctx.createGain(); mixNoise.gain.value= p.noise;

    const tEnd = adsrToZeroLinear(g.gain, t0, 0.003, Math.max(0.05, p.dur), 0, 0.001, 1.0);

    osc.connect(mixTone);
    n.connect(bp); bp.connect(mixNoise);
    mixTone.connect(g); mixNoise.connect(g);

    g.connect(out);
    routeToConsoleStereo(out);

    osc.start(t0); osc.stop(tEnd + 0.05);
    mod.start(t0); mod.stop(tEnd + 0.05);
    n.start(t0);   n.stop(tEnd + 0.05);

    scheduleStopDisconnect(out, tEnd + 0.30);
  }

  function playThrust(rng){
    const p = patch.thrust, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const n = noiseSource();
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(p.lp, t0);
    lp.Q.value = p.q;

    const lfo = ctx.createOscillator();
    lfo.type = "sine";
    lfo.frequency.value = p.flutterHz;
    const lfoG = ctx.createGain();
    lfoG.gain.value = p.flutterAmt * 0.35;
    lfo.connect(lfoG);
    lfoG.connect(g.gain);

    const tEnd = adsrToZeroLinear(g.gain, t0, 0.008, Math.max(0.08, p.dur), 0, 0.001, 0.7);

    const mix = ctx.createGain();
    mix.gain.value = p.noise;

    n.connect(lp); lp.connect(mix); mix.connect(g);
    g.connect(out);
    routeToConsoleStereo(out);

    n.start(t0); n.stop(tEnd + 0.08);
    lfo.start(t0); lfo.stop(tEnd + 0.08);

    scheduleStopDisconnect(out, tEnd + 0.35);
  }

  function playExplosion(rng){
    const p = patch.explosion, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const A = 0.003;
    const D = clamp(p.dur, 0.08, 6.0);
    const R = 0.012;

    const tEnd = adsrToZeroLinear(g.gain, t0, A, D, 0, R, 1.0);

    const n = noiseSource();
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(p.lp0, t0);
    lp.frequency.exponentialRampToValueAtTime(Math.max(50, p.lp1), t0 + Math.min(p.sweepTime, D));
    lp.Q.value = 0.7;
    const nG = ctx.createGain(); nG.gain.value = 0;
    adsrToZeroLinear(nG.gain, t0, A, D, 0, R, clamp(p.noise, 0, 1));

    const boom = ctx.createOscillator();
    boom.type = "sine";
    boom.frequency.setValueAtTime(p.boomHz * 1.2, t0);
    boom.frequency.exponentialRampToValueAtTime(Math.max(12, p.boomHz), t0 + Math.min(0.35, D));
    const boomG = ctx.createGain(); boomG.gain.value = 0;
    adsrToZeroLinear(boomG.gain, t0, 0.002, Math.max(0.06, D*0.65), 0, R, clamp(p.boomAmt, 0, 1));

    const crack = noiseSource();
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.value = 1200;
    const crackG = ctx.createGain(); crackG.gain.value = 0;
    adsrToZeroLinear(crackG.gain, t0, 0.001, Math.max(0.04, D*0.45), 0, R, clamp(p.crackle, 0, 1));

    const mix = ctx.createGain(); mix.gain.value = 1.0;

    n.connect(lp); lp.connect(nG); nG.connect(mix);
    boom.connect(boomG); boomG.connect(mix);
    crack.connect(hp); hp.connect(crackG); crackG.connect(mix);

    mix.connect(g);
    g.connect(out);
    routeToConsoleStereo(out);

    n.start(t0); n.stop(tEnd + 0.12);
    crack.start(t0); crack.stop(tEnd + 0.12);
    boom.start(t0); boom.stop(tEnd + 0.12);

    scheduleStopDisconnect(out, tEnd + 0.70);
  }

  function playPickup(rng){
    const p = patch.pickup, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const osc = ctx.createOscillator();
    osc.type = "triangle";
    osc.frequency.setValueAtTime(p.baseHz, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(30, p.upHz), t0 + p.glide);

    const vib = ctx.createOscillator();
    vib.type = "sine";
    vib.frequency.value = p.vibHz;
    const vibG = ctx.createGain();
    vibG.gain.value = p.vibAmt * p.baseHz;
    vib.connect(vibG);
    vibG.connect(osc.frequency);

    const sh = ctx.createWaveShaper();
    sh.curve = makeDriveCurve(lerp(5, 900, p.twang));
    sh.oversample = "2x";

    const tEnd = adsrToZeroLinear(g.gain, t0, 0.004, Math.max(0.06, p.dur), 0, 0.01, 0.8);

    osc.connect(sh); sh.connect(g);
    g.connect(out);
    routeToConsoleStereo(out);

    osc.start(t0); osc.stop(tEnd + 0.06);
    vib.start(t0); vib.stop(tEnd + 0.06);

    scheduleStopDisconnect(out, tEnd + 0.25);
  }

  function playAlarm(rng){
    const p = patch.alarm, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const osc = ctx.createOscillator();
    osc.type = "square";
    osc.frequency.setValueAtTime(p.aHz, t0);

    const step = ctx.createOscillator();
    step.type = "square";
    step.frequency.value = p.rate;

    const stepG = ctx.createGain();
    stepG.gain.value = (p.bHz - p.aHz) * 0.5;
    step.connect(stepG);
    stepG.connect(osc.frequency);

    const sh = ctx.createWaveShaper();
    sh.curve = makeDriveCurve(lerp(5, 900, p.edge));
    sh.oversample = "2x";

    const tEnd = adsrToZeroLinear(g.gain, t0, 0.010, Math.max(0.10, p.dur), 0, 0.01, 0.55);

    osc.connect(sh); sh.connect(g);
    g.connect(out);
    routeToConsoleStereo(out);

    osc.start(t0);  osc.stop(tEnd + 0.06);
    step.start(t0); step.stop(tEnd + 0.06);

    scheduleStopDisconnect(out, tEnd + 0.30);
  }

  function playSmartBomb(rng){
    const p = patch.smartbomb, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const A = 0.003;
    const D = clamp(p.dur, 0.10, 8.0);
    const R = 0.014;

    const tEnd = adsrToZeroLinear(g.gain, t0, A, D, 0, R, 1.0);

    const n = noiseSource();
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(p.sweep0, t0);
    lp.frequency.exponentialRampToValueAtTime(Math.max(40, p.sweep1), t0 + Math.min(p.sweepTime, D));
    lp.Q.value = 0.75;
    const nG = ctx.createGain(); nG.gain.value = 0;
    adsrToZeroLinear(nG.gain, t0, A, D, 0, R, clamp(p.noise, 0, 1));

    const boom = ctx.createOscillator();
    boom.type = "sine";
    boom.frequency.setValueAtTime(p.boomHz * 1.15, t0);
    boom.frequency.exponentialRampToValueAtTime(Math.max(10, p.boomHz), t0 + Math.min(0.50, D));
    const boomG = ctx.createGain(); boomG.gain.value = 0;
    adsrToZeroLinear(boomG.gain, t0, 0.002, Math.max(0.08, D*0.75), 0, R, clamp(p.boomAmt, 0, 1));

    const ring = ctx.createOscillator();
    ring.type = "square";
    ring.frequency.setValueAtTime(p.ringHz, t0);
    ring.frequency.exponentialRampToValueAtTime(Math.max(10, p.ringHz * 0.45), t0 + Math.min(1.0, D*0.6));
    const ringG = ctx.createGain(); ringG.gain.value = 0;
    adsrToZeroLinear(ringG.gain, t0, 0.002, Math.max(0.08, D*0.85), 0, R, clamp(p.ringAmt, 0, 1));

    const ringSh = ctx.createWaveShaper();
    ringSh.curve = makeDriveCurve(lerp(5, 700, 0.6));
    ringSh.oversample = "2x";

    const crack = noiseSource();
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.value = 1000;
    const crackG = ctx.createGain(); crackG.gain.value = 0;
    adsrToZeroLinear(crackG.gain, t0, 0.001, Math.max(0.05, D*0.55), 0, R, clamp(p.crackle, 0, 1));

    const mix = ctx.createGain(); mix.gain.value = 1.0;

    n.connect(lp); lp.connect(nG); nG.connect(mix);
    boom.connect(boomG); boomG.connect(mix);
    ring.connect(ringSh); ringSh.connect(ringG); ringG.connect(mix);
    crack.connect(hp); hp.connect(crackG); crackG.connect(mix);

    mix.connect(g);
    g.connect(out);
    routeToConsoleStereo(out);

    n.start(t0); n.stop(tEnd + 0.12);
    crack.start(t0); crack.stop(tEnd + 0.12);
    boom.start(t0); boom.stop(tEnd + 0.12);
    ring.start(t0); ring.stop(tEnd + 0.12);

    scheduleStopDisconnect(out, tEnd + 0.70);
  }

  function playHyperspace(rng){
    const p = patch.hyperspace, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const n = noiseSource();
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(p.whooshLP0, t0);
    lp.frequency.exponentialRampToValueAtTime(Math.max(60, p.whooshLP1), t0 + p.whooshTime);
    lp.Q.value = 0.8;
    const nG = ctx.createGain(); nG.gain.value = 0.65;

    const osc = ctx.createOscillator();
    osc.type = "sawtooth";
    osc.frequency.setValueAtTime(p.tone0, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(20, p.tone1), t0 + p.toneTime);

    const sh = ctx.createWaveShaper();
    sh.curve = makeDriveCurve(lerp(5, 1100, p.edge));
    sh.oversample = "2x";
    const oG = ctx.createGain(); oG.gain.value = 0.40;

    const mix = ctx.createGain();
    n.connect(lp); lp.connect(nG); nG.connect(mix);
    osc.connect(sh); sh.connect(oG); oG.connect(mix);

    const fx = feedbackDelay(mix, p.delayT, p.delayFb, p.wet);

    const tEnd = adsrToZeroLinear(g.gain, t0, 0.010, Math.max(0.10, p.dur), 0, 0.01, 0.85);

    fx.out.connect(g);
    g.connect(out);
    routeToConsoleStereo(out);

    n.start(t0);   n.stop(tEnd + 0.10);
    osc.start(t0); osc.stop(tEnd + 0.10);

    scheduleStopDisconnect(out, tEnd + 0.45);
  }

  function playTeleport(rng){
    const p = patch.teleport, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const osc = ctx.createOscillator();
    osc.type = "triangle";
    osc.frequency.setValueAtTime(p.chirp0, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(20, p.chirp1), t0 + p.chirpTime);

    const sh = ctx.createWaveShaper();
    sh.curve = makeDriveCurve(lerp(5, 1100, p.edge));
    sh.oversample = "2x";
    const oG = ctx.createGain(); oG.gain.value = 0.60;

    const n = noiseSource();
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = p.sparkleBP;
    bp.Q.value = p.sparkleQ;
    const nG = ctx.createGain(); nG.gain.value = p.sparkle;

    const mix = ctx.createGain();
    osc.connect(sh); sh.connect(oG); oG.connect(mix);
    n.connect(bp); bp.connect(nG); nG.connect(mix);

    const fx = feedbackDelay(mix, p.delayT, p.delayFb, p.wet);

    const tEnd = adsrToZeroLinear(g.gain, t0, 0.003, Math.max(0.06, p.dur), 0, 0.01, 0.85);

    fx.out.connect(g);
    g.connect(out);
    routeToConsoleStereo(out);

    osc.start(t0); osc.stop(tEnd + 0.08);
    n.start(t0);   n.stop(tEnd + 0.08);

    scheduleStopDisconnect(out, tEnd + 0.30);
  }

  const status = $("#status");

  function setControlsEnabled(enabled){
    const ids = ["laser","zap","thrust","explosion","pickup","alarm","smartbomb","hyperspace","teleport","randAll","resetBase","master","crush","mode","mutAmt","seed"];
    ids.forEach(id => { const el = $("#"+id); if (el) el.disabled = !enabled; });
  }

  function stopThenPlay(playFn){
    if (!audioReady || !ctx) return;
    stopAll();

    const tag = `${$("#seed").value}|${$("#mode").value}|${REV}|play|${performance.now().toFixed(3)}`;
    const rng = mulberry32(hash32(tag));
    randomizeStereoByFreq(rng);

    playFn(rng);
  }

  function syncReadouts(){
    $("#masterVal").textContent = (+$("#master").value).toFixed(2);
    $("#crushVal").textContent  = (+$("#crush").value).toFixed(2);
    $("#mutAmtVal").textContent = (+$("#mutAmt").value).toFixed(2);
    $("#modeVal").textContent   = $("#mode").value;
  }

  async function startSession(){
    ensureAudio();
    ensureCrusher();
    if (ctx.state !== "running") await ctx.resume();
    audioReady = true;
    $("#startOverlay").style.display = "none";
    setControlsEnabled(true);
    masterGain.gain.value = parseFloat($("#master").value);
    status.textContent = "";
  }

  function hook(){
    setControlsEnabled(false);
    syncReadouts();

    $("#bigStartBtn").addEventListener("click", startSession);
    $("#startOverlay").addEventListener("click", (e) => {
      if (e.target.id === "startOverlay") startSession();
    });

    $("#master").addEventListener("input", (e) => {
      $("#masterVal").textContent = (+e.target.value).toFixed(2);
      if (masterGain) masterGain.gain.value = +e.target.value;
    });
    $("#crush").addEventListener("input", (e) => { $("#crushVal").textContent = (+e.target.value).toFixed(2); });
    $("#mutAmt").addEventListener("input", (e) => { $("#mutAmtVal").textContent = (+e.target.value).toFixed(2); });
    $("#mode").addEventListener("change", () => { $("#modeVal").textContent = $("#mode").value; });

    $("#randAll").addEventListener("click", () => {
      if (!audioReady) return;
      stopAll();
      randomizeAll();
      status.textContent = "randomized";
      setTimeout(() => { if (status.textContent === "randomized") status.textContent = ""; }, 650);
    });

    $("#resetBase").addEventListener("click", () => {
      if (!audioReady) return;
      stopAll();
      resetToBase();
      $("#revTag").textContent = "rev#0";
      REV = 0;
      status.textContent = "reset";
      setTimeout(() => { if (status.textContent === "reset") status.textContent = ""; }, 650);
    });

    $("#laser").addEventListener("click", () => stopThenPlay(playLaser));
    $("#zap").addEventListener("click", () => stopThenPlay(playZap));
    $("#thrust").addEventListener("click", () => stopThenPlay(playThrust));
    $("#explosion").addEventListener("click", () => stopThenPlay(playExplosion));
    $("#pickup").addEventListener("click", () => stopThenPlay(playPickup));
    $("#alarm").addEventListener("click", () => stopThenPlay(playAlarm));
    $("#smartbomb").addEventListener("click", () => stopThenPlay(playSmartBomb));
    $("#hyperspace").addEventListener("click", () => stopThenPlay(playHyperspace));
    $("#teleport").addEventListener("click", () => stopThenPlay(playTeleport));

    window.addEventListener("keydown", (e) => {
      if (e.repeat) return;
      if (!audioReady && (e.key === "Enter" || e.key === " ")){ e.preventDefault(); startSession(); return; }
      if (!audioReady) return;
      if (e.key === "r" || e.key === "R"){ $("#randAll").click(); return; }
      const map = {"1":"laser","2":"zap","3":"thrust","4":"explosion","5":"pickup","6":"alarm","7":"smartbomb","8":"hyperspace","9":"teleport"};
      if (map[e.key]) $("#"+map[e.key]).click();
    });
  }

  hook();
})();
</script>
</body>
</html>
