<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Groove Dynamics</title>
  <style>
    :root { --green:#7dd35f; }

    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      color: var(--green);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      transition: background-color 80ms linear;
      touch-action: manipulation;
    }

    .app{
      height: calc(var(--vh, 1vh) * 100);
      display: grid;
      place-items: center;
    }

    /* Single centered round Start button */
    #startBtn {
      width: min(180px, 46vw);
      height: min(180px, 46vw);
      border-radius: 999px;
      border: 2px solid var(--green);
      background: rgba(0,0,0,0.15);
      color: var(--green);
      font-size: 22px;
      font-weight: 800;
      letter-spacing: 0.02em;
      box-shadow: 0 0 22px rgba(125,211,95,0.18);
      -webkit-tap-highlight-color: transparent;
      user-select: none;
    }
    #startBtn:active { transform: scale(0.98); }
    #startBtn:disabled { opacity: 0.55; }
  </style>
</head>
<body>
  <main class="app">
    <button id="startBtn">Start</button>
  </main>

  <!-- Ably JS -->
  <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>

  <!-- center button on screen hack -->
  <script>
    (function setVhUnit(){
      const root = document.documentElement;

      const set = () => {
        const vv = window.visualViewport;
        const h = (vv && vv.height) ? vv.height : window.innerHeight;
        root.style.setProperty('--vh', (h * 0.01) + 'px');
      };

      set();

      window.addEventListener('resize', set, { passive: true });
      window.addEventListener('orientationchange', set, { passive: true });
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', set, { passive: true });
        window.visualViewport.addEventListener('scroll', set, { passive: true });
      }
    })();
  </script>

  <script>
  (() => {
    // =========================================================================
    // UI (single button only) â€” Start â†’ Orient Phone â†’ Stop
    // =========================================================================
    const startBtn = document.getElementById('startBtn');

    const UI = {
      state: "idle",   // "idle" | "running_need_orient" | "running_oriented"
    };

    function setBtn(label){
      startBtn.textContent = label;
    }

    // =========================================================================
    // Keep phone glow mapping (background color), driven by energy
    // =========================================================================
    const BG0 = { r: 0,   g: 0,  b: 0  };
    const BG1 = { r: 255, g: 42, b: 0  };
    function setBgFromEnergy(e01) {
      const t = Math.max(0, Math.min(1, e01));
      const r = Math.round(BG0.r + (BG1.r - BG0.r) * t);
      const g = Math.round(BG0.g + (BG1.g - BG0.g) * t);
      const b = Math.round(BG0.b + (BG1.b - BG0.b) * t);
      document.body.style.backgroundColor = `rgb(${r},${g},${b})`;
    }
    setBgFromEnergy(0);

    // =========================================================================
    // RELAY (Ably via Cloudflare Worker token) â€” logic preserved
    // =========================================================================
    const WORKER_BASE = "https://orb-token.mrgarthwilliams.workers.dev";
    const TOKEN_URL = WORKER_BASE + "/token";

    function parseRoom() {
      const u = new URL(window.location.href);
      const raw = (u.searchParams.get("room") || "test").trim();
      const roomCode = raw.startsWith("orb:") ? raw.slice(4) : raw;
      const channelName = "orb:" + roomCode;
      return { raw, roomCode, channelName };
    }

    let ably = null;
    let ablyChannel = null;

    const roomInfo = parseRoom();
    const room = roomInfo.channelName;
    const roomCode = roomInfo.roomCode;

    async function connectRelay() {
      try { if (ablyChannel) ablyChannel.detach(); } catch(e) {}
      try { if (ably) ably.close(); } catch(e) {}
      ably = null; ablyChannel = null;

      const authUrl =
        TOKEN_URL +
        "?room=" + encodeURIComponent(roomCode) +
        "&clientId=" + encodeURIComponent("phone-" + Math.random().toString(16).slice(2,6));

      // Quick preflight (kept)
      try {
        const r = await fetch(authUrl, { method: "GET", cache: "no-store" });
        const j = await r.json();
        if (!r.ok || !j.token) return false;
      } catch (e) {
        return false;
      }

      ably = new Ably.Realtime({ authUrl, autoConnect: true });
      ablyChannel = ably.channels.get(room);

      // Await attach so we donâ€™t publish into a not-yet-attached channel.
      await new Promise((resolve) => {
        ablyChannel.attach(() => resolve());
      });

      // ðŸš« NOTE: No "cmd" subscription by request (phone owns orientation flow)

      return true;
    }

    function disconnectRelay() {
      try { if (ablyChannel) ablyChannel.detach(); } catch(e) {}
      try { if (ably) ably.close(); } catch(e) {}
      ably = null; ablyChannel = null;
    }

    // =========================================================================
    // NETWORK THROTTLE (unchanged)
    // =========================================================================
    const SEND_HZ = 12;
    const SEND_MIN_MS = 1000 / SEND_HZ;

    // =========================================================================
    // TELEMETRY SIZE SWITCH
    // =========================================================================
    const TELEMETRY = false;
    const TELEMETRY_URL = (() => {
      try {
        const u = new URL(location.href);
        return (u.searchParams.get("telemetry") === "1");
      } catch { return false; }
    })();
    const TELEMETRY_ON = TELEMETRY || TELEMETRY_URL;

    // =========================================================================
    // 1) FALL DRAG DEFAULT (requested)
    // =========================================================================
    const FALL_DRAG_DEFAULT = 1.0;

    const EPS = {
      energy01:    0.006,
      groove01:    0.008,
      dynamics01:  0.008,
      smooth01:    0.008,
      speed01:     0.008,
      shake01:     0.015,
      hz:          0.030,
    };

    let nextSendAtMs = 0;
    let lastSig = null;

    function roundN(x, n=4){
      const v = Number(x);
      if (!isFinite(v)) return 0;
      const p = Math.pow(10, n);
      return Math.round(v * p) / p;
    }

    function buildSigFromPayload(p){
      return {
        energy01:    roundN(p.energy01, 4),
        groove01:    roundN(p.groove01, 4),
        dynamics01:  roundN(p.dynamics01, 4),
        smooth01:    roundN(p.smooth01, 4),
        speed01:     roundN(p.speed01, 4),
        shake01:     roundN(p.shake01, 4),
        locked:      !!p.locked,
        shakeHit:    !!p.shakeHit,
        hz:          roundN(p.hz, 3),
      };
    }

    function sigChanged(sig){
      if (!lastSig) return true;

      if (sig.shakeHit && !lastSig.shakeHit) return true;
      if (sig.locked !== lastSig.locked) return true;

      if (Math.abs(sig.energy01   - lastSig.energy01)   > EPS.energy01) return true;
      if (Math.abs(sig.groove01   - lastSig.groove01)   > EPS.groove01) return true;
      if (Math.abs(sig.dynamics01 - lastSig.dynamics01) > EPS.dynamics01) return true;
      if (Math.abs(sig.smooth01   - lastSig.smooth01)   > EPS.smooth01) return true;
      if (Math.abs(sig.speed01    - lastSig.speed01)    > EPS.speed01) return true;
      if (Math.abs(sig.shake01    - lastSig.shake01)    > EPS.shake01) return true;
      if (Math.abs(sig.hz         - lastSig.hz)         > EPS.hz) return true;

      return false;
    }

    // =========================================================================
    // publishDynamics trims payload when TELEMETRY_ON is false
    // =========================================================================
    function publishDynamics(payload, dt, force=false) {
      if (!ablyChannel) return;

      const now = performance.now();
      if (!force && now < nextSendAtMs) return;

      const sig = buildSigFromPayload(payload);
      if (!force && !sigChanged(sig)) return;

      lastSig = sig;
      nextSendAtMs = now + SEND_MIN_MS;

      const out = {
        room: payload.room,
        fallDrag: FALL_DRAG_DEFAULT,

        energy01:   sig.energy01,
        groove01:   sig.groove01,
        dynamics01: sig.dynamics01,
        smooth01:   sig.smooth01,
        speed01:    sig.speed01,
        shake01:    sig.shake01,
        locked:     sig.locked,
        shakeHit:   sig.shakeHit,
        hz:         sig.hz,
      };

      // send shake direction ONLY when a shakeHit fires (lean)
      if (payload.shakeHit && payload.sd) out.sd = payload.sd;

      // orient status only as tiny pings (1 during step, 1 when done, 0 reset)
      if (payload.oc !== undefined && payload.oc !== null) out.oc = payload.oc;
      if (payload.od !== undefined && payload.od !== null) out.od = payload.od;

      if (TELEMETRY_ON) {
        out.t     = roundN(payload.t, 1);
        out.dt    = roundN(payload.dt, 4);
        out.wRaw  = roundN(payload.wRaw, 2);
        out.wCap  = roundN(payload.wCap, 2);
        out.wFilt = roundN(payload.wFilt, 2);
        out.cap   = roundN(payload.cap, 2);

        out.d_r2      = roundN(payload.d_r2, 4);
        out.d_r3      = roundN(payload.d_r3, 4);
        out.d_gate    = roundN(payload.d_gate, 4);
        out.d_balance = roundN(payload.d_balance, 4);
        out.d_couple  = roundN(payload.d_couple, 4);
      }

      ablyChannel.publish("orb", out, (err) => {
        if (err) console.warn("[ably publish err]", err);
      });
    }

    // =========================================================================
    // DIAL PACK v4 â€” base detection (PRESERVED)
    // =========================================================================
    const OMEGA_LPF = 0.22;

    const HUNT_WINDOW_SEC   = .80;
    const STABLE_WINDOW_SEC = 1.60;

    const MIN_WINDOW_SAMPLES = 28;
    const MAX_WINDOW_SAMPLES = 260;

    const MIN_OMEGA = 0.02;

    const LOCK_ON  = 0.30;
    const LOCK_OFF = 0.22;

    const MIN_HZ = 0.55;
    const MAX_HZ = 2.30;

    const JERK_TIGHT = 220.0;
    const JERK_LOOSE = 2600.0;

    // =========================================================================
    // DYNAMICS â€” v4.0 (DIRECTIONAL DIVERSITY, 1s window) â€” functionally same
    // =========================================================================
    const DYNAMICS_WINDOW_SEC = 1.00;
    const DYNAMICS_FLOOR = 0.18;

    const DYNAMICS_UI_EXP  = 1.0;
    const DYNAMICS_UI_GAIN = 3.5;

    const DYNAMICS_ACTIVITY_MIN01 = 0.06;
    const DYNAMICS_ACTIVITY_POW   = 1.15;

    const ENERGY_GAIN_LOCKED = 1.25;
    const ENERGY_GAIN_FREE   = 0.65;

    const ENERGY_DECAY       = 0.1;

    const UI_SMOOTH   = 0.10;
    const LOCK_SMOOTH = 0.14;

    const GROOVE_EXP    = 0.70;
    const SMOOTH_EXP    = 0.70;
    const DYNAMICS_EXP  = 1.00;

    const EARN_SCALE = 1.00;

    const COAST_QUALITY_MIN  = 0.28;
    const COAST_DECAY_MULT   = 0.65;

    const SMOOTH_KILL_THRESH     = 0.12;
    const SMOOTH_KILL_DECAY_MULT = 3.25;
    const SMOOTH_KILL_UNLOCK     = true;

    const GRACE_SEC = 0.75;

    const RECENTER_SEC = 0.85;
    const RECENTER_GROOVE_MAX = 0.22;

    const NORM_ALPHA = 0.10;

    // ============================================================================
    // SPEED METER â€” tuned for â€œforceâ€ (rotationRate magnitude, deg/sec)
    // ============================================================================
    const SPEED_DEAD_DPS = 8.0;
    const SPEED_CAP_DPS  = 360.0;

    const SPEED_EMA_CUTOFF_FAST_HZ = 1.5;
    const SPEED_EMA_CUTOFF_SLOW_HZ = .10;

    const SPEED_ADAPT_START_DPS = 18.0;
    const SPEED_ADAPT_END_DPS   = 130.0;

    const SPEED_ADAPT_POW = 1.0;

    const SPEED_NORM_DPS = 300.0;
    const SPEED_MAP_POW  = 1.10;

    const SPEED_ATTACK_HZ  = 5.0;
    const SPEED_RELEASE_HZ = 8.0;

    // =========================================================================
    // DISRUPTOR v3 â€” SHAKE (FAST HIT + SLOW METER) + LOW-SMOOTH BOOST
    // =========================================================================
    const SHAKE_BASELINE_HZ = 0.75;
    const SHAKE_HP_DEAD_G   = 0.65;
    const SHAKE_JERK_DEAD   = 10.0;

    const SHAKE_HP_WEIGHT   = 1.00;
    const SHAKE_JERK_WEIGHT = 0.35;

    const SHAKE_METER_GAIN  = 2.10;
    const SHAKE_METER_DECAY = 2.60;

    const SHAKE_SMOOTH_BOOST_START   = 0.45;
    const SHAKE_SMOOTH_THR_DROP_MAX  = 0.60;

    // =========================================================================
    // NEW SHAKE WIN RULE:
    // "When shake meter hits 100% twice in 500ms" => shakeHit
    // =========================================================================
    const SHAKE_WIN_WINDOW_SEC = 0.50;
    const SHAKE_FULL_HI = 0.999;

    // =========================================================================
    // NEW: SHAKE DIRECTION + 2-step orientation flow (PHONE-OWNED)
    // =========================================================================
    const GRAV_LPF_HZ = 2.0;
    const IMPULSE_WIN_SEC = 0.22;
    const VDOM_RATIO = 1.20;
    const ORIENT_MIN_IMP = 0.35;

    // Oriented basis (world-ish, in device coords): X=Left/Right, Y=Forward/Back
    let haveOrient = false;
    let bx = {x:1,y:0,z:0};
    let by = {x:0,y:1,z:0};

    // gravity LPF vector
    let gX=0, gY=0, gZ=9.81;

    // impulse buffer (linear accel)
    const aLinBuf = []; // {t, dt, x,y,z}
    function pushALin(t, dt, ax, ay, az){
      const d = Math.max(1e-4, Number(dt)||0);
      aLinBuf.push({ t, dt:d, x:ax, y:ay, z:az });
      const cutoff = t - 0.55;
      while (aLinBuf.length && aLinBuf[0].t < cutoff) aLinBuf.shift();
    }

    function norm3(x,y,z){ return Math.sqrt(x*x+y*y+z*z); }
    function dot3(ax,ay,az, bx,by,bz){ return ax*bx + ay*by + az*bz; }

    function unit3(x,y,z){
      const m = Math.max(1e-6, norm3(x,y,z));
      return { x:x/m, y:y/m, z:z/m, m };
    }

    function projectToPlane(vx,vy,vz, nx,ny,nz){
      const d = dot3(vx,vy,vz, nx,ny,nz);
      return { x: vx - nx*d, y: vy - ny*d, z: vz - nz*d };
    }

    function orthonormalize(hx,hy,hz, gx,gy,gz){
      const hp = projectToPlane(hx,hy,hz, gx,gy,gz);
      const u = unit3(hp.x, hp.y, hp.z);
      return { x:u.x, y:u.y, z:u.z, mag:u.m };
    }

    function computeImpulse(tNow){
      const t0 = tNow - IMPULSE_WIN_SEC;
      let sx=0, sy=0, sz=0;
      for (let i = aLinBuf.length - 1; i >= 0; i--){
        const s = aLinBuf[i];
        if (s.t < t0) break;
        const w = s.dt;
        sx += s.x * w;
        sy += s.y * w;
        sz += s.z * w;
      }
      return { x:sx, y:sy, z:sz };
    }

    function chooseDirectionFromImpulse(ix,iy,iz, gx,gy,gz){
      const gU = unit3(gx,gy,gz);
      const gHat = {x:gU.x, y:gU.y, z:gU.z};

      const v = dot3(ix,iy,iz, gHat.x,gHat.y,gHat.z);
      const hp = projectToPlane(ix,iy,iz, gHat.x,gHat.y,gHat.z);
      const hMag = norm3(hp.x,hp.y,hp.z);
      const vMag = Math.abs(v);

      if (vMag > (hMag * VDOM_RATIO)) {
        return (v >= 0) ? "D" : "U";
      }

      // If not oriented, still classify on a stable fallback axis in gravity plane
      let ax1 = bx, ax2 = by;
      if (!haveOrient) {
        const gHatAbsZ = Math.abs(gHat.z);
        const ref = (gHatAbsZ < 0.9) ? {x:0,y:0,z:1} : {x:0,y:1,z:0};
        const p = projectToPlane(ref.x,ref.y,ref.z, gHat.x,gHat.y,gHat.z);
        const u = unit3(p.x,p.y,p.z);
        ax1 = {x:u.x,y:u.y,z:u.z};
        const cx = gHat.y*ax1.z - gHat.z*ax1.y;
        const cy = gHat.z*ax1.x - gHat.x*ax1.z;
        const cz = gHat.x*ax1.y - gHat.y*ax1.x;
        const cu = unit3(cx,cy,cz);
        ax2 = {x:cu.x,y:cu.y,z:cu.z};
      }

      const dx = dot3(hp.x,hp.y,hp.z, ax1.x,ax1.y,ax1.z);
      const dy = dot3(hp.x,hp.y,hp.z, ax2.x,ax2.y,ax2.z);

      if (Math.abs(dx) >= Math.abs(dy)) return (dx >= 0) ? "R" : "L";
      return (dy >= 0) ? "F" : "B";
    }

    // -------------------------------------------------------------------------
    // ORIENT FLOW (PHONE-OWNED): two 3s windows collecting shakeHit impulses
    // -------------------------------------------------------------------------
    const ORIENT_STEP_MS = 3000;

    const orient = {
      active: false,
      step: 0,       // 1 or 2
      untilT: 0,     // seconds
      samples: [],   // {x,y,z} unit vectors in gravity plane
    };

    function orientReset(){
      haveOrient = false;
      orient.active = false;
      orient.step = 0;
      orient.untilT = 0;
      orient.samples.length = 0;
      bx = {x:1,y:0,z:0};
      by = {x:0,y:1,z:0};

      // ping reset (optional)
      publishDynamics({
        room,
        energy01: energyUI,
        groove01: lastGrooveUI,
        dynamics01: lastDynamicsUI,
        smooth01: lastSmoothUI,
        speed01: speedOut,
        shake01,
        shakeHit:false,
        sd:"",
        locked:false,
        hz:0,
        oc:0,
        od:0
      }, 0, true);
    }

    function orientStart(step){
      orient.active = true;
      orient.step = step;
      orient.samples.length = 0;
      orient.untilT = (performance.now()/1000) + (ORIENT_STEP_MS/1000);

      // ping start step
      publishDynamics({
        room,
        energy01: energyUI,
        groove01: lastGrooveUI,
        dynamics01: lastDynamicsUI,
        smooth01: lastSmoothUI,
        speed01: speedOut,
        shake01,
        shakeHit:false,
        sd:"",
        locked:false,
        hz:0,
        oc:step,
        od:0
      }, 0, true);
    }

    function orientConsumeImpulse(imp){
      const gU = unit3(gX,gY,gZ);
      const gHat = {x:gU.x, y:gU.y, z:gU.z};

      const hp = projectToPlane(imp.x,imp.y,imp.z, gHat.x,gHat.y,gHat.z);
      const hMag = norm3(hp.x,hp.y,hp.z);
      if (hMag < ORIENT_MIN_IMP) return false;

      const hu = unit3(hp.x,hp.y,hp.z);
      orient.samples.push({x:hu.x,y:hu.y,z:hu.z});
      return true;
    }

    function pcaAxisFromSamples(samples){
      let mx=0,my=0,mz=0;
      for (const s of samples){ mx += s.x; my += s.y; mz += s.z; }
      const n = Math.max(1, samples.length);
      mx /= n; my /= n; mz /= n;
      const u = unit3(mx,my,mz);
      return { x:u.x, y:u.y, z:u.z, mag:u.m };
    }

    function orientFinalizeIfTime(tNow){
      if (!orient.active) return false;
      if (tNow < orient.untilT) return false;

      if (orient.samples.length < 6) {
        orient.untilT = tNow + 1.0; // silently extend
        return false;
      }

      const gU = unit3(gX,gY,gZ);
      const gHat = {x:gU.x, y:gU.y, z:gU.z};

      if (orient.step === 1) {
        const ax = pcaAxisFromSamples(orient.samples);
        const axOrtho = orthonormalize(ax.x,ax.y,ax.z, gHat.x,gHat.y,gHat.z);
        bx = {x:axOrtho.x,y:axOrtho.y,z:axOrtho.z};

        // provisional by = gHat x bx
        const cx = gHat.y*bx.z - gHat.z*bx.y;
        const cy = gHat.z*bx.x - gHat.x*bx.z;
        const cz = gHat.x*bx.y - gHat.y*bx.x;
        const cu = unit3(cx,cy,cz);
        by = {x:cu.x,y:cu.y,z:cu.z};

        orient.active = false;
        orient.samples.length = 0;

        publishDynamics({
          room, energy01: energyUI, groove01:lastGrooveUI, dynamics01:lastDynamicsUI, smooth01:lastSmoothUI,
          speed01:speedOut, shake01, shakeHit:false, sd:"", locked:false, hz:0, oc:1, od:1
        }, 0, true);

        return true;
      }

      if (orient.step === 2) {
        const ay = pcaAxisFromSamples(orient.samples);

        // remove component along bx
        const d = dot3(ay.x,ay.y,ay.z, bx.x,bx.y,bx.z);
        const rx = ay.x - bx.x * d;
        const ry = ay.y - bx.y * d;
        const rz = ay.z - bx.z * d;

        const byOrtho = orthonormalize(rx,ry,rz, gHat.x,gHat.y,gHat.z);
        if (byOrtho.mag < 0.3) {
          orient.untilT = tNow + 1.0;
          orient.samples.length = 0;
          return false;
        }

        by = {x:byOrtho.x,y:byOrtho.y,z:byOrtho.z};

        // re-orthonormalize bx vs by
        const d2 = dot3(bx.x,bx.y,bx.z, by.x,by.y,by.z);
        const bx2 = orthonormalize(bx.x - by.x*d2, bx.y - by.y*d2, bx.z - by.z*d2, gHat.x,gHat.y,gHat.z);
        bx = {x:bx2.x,y:bx2.y,z:bx2.z};

        haveOrient = true;

        orient.active = false;
        orient.samples.length = 0;

        publishDynamics({
          room, energy01: energyUI, groove01:lastGrooveUI, dynamics01:lastDynamicsUI, smooth01:lastSmoothUI,
          speed01:speedOut, shake01, shakeHit:false, sd:"", locked:false, hz:0, oc:2, od:1
        }, 0, true);

        return true;
      }

      return false;
    }

    // =========================================================================
    // AUDIO MAPPING (preserved)
    // =========================================================================
    const AUDIO_GATE   = 0.02;
    const AUDIO_MIN_DB = -42;
    const AUDIO_MAX_DB = -6;
    const AUDIO_EXP    = 1.15;

    const MASTER_GAIN  = 2.2;

    const TONE_BASE_HZ    = 180;
    const TONE_MAX_ADD_HZ = 220;

    // =========================================================================
    // Helpers
    // =========================================================================
    const clamp01 = (x) => Math.max(0, Math.min(1, x));
    const lerp = (a,b,t) => a + (b-a)*t;
    const mag3 = (x,y,z) => Math.sqrt(x*x+y*y+z*z);
    const dbToGain = (db) => Math.pow(10, db/20);

    function alphaFromCutoff(dt, cutoffHz){
      const tau = 1 / (2 * Math.PI * cutoffHz);
      return 1 / (1 + tau / Math.max(1e-4, dt));
    }

    function median(arr) {
      if (!arr.length) return 0;
      const a = arr.slice().sort((x,y) => x - y);
      const mid = (a.length - 1) / 2;
      const lo = Math.floor(mid), hi = Math.ceil(mid);
      return (a[lo] + a[hi]) / 2;
    }

    function energyToGain(e) {
      if (e <= AUDIO_GATE) return 0;
      const x = (e - AUDIO_GATE) / (1 - AUDIO_GATE);
      const shaped = Math.pow(clamp01(x), AUDIO_EXP);
      const db = AUDIO_MIN_DB + (AUDIO_MAX_DB - AUDIO_MIN_DB) * shaped;
      return dbToGain(db);
    }

    function autocorrPeak(signal, dt) {
      const n = signal.length;
      if (n < 24) return {peak: 0, lag: 0, hz: 0};

      let mean=0;
      for (let i=0;i<n;i++) mean += signal[i];
      mean /= n;

      let varr=0;
      for (let i=0;i<n;i++) {
        const d = signal[i]-mean;
        varr += d*d;
      }
      if (varr < 1e-9) return {peak: 0, lag: 0, hz: 0};

      const minLag = Math.max(2, Math.floor(1/(MAX_HZ*dt)));
      const maxLag = Math.min(n-3, Math.floor(1/(MIN_HZ*dt)));

      let best = -1;
      let bestLag = 0;

      for (let lag=minLag; lag<=maxLag; lag++) {
        let c=0;
        for (let i=0;i<n-lag;i++) c += (signal[i]-mean) * (signal[i+lag]-mean);
        const r = c / varr;
        if (r > best) { best = r; bestLag = lag; }
      }

      const hz = bestLag > 0 ? (1/(bestLag*dt)) : 0;
      return {peak: clamp01(best), lag: bestLag, hz};
    }

    function smoothnessFromJerk(avgJerk) {
      const t = (JERK_LOOSE - avgJerk) / (JERK_LOOSE - JERK_TIGHT);
      return clamp01(t);
    }

    function dynamicsActivityGate(speed01){
      const v = clamp01(speed01 || 0);
      const x = (v - DYNAMICS_ACTIVITY_MIN01) / (1 - DYNAMICS_ACTIVITY_MIN01);
      return Math.pow(clamp01(x), DYNAMICS_ACTIVITY_POW);
    }

    function computeAvg(arr) {
      if (!arr.length) return 0;
      let s=0;
      for (const x of arr) s+=x;
      return s/arr.length;
    }

    function trimToWindow(dtMean, targetSec, omegaMag, omegaNorm, omegaVec, jerkBuf, dtBuf) {
      let targetN = dtMean > 1e-4 ? Math.round(targetSec / dtMean) : MAX_WINDOW_SAMPLES;
      targetN = Math.max(MIN_WINDOW_SAMPLES, Math.min(MAX_WINDOW_SAMPLES, targetN));

      while (omegaMag.length  > targetN) omegaMag.shift();
      while (omegaNorm.length > targetN) omegaNorm.shift();
      while (omegaVec.length  > targetN) omegaVec.shift();
      while (jerkBuf.length   > targetN) jerkBuf.shift();
      while (dtBuf.length     > targetN) dtBuf.shift();

      return targetN;
    }

    // =========================================================================
    // Dynamics diversity window buffer (time-based, ~1000ms)
    // =========================================================================
    const dynamicsVecBuf = [];
    const dynamicsDtBuf  = [];

    function dynamicsBufPush(vec, dt){
      const d = Math.max(1e-4, Number(dt) || 0);
      dynamicsVecBuf.push(vec);
      dynamicsDtBuf.push(d);

      let acc = 0;
      for (let i = dynamicsDtBuf.length - 1; i >= 0; i--){
        acc += dynamicsDtBuf[i];
        if (acc >= 2.5) {
          dynamicsVecBuf.splice(0, i);
          dynamicsDtBuf.splice(0, i);
          break;
        }
      }
    }

    function dynamicsDiversityLastSec(windowSec){
      const W = Math.max(0.2, Number(windowSec) || 1.0);

      let sumW = 0;
      let sx = 0, sy = 0, sz = 0;

      for (let i = dynamicsVecBuf.length - 1; i >= 0; i--){
        const dt = dynamicsDtBuf[i] || 0;
        if (sumW >= W) break;

        const w = Math.min(dt, W - sumW);
        const v = dynamicsVecBuf[i];
        if (v) {
          sx += (v.x || 0) * w;
          sy += (v.y || 0) * w;
          sz += (v.z || 0) * w;
        }
        sumW += w;
      }

      if (sumW < 0.25) return { div01: 0, R: 1, n: dynamicsVecBuf.length };

      const inv = 1 / sumW;
      const mx = sx * inv, my = sy * inv, mz = sz * inv;
      const R = clamp01(Math.sqrt(mx*mx + my*my + mz*mz));
      const div01 = clamp01(1 - R);

      return { div01, R, n: dynamicsVecBuf.length };
    }

    // =========================================================================
    // Meter continuity (logic preserved; no UI)
    // =========================================================================
    const METER_HOLD_SEC = 0.55;
    const METER_FADE_HZ  = 3.0;

    // =========================================================================
    // State
    // =========================================================================
    let running = false;
    let lastT = null;

    let ox=0, oy=0, oz=0;

    const omegaMag  = [];
    const omegaNorm = [];
    const omegaVec  = [];
    const jerkBuf   = [];
    const dtBuf     = [];

    let emaMean = 0;
    let emaVar  = 1;

    let lock = false;
    let lockStrength = 0;
    let grooveHz = 0;

    let graceLeft = 0;
    let recenterBadTime = 0;

    let energy = 0;
    let energyUI = 0;

    let mSpeedEMA = 0;
    let speedOut  = 0;

    let meterHoldLeft = 0;
    let lastGrooveUI = 0;
    let lastDynamicsUI  = 0;
    let lastSmoothUI = 0;

    // SHAKE state
    let shake01 = 0;

    let accelBaseMag = 9.81;
    let prevAx = 0, prevAy = 0, prevAz = 0;
    let prevAmag = 9.81;

    let shakeFullTimes = [];
    let lastShakeDir = "";

    let audioCtx = null, osc = null, gainNode = null;

    function ensureAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      gainNode = audioCtx.createGain();
      gainNode.gain.value = 0;

      osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = TONE_BASE_HZ;

      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      osc.start();
    }

    function setAudio(eUI, groove, locked) {
      if (!audioCtx || !gainNode || !osc) return;

      const gBase = energyToGain(clamp01(eUI));
      const gGroove = locked ? (0.30 + 0.70*groove) : (0.08 + 0.22*groove);
      const g = MASTER_GAIN * gBase * gGroove;

      const f = TONE_BASE_HZ
              + TONE_MAX_ADD_HZ * (locked ? groove : 0.30*groove)
              + 60 * clamp01(eUI);

      const now = audioCtx.currentTime;
      gainNode.gain.cancelScheduledValues(now);
      gainNode.gain.setTargetAtTime(g, now, 0.06);

      osc.frequency.cancelScheduledValues(now);
      osc.frequency.setTargetAtTime(f, now, 0.06);
    }

    function flushHistorySoft() {
      const keep = Math.min(18, omegaMag.length);
      omegaMag.splice(0, Math.max(0, omegaMag.length - keep));
      omegaNorm.splice(0, Math.max(0, omegaNorm.length - keep));
      omegaVec.splice(0, Math.max(0, omegaVec.length - keep));
      jerkBuf.splice(0, Math.max(0, jerkBuf.length - keep));
      dtBuf.splice(0, Math.max(0, dtBuf.length - keep));

      dynamicsVecBuf.splice(0, Math.max(0, dynamicsVecBuf.length - keep));
      dynamicsDtBuf.splice(0, Math.max(0, dynamicsDtBuf.length - keep));
    }

    function meterHoldOrFade(dt) {
      if (dt > 0) meterHoldLeft = Math.max(0, meterHoldLeft - dt);

      const dtFade = Math.max(1e-3, dt || computeAvg(dtBuf.slice(-50)) || 1/60);
      const aFade = alphaFromCutoff(dtFade, METER_FADE_HZ);
      const holding = meterHoldLeft > 0;

      const grooveOut   = holding ? lastGrooveUI   : (1 - aFade) * lastGrooveUI;
      const dynamicsOut = holding ? lastDynamicsUI : (1 - aFade) * lastDynamicsUI;
      const smoothOut   = holding ? lastSmoothUI   : (1 - aFade) * lastSmoothUI;

      lastGrooveUI   = grooveOut;
      lastDynamicsUI = dynamicsOut;
      lastSmoothUI   = smoothOut;

      return { grooveOut, dynamicsOut, smoothOut };
    }

    function updateSpeedV0(wRawDps, dt) {
      const dtSafe = Math.max(1e-3, dt || 1/60);

      const wRaw = Math.max(0, wRawDps || 0);
      const cap  = SPEED_CAP_DPS;
      const wCap = Math.min(wRaw, cap);

      const wDz = Math.max(0, wCap - SPEED_DEAD_DPS);

      const denom = Math.max(1e-6, (SPEED_ADAPT_END_DPS - SPEED_ADAPT_START_DPS));
      let tAdapt = (wDz - SPEED_ADAPT_START_DPS) / denom;
      tAdapt = clamp01(tAdapt);
      tAdapt = Math.pow(tAdapt, SPEED_ADAPT_POW);

      const cutoffHz = lerp(SPEED_EMA_CUTOFF_FAST_HZ, SPEED_EMA_CUTOFF_SLOW_HZ, tAdapt);
      const aE = alphaFromCutoff(dtSafe, cutoffHz);

      mSpeedEMA = (mSpeedEMA === 0) ? wDz : ((1 - aE) * mSpeedEMA + aE * wDz);
      const wFilt = mSpeedEMA;

      const n = clamp01(wFilt / SPEED_NORM_DPS);
      const target = Math.pow(n, SPEED_MAP_POW);

      const aAtk = alphaFromCutoff(dtSafe, SPEED_ATTACK_HZ);
      const aRel = alphaFromCutoff(dtSafe, SPEED_RELEASE_HZ);
      const a = (target >= speedOut) ? aAtk : aRel;
      speedOut = (1 - a) * speedOut + a * target;

      return { cap, dt: dtSafe, wRaw, wCap, wDz, wFilt, speed: speedOut, cutoffHz, tAdapt };
    }

    // =========================================================================
    // SHAKE â€” meter unchanged; shakeHit double 100% within 500ms
    // + direction code + orientation sample capture during orient windows
    // =========================================================================
    function updateShake(e, t, dt, groove01=0, locked=false, smooth01=1){
      const acc = e.accelerationIncludingGravity || e.acceleration;
      const dtSafe = Math.max(1e-3, dt || 1/60);

      const prevShake = shake01;

      if (!acc) {
        shake01 = Math.max(0, shake01 - SHAKE_METER_DECAY * dtSafe);
        return { shake01, shakeHit:false, spike:0, amag:0, jerk:0, sd:"" };
      }

      const ax = Number(acc.x) || 0;
      const ay = Number(acc.y) || 0;
      const az = Number(acc.z) || 0;

      // gravity LPF
      const aG = alphaFromCutoff(dtSafe, GRAV_LPF_HZ);
      gX = (1 - aG) * gX + aG * ax;
      gY = (1 - aG) * gY + aG * ay;
      gZ = (1 - aG) * gZ + aG * az;

      // linear accel estimate for impulse/direction
      const linX = ax - gX;
      const linY = ay - gY;
      const linZ = az - gZ;
      pushALin(t, dtSafe, linX, linY, linZ);

      const amag = mag3(ax, ay, az);

      // baseline magnitude (LPF)
      const aBase = alphaFromCutoff(dtSafe, SHAKE_BASELINE_HZ);
      accelBaseMag = (isFinite(accelBaseMag) ? accelBaseMag : amag);
      accelBaseMag = (1 - aBase) * accelBaseMag + aBase * amag;

      // high-pass impact
      const hp = Math.abs(amag - accelBaseMag);
      const hpSpike = Math.max(0, hp - SHAKE_HP_DEAD_G);

      // jerk (delta accel / sec)
      const dax = ax - prevAx;
      const day = ay - prevAy;
      const daz = az - prevAz;
      const jerk = mag3(dax, day, daz) / dtSafe;
      const jerkSpike = Math.max(0, jerk - SHAKE_JERK_DEAD);

      prevAx = ax; prevAy = ay; prevAz = az;
      prevAmag = amag;

      const spike = (SHAKE_HP_WEIGHT * hpSpike) + (SHAKE_JERK_WEIGHT * (jerkSpike / 80.0));

      shake01 = clamp01(shake01 + SHAKE_METER_GAIN * spike * dtSafe - SHAKE_METER_DECAY * dtSafe);

      // (kept: smooth bias space; does not directly change shakeHit)
      const s = clamp01(smooth01 || 0);
      const boost = (s < SHAKE_SMOOTH_BOOST_START)
        ? clamp01((SHAKE_SMOOTH_BOOST_START - s) / Math.max(1e-6, SHAKE_SMOOTH_BOOST_START))
        : 0;
      void boost; // reserved knob
      // const _thrDrop = boost * SHAKE_SMOOTH_THR_DROP_MAX;

      // "full meter" rising edge tracking
      const hitFull = (prevShake < SHAKE_FULL_HI) && (shake01 >= SHAKE_FULL_HI);
      if (hitFull) {
        shakeFullTimes.push(t);
        const cutoff = t - SHAKE_WIN_WINDOW_SEC;
        while (shakeFullTimes.length && shakeFullTimes[0] < cutoff) shakeFullTimes.shift();
      } else if (shakeFullTimes.length) {
        const cutoff = t - SHAKE_WIN_WINDOW_SEC;
        while (shakeFullTimes.length && shakeFullTimes[0] < cutoff) shakeFullTimes.shift();
      }

      let shakeHit = false;
      if (shakeFullTimes.length >= 2) {
        shakeHit = true;
        shakeFullTimes.length = 0;
      }

      let sd = "";
      if (shakeHit) {
        const imp = computeImpulse(t);

        // if we're calibrating, capture samples from these shakeHits
        if (orient.active) orientConsumeImpulse(imp);

        sd = chooseDirectionFromImpulse(imp.x,imp.y,imp.z, gX,gY,gZ);
        lastShakeDir = sd;
      }

      // finalize step if time elapsed
      orientFinalizeIfTime(t);

      return { shake01, shakeHit, spike, amag, jerk, sd };
    }

    // =========================================================================
    // "Start â†’ Orient Phone â†’ Stop" click handler behavior
    // =========================================================================
    function clickHandler(){
      if (UI.state === "idle") {
        start();
        return;
      }

      if (UI.state === "running_need_orient") {
        // Begin the two-step orient flow (phone-owned)
        // Step 1: shake LEFT/RIGHT (axis 1)
        // Step 2: shake FORWARD/BACK (axis 2)
        orientReset();     // clean slate each time you enter orient mode
        orientStart(1);
        UI.state = "running_need_orient"; // stays until step2 completes
        setBtn("ORIENTâ€¦ 1/2");
        return;
      }

      // running_oriented => Stop
      stop();
    }

    startBtn.addEventListener('click', clickHandler);

    // =========================================================================
    // onMotion
    // =========================================================================
    function onMotion(e) {
      if (!running) return;

      try {
        const t = performance.now() / 1000;
        const dt = (lastT == null) ? 0 : (t - lastT);
        lastT = t;

        if (dt > 0) dtBuf.push(dt);

        const lockedProxy = !!(lock || graceLeft > 0);
        const grooveProxy = clamp01(lockStrength || lastGrooveUI || 0);
        const smoothProxy = clamp01(lastSmoothUI || 0);

        const sh = updateShake(e, t, dt, grooveProxy, lockedProxy, smoothProxy);

        // UI state updates for orient flow:
        if (UI.state !== "idle") {
          if (orient.active) {
            setBtn(orient.step === 1 ? "ORIENTâ€¦ 1/2" : "ORIENTâ€¦ 2/2");
          } else if (!haveOrient && UI.state !== "running_oriented") {
            // If step 1 just completed, auto-advance to step 2 immediately
            // (this mirrors the "guided flow" without extra UI)
            // We detect completion by seeing oc/od pings via publish, but locally:
            // If we are not active and not oriented yet, start step 2.
            // Step 1 completion sets bx/by but haveOrient remains false.
            // We'll assume step 1 completed if bx/by changed AND weâ€™re not oriented.
            // More robust: track last completed step locally:
          }
        }

        // Auto-advance logic (robust): track step completion locally
        // We infer completion when orient.active went false and haveOrient still false and we were just in step 1.
        // We'll keep a tiny state machine:
      } catch (err) {
        console.error("[onMotion crash]", err);
      }
    }

    // Patch in the orient state machine (keeps code readable)
    let _wasOrientActive = false;
    let _lastOrientStep = 0;

    // Wrap original onMotion so we can insert the robust auto-advance
    const _onMotionCore = onMotion;
    function onMotionWrapped(e){
      const beforeActive = orient.active;
      const beforeStep = orient.step;
      _onMotionCore(e);

      const afterActive = orient.active;

      // Detect transition: active -> inactive
      if (beforeActive && !afterActive) {
        // Step finished. If it was step 1, immediately begin step 2.
        if (beforeStep === 1 && !haveOrient) {
          orientStart(2);
          setBtn("ORIENTâ€¦ 2/2");
        } else if (beforeStep === 2 && haveOrient) {
          // Fully oriented; button becomes Stop
          UI.state = "running_oriented";
          setBtn("Stop");
        }
      }

      // If user is in running_need_orient but hasn't clicked ORIENT yet:
      if (UI.state === "running_need_orient" && !orient.active && !haveOrient) {
        // keep label as "Orient Phone"
        setBtn("Orient Phone");
      }

      // If already oriented, lock label to Stop
      if (UI.state !== "idle" && haveOrient && UI.state !== "running_oriented") {
        UI.state = "running_oriented";
        setBtn("Stop");
      }

      _wasOrientActive = afterActive;
      _lastOrientStep = orient.step;
    }

    // Replace listener target to wrapped version when we start
    function addMotionListener(){
      window.addEventListener('devicemotion', onMotionWrapped, { passive: true });
    }
    function removeMotionListener(){
      window.removeEventListener('devicemotion', onMotionWrapped);
    }

    // =========================================================================
    // iOS permission gate (UI-less)
    // =========================================================================
    async function requestMotionPermissionIfNeeded() {
      const needs = (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function')
                 || (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function');

      if (!needs) return true;

      const reqs = [];

      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        reqs.push(DeviceMotionEvent.requestPermission().then(s => s === 'granted').catch(() => false));
      }

      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        reqs.push(DeviceOrientationEvent.requestPermission().then(s => s === 'granted').catch(() => false));
      }

      const results = await Promise.all(reqs);
      return results.every(Boolean);
    }

    // =========================================================================
    // Start/Stop â€” now Startâ†’Orient Phoneâ†’Stop
    // =========================================================================
    async function start() {
      if (!window.isSecureContext) return;

      startBtn.disabled = true;
      try {
        const ok = await requestMotionPermissionIfNeeded();
        if (!ok) return;

        ensureAudio();
        try { await audioCtx.resume(); } catch(e) {}

        nextSendAtMs = 0;
        lastSig = null;
        await connectRelay();

        running = true;
        lastT = null;

        ox=oy=oz=0;
        omegaMag.length  = 0;
        omegaNorm.length = 0;
        omegaVec.length  = 0;
        jerkBuf.length   = 0;
        dtBuf.length     = 0;

        dynamicsVecBuf.length = 0;
        dynamicsDtBuf.length  = 0;

        emaMean = 0;
        emaVar  = 1;

        lock = false;
        lockStrength = 0;
        grooveHz = 0;

        graceLeft = 0;
        recenterBadTime = 0;

        energy = 0;
        energyUI = 0;

        mSpeedEMA = 0;
        speedOut  = 0;

        meterHoldLeft = 0;
        lastGrooveUI   = 0;
        lastDynamicsUI = 0;
        lastSmoothUI   = 0;

        shake01 = 0;
        accelBaseMag = 9.81;

        prevAx = prevAy = prevAz = 0;
        prevAmag = 9.81;

        shakeFullTimes.length = 0;

        lastShakeDir = "";
        aLinBuf.length = 0;

        gX = 0; gY = 0; gZ = 9.81;

        // Keep calibration across runs unless user re-enters Orient Phone
        orient.active = false;
        orient.step = 0;
        orient.untilT = 0;
        orient.samples.length = 0;

        setAudio(0,0,false);
        setBgFromEnergy(0);

        addMotionListener();

        // Button label after start:
        if (haveOrient) {
          UI.state = "running_oriented";
          setBtn("Stop");
        } else {
          UI.state = "running_need_orient";
          setBtn("Orient Phone");
        }

      } finally {
        startBtn.disabled = false;
      }

      if (screen.orientation && screen.orientation.lock) {
        try { await screen.orientation.lock('portrait-primary'); }
        catch (e) { /* no-op */ }
      }
    }

    function stop() {
      running = false;
      removeMotionListener();

      if (audioCtx && gainNode) {
        const now = audioCtx.currentTime;
        gainNode.gain.cancelScheduledValues(now);
        gainNode.gain.setTargetAtTime(0, now, 0.05);
      }

      disconnectRelay();
      UI.state = "idle";
      setBtn("Start");
      setBgFromEnergy(0);
    }

    // =========================================================================
    // Motion processing (rest of your original logic) â€” unchanged,
    // but we need to keep it intact. Weâ€™ll re-insert your original onMotion body
    // with only one substitution: updateShake(...) call stays, publish stays.
    // =========================================================================

    // Rebuild onMotion core with your original logic (unchanged), but using
    // the wrapped listener already installed above.
    function onMotion(e) {
      if (!running) return;

      try {
        const t = performance.now() / 1000;
        const dt = (lastT == null) ? 0 : (t - lastT);
        lastT = t;

        if (dt > 0) dtBuf.push(dt);

        const lockedProxy = !!(lock || graceLeft > 0);
        const grooveProxy = clamp01(lockStrength || lastGrooveUI || 0);
        const smoothProxy = clamp01(lastSmoothUI || 0);

        const sh = updateShake(e, t, dt, grooveProxy, lockedProxy, smoothProxy);

        const rr = e.rotationRate;

        if (!rr) {
          const dtMean = Math.max(1e-3, computeAvg(dtBuf.slice(-50)) || 1/60);
          const dtForFilter = (dt > 0) ? dt : dtMean;
          const sv = updateSpeedV0(0, dtForFilter);

          if (dt > 0) {
            energy = Math.max(0, energy - ENERGY_DECAY * dt);
            energyUI = lerp(energyUI, energy, UI_SMOOTH);
          }

          const held = meterHoldOrFade(dt);

          publishDynamics({
            room,
            t: performance.now(),
            dt: sv.dt,
            wRaw: sv.wRaw,
            wCap: sv.wCap,
            wFilt: sv.wFilt,
            cap: sv.cap,
            energy01: energyUI,
            groove01: held.grooveOut,
            dynamics01: held.dynamicsOut,
            smooth01: held.smoothOut,
            speed01: sv.speed,
            shake01: sh.shake01,
            shakeHit: sh.shakeHit,
            sd: sh.sd,
            locked: false,
            hz: 0,
            d_r2: 0, d_r3: 0, d_gate: 0, d_balance: 0, d_couple: 0,
            oc: orient.active ? orient.step : undefined,
            od: undefined
          }, dt);

          setBgFromEnergy(clamp01(energyUI));
          setAudio(energyUI, held.grooveOut, false);
          return;
        }

        const x = rr.beta ?? 0;
        const y = rr.gamma ?? 0;
        const z = rr.alpha ?? 0;

        const prevOx=ox, prevOy=oy, prevOz=oz;

        ox = lerp(ox, x, OMEGA_LPF);
        oy = lerp(oy, y, OMEGA_LPF);
        oz = lerp(oz, z, OMEGA_LPF);

        const mStability = mag3(ox,oy,oz);
        const dtMean = Math.max(1e-3, computeAvg(dtBuf.slice(-50)));
        const dtForFilter = (dt > 0) ? dt : dtMean;

        const wRaw = mag3(x, y, z);
        const sv = updateSpeedV0(wRaw, dtForFilter);

        if (dt > 0) graceLeft = Math.max(0, graceLeft - dt);

        if (mStability > MIN_OMEGA) {
          omegaMag.push(mStability);

          const d0 = mStability - emaMean;
          emaMean = emaMean + NORM_ALPHA * d0;

          const d2 = (mStability - emaMean);
          emaVar = emaVar + NORM_ALPHA * (d2*d2 - emaVar);

          const rms = Math.sqrt(Math.max(1e-6, emaVar));
          omegaNorm.push((mStability - emaMean) / rms);

          const invM = 1 / Math.max(1e-6, mStability);
          const vUnit = { x: ox*invM, y: oy*invM, z: oz*invM };
          omegaVec.push(vUnit);

          if (dtForFilter > 0) dynamicsBufPush(vUnit, dtForFilter);

          if (dt > 0) {
            const dtSafe = Math.max(dt, dtMean * 0.5, 1/120);
            jerkBuf.push(mag3(ox-prevOx, oy-prevOy, oz-prevOz) / dtSafe);
          }
        } else {
          if (omegaMag.length) omegaMag.shift();
          if (omegaNorm.length) omegaNorm.shift();
          if (omegaVec.length) omegaVec.shift();
          if (jerkBuf.length)  jerkBuf.shift();
        }

        const inStableMode = lock || graceLeft > 0;
        const windowSec = inStableMode ? STABLE_WINDOW_SEC : HUNT_WINDOW_SEC;
        const nTarget = trimToWindow(dtMean, windowSec, omegaMag, omegaNorm, omegaVec, jerkBuf, dtBuf);

        if (omegaNorm.length < Math.min(MIN_WINDOW_SAMPLES, nTarget)) {
          if (dt > 0) {
            energy = Math.max(0, energy - ENERGY_DECAY * dt);
            energyUI = lerp(energyUI, energy, UI_SMOOTH);
          }

          const held = meterHoldOrFade(dt);

          publishDynamics({
            room,
            t: performance.now(),
            dt: sv.dt,
            wRaw: sv.wRaw,
            wCap: sv.wCap,
            wFilt: sv.wFilt,
            cap: sv.cap,
            energy01: energyUI,
            groove01: held.grooveOut,
            dynamics01: held.dynamicsOut,
            smooth01: held.smoothOut,
            speed01: sv.speed,
            shake01: sh.shake01,
            shakeHit: sh.shakeHit,
            sd: sh.sd,
            locked: false,
            hz: 0,
            d_r2: 0, d_r3: 0, d_gate: 0, d_balance: 0, d_couple: 0,
            oc: orient.active ? orient.step : undefined,
            od: undefined
          }, dt);

          setBgFromEnergy(clamp01(energyUI));
          setAudio(energyUI, held.grooveOut, false);
          return;
        }

        const ac = autocorrPeak(omegaNorm, dtMean);
        lockStrength = lerp(lockStrength, ac.peak, LOCK_SMOOTH);
        grooveHz = ac.hz;

        const jerkWindow = jerkBuf.slice(-Math.min(jerkBuf.length, 70));
        const avgJerk = median(jerkWindow);
        const smoothScore = smoothnessFromJerk(avgJerk);

        const dDiv = dynamicsDiversityLastSec(DYNAMICS_WINDOW_SEC);
        const actGate = dynamicsActivityGate(sv.speed);
        const diversityGated = clamp01(dDiv.div01 * actGate);

        const dynamicsBonus = DYNAMICS_FLOOR + (1 - DYNAMICS_FLOOR) * diversityGated;
        const shapedCore = diversityGated;
        const dynamicsUI = clamp01(DYNAMICS_UI_GAIN * Math.pow(shapedCore, DYNAMICS_UI_EXP));

        meterHoldLeft = METER_HOLD_SEC;
        lastGrooveUI   = lockStrength;
        lastDynamicsUI = dynamicsUI;
        lastSmoothUI   = smoothScore;

        if (!lock) {
          if (lockStrength > LOCK_ON) { lock = true; graceLeft = 0; }
        } else {
          if (lockStrength < LOCK_OFF) { lock = false; graceLeft = GRACE_SEC; }
        }

        const inGrace = (!lock && graceLeft > 0);
        if (inGrace && lockStrength > LOCK_ON) { lock = true; graceLeft = 0; }

        if (dt > 0) {
          const badGroove = lockStrength <= RECENTER_GROOVE_MAX;
          const notLockedNow = !lock;
          if (badGroove && notLockedNow) recenterBadTime += dt;
          else recenterBadTime = Math.max(0, recenterBadTime - 1.5*dt);

          if (recenterBadTime >= RECENTER_SEC) {
            flushHistorySoft();
            recenterBadTime = 0;
          }
        }

        if (dt > 0) {
          const grooveTerm   = Math.pow(clamp01(lockStrength), GROOVE_EXP);
          const smoothTerm   = Math.pow(clamp01(smoothScore), SMOOTH_EXP);
          const dynamicsTerm = Math.pow(clamp01(dynamicsBonus), DYNAMICS_EXP);

          const qualityTerm = grooveTerm * smoothTerm;
          const earnBase = EARN_SCALE * grooveTerm * smoothTerm * dynamicsTerm;

          const effectivelyLocked = lock || inGrace;
          const gain = effectivelyLocked ? ENERGY_GAIN_LOCKED : ENERGY_GAIN_FREE;

          const smoothKill = (smoothScore < SMOOTH_KILL_THRESH);
          const earn = smoothKill ? 0 : (gain * earnBase);

          let decay = ENERGY_DECAY;
          if (qualityTerm >= COAST_QUALITY_MIN) decay *= COAST_DECAY_MULT;

          if (smoothKill) {
            decay *= SMOOTH_KILL_DECAY_MULT;
            if (SMOOTH_KILL_UNLOCK) { lock = false; graceLeft = 0; }
          }

          energy = Math.max(0, energy + (earn - decay) * dt);
          energyUI = lerp(energyUI, energy, UI_SMOOTH);
        }

        const lockedNow = !!(lock || inGrace);

        publishDynamics({
          room,
          t: performance.now(),
          dt: sv.dt,
          wRaw: sv.wRaw,
          wCap: sv.wCap,
          wFilt: sv.wFilt,
          cap: sv.cap,
          energy01: energyUI,
          groove01: lockStrength,
          dynamics01: dynamicsUI,
          smooth01: smoothScore,
          speed01: sv.speed,
          shake01: sh.shake01,
          shakeHit: sh.shakeHit,
          sd: sh.sd,
          locked: lockedNow,
          hz: grooveHz,

          d_r2: dDiv.R,
          d_r3: dDiv.div01,
          d_gate: actGate,
          d_balance: 0,
          d_couple: 0,

          oc: orient.active ? orient.step : undefined,
          od: undefined
        }, dt);

        setBgFromEnergy(clamp01(energyUI));
        setAudio(energyUI, lockStrength, lockedNow);

      } catch (err) {
        console.error("[onMotion crash]", err);
      }
    }

    // =========================================================================
    // iOS permission gate (UI-less)
    // =========================================================================
    async function requestMotionPermissionIfNeeded() {
      const needs = (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function')
                 || (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function');

      if (!needs) return true;

      const reqs = [];

      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        reqs.push(DeviceMotionEvent.requestPermission().then(s => s === 'granted').catch(() => false));
      }

      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        reqs.push(DeviceOrientationEvent.requestPermission().then(s => s === 'granted').catch(() => false));
      }

      const results = await Promise.all(reqs);
      return results.every(Boolean);
    }

    // =========================================================================
    // Start/Stop
    // =========================================================================
    async function start() {
      if (!window.isSecureContext) return;

      startBtn.disabled = true;
      try {
        const ok = await requestMotionPermissionIfNeeded();
        if (!ok) return;

        ensureAudio();
        try { await audioCtx.resume(); } catch(e) {}

        nextSendAtMs = 0;
        lastSig = null;
        await connectRelay();

        running = true;
        lastT = null;

        ox=oy=oz=0;
        omegaMag.length  = 0;
        omegaNorm.length = 0;
        omegaVec.length  = 0;
        jerkBuf.length   = 0;
        dtBuf.length     = 0;

        dynamicsVecBuf.length = 0;
        dynamicsDtBuf.length  = 0;

        emaMean = 0;
        emaVar  = 1;

        lock = false;
        lockStrength = 0;
        grooveHz = 0;

        graceLeft = 0;
        recenterBadTime = 0;

        energy = 0;
        energyUI = 0;

        mSpeedEMA = 0;
        speedOut  = 0;

        meterHoldLeft = 0;
        lastGrooveUI   = 0;
        lastDynamicsUI = 0;
        lastSmoothUI   = 0;

        shake01 = 0;
        accelBaseMag = 9.81;
        prevAx = prevAy = prevAz = 0;
        prevAmag = 9.81;
        shakeFullTimes.length = 0;

        lastShakeDir = "";
        aLinBuf.length = 0;

        gX = 0; gY = 0; gZ = 9.81;

        orient.active = false;
        orient.step = 0;
        orient.untilT = 0;
        orient.samples.length = 0;

        setAudio(0,0,false);
        setBgFromEnergy(0);

        addMotionListener();

        if (haveOrient) {
          UI.state = "running_oriented";
          setBtn("Stop");
        } else {
          UI.state = "running_need_orient";
          setBtn("Orient Phone");
        }

      } finally {
        startBtn.disabled = false;
      }

      if (screen.orientation && screen.orientation.lock) {
        try { await screen.orientation.lock('portrait-primary'); }
        catch (e) {}
      }
    }

    function stop() {
      running = false;
      removeMotionListener();

      if (audioCtx && gainNode) {
        const now = audioCtx.currentTime;
        gainNode.gain.cancelScheduledValues(now);
        gainNode.gain.setTargetAtTime(0, now, 0.05);
      }

      disconnectRelay();
      UI.state = "idle";
      setBtn("Start");
      setBgFromEnergy(0);
    }

    // =========================================================================
    // Final: single button click logic
    // =========================================================================
    startBtn.onclick = () => {
      if (UI.state === "idle") {
        start();
        return;
      }
      if (UI.state === "running_need_orient") {
        // enter orient wizard
        orientReset();
        orientStart(1);
        setBtn("ORIENTâ€¦ 1/2");
        return;
      }
      // oriented => stop
      stop();
    };

  })();
  </script>
</body>
</html>
