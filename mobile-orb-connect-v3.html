<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Orb Relay — Mobile</title>

  <style>
    :root{
      --bg0: #000;
      --g: #32ff75;

      /* energy glow (0..1) */
      --e: 0;

      /* glow colors */
      --glowCore: rgba(50,255,117, 0.85);
      --glowHalo: rgba(50,255,117, 0.20);
    }

    html,body{
      height:100%;
      margin:0;
      background: var(--bg0);
      color: var(--g);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      overflow:hidden;
      touch-action: manipulation;
    }

    /* energy-driven glow */
    body{
      background:
        radial-gradient(
          900px 900px at 50% 45%,
          rgba(50,255,117, calc(0.08 + 0.35 * var(--e))) 0%,
          rgba(50,255,117, calc(0.02 + 0.14 * var(--e))) 35%,
          rgba(0,0,0, 1.0) 75%
        ),
        radial-gradient(
          1200px 900px at 50% 40%,
          rgba(255, 42, 0, calc(0.00 + 0.12 * var(--e))) 0%,
          rgba(0,0,0, 1.0) 70%
        );
      transition: background 70ms linear;
    }

    .center{
      position:fixed;
      inset:0;
      display:grid;
      place-items:center;
    }

    #startBtn{
      padding:18px 22px;
      border-radius:18px;
      border:1px solid rgba(50,255,117,.30);
      background: rgba(0,0,0,.40);
      color: var(--g);
      font-weight: 1000;
      font-size: 18px;
      letter-spacing:.4px;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      box-shadow:
        0 0 calc(18px + 60px * var(--e)) rgba(50,255,117, calc(0.08 + 0.22 * var(--e))),
        inset 0 0 0 1px rgba(0,0,0,.35);
    }

    #startBtn:active{
      transform: translateY(1px);
    }

    #startBtn[disabled]{
      opacity:.65;
      cursor:default;
    }

    /* subtle “connected” hide */
    .gone{
      opacity:0;
      pointer-events:none;
      transform: scale(.98);
      transition: opacity 260ms ease, transform 260ms ease;
    }
  </style>

  <!-- Ably -->
  <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
</head>

<body>
  <div class="center">
    <button id="startBtn">START</button>
  </div>

  <script>
    // ============================================================
    // CONFIG
    // ============================================================
    const WORKER_BASE = "https://orb-token.mrgarthwilliams.workers.dev"; // same as receiver
    const DEFAULT_ROOM = "test";
    const PUBLISH_HZ = 30;                 // outbound rate
    const SMOOTH_ALPHA = 0.18;             // smoothing on some signals
    const SHAKE_THRESH = 2.6;              // g-ish bump threshold (tune)
    const LOCK_HZ_MIN = 0.8;               // lock detection band
    const LOCK_HZ_MAX = 2.6;
    const LOCK_STABLE_MS = 650;

    // ============================================================
    // DOM
    // ============================================================
    const startBtn = document.getElementById("startBtn");

    // ============================================================
    // SMALL UTILS
    // ============================================================
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const clamp01 = (x) => clamp(Number(x) || 0, 0, 1);
    const lerp = (a,b,t) => a + (b-a)*t;

    function readRoomFromUrl(){
      try{
        const u = new URL(location.href);
        const r = (u.searchParams.get("room") || "").trim();
        return r || DEFAULT_ROOM;
      }catch(_){
        return DEFAULT_ROOM;
      }
    }

    // ============================================================
    // AUDIO (energy -> gain, energy -> tone)
    // ============================================================
    let audioCtx = null, osc = null, gainNode = null;
    let audioOn = false;

    const AUDIO_GATE   = 0.02;
    const AUDIO_MIN_DB = -44;
    const AUDIO_MAX_DB = -8;
    const AUDIO_EXP    = 1.18;

    const TONE_BASE_HZ    = 170;
    const TONE_MAX_ADD_HZ = 250;

    const dbToGain = (db) => Math.pow(10, db/20);

    function energyToGain(e) {
      if (e <= AUDIO_GATE) return 0;
      const x = (e - AUDIO_GATE) / (1 - AUDIO_GATE);
      const shaped = Math.pow(clamp01(x), AUDIO_EXP);
      const db = AUDIO_MIN_DB + (AUDIO_MAX_DB - AUDIO_MIN_DB) * shaped;
      return dbToGain(db);
    }

    function ensureAudio(){
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      gainNode = audioCtx.createGain();
      gainNode.gain.value = 0;

      osc = audioCtx.createOscillator();
      osc.type = "sine";
      osc.frequency.value = TONE_BASE_HZ;

      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      osc.start();
    }

    async function startAudio(){
      ensureAudio();
      try { await audioCtx.resume(); } catch(_) {}
      audioOn = true;
    }

    function setAudioFromEnergy(e01){
      if (!audioOn || !audioCtx || !gainNode || !osc) return;

      const e = clamp01(e01);
      const g = energyToGain(e);
      const f = TONE_BASE_HZ + TONE_MAX_ADD_HZ * e + 55 * e;

      const now = audioCtx.currentTime;
      gainNode.gain.cancelScheduledValues(now);
      gainNode.gain.setTargetAtTime(g, now, 0.06);

      osc.frequency.cancelScheduledValues(now);
      osc.frequency.setTargetAtTime(f, now, 0.06);
    }

    // ============================================================
    // VISUAL GLOW (energy -> CSS var)
    // ============================================================
    function setGlow(e01){
      document.documentElement.style.setProperty("--e", String(clamp01(e01)));
    }

    // ============================================================
    // MOTION INGEST + METRICS
    // - This is intentionally compact; we can “true-model” later.
    // - Output keys match receiver:
    //   energy01, speed01, groove01, orbit01, smooth01, shake01, locked, hz
    // ============================================================
    let lastTs = null;

    // raw
    let ax=0, ay=0, az=0;         // accel incl gravity
    let rx=0, ry=0, rz=0;         // rotation rate (deg/s)
    let alpha=0, beta=0, gamma=0; // orientation

    // derived + smoothed
    let energy01 = 0;
    let speed01  = 0;
    let smooth01 = 0;
    let groove01 = 0;
    let orbit01  = 0;
    let shake01  = 0;

    // lock detection (rhythm-ish)
    let hz = 0;
    let locked = false;
    let lockStableSince = 0;

    // for hz estimate (zero-crossing-ish on “speed”)
    let prevSpeed = 0;
    let lastPeakMs = 0;

    // for shake
    let lastShakeMs = 0;

    function ema(prev, next, a){
      return lerp(prev, next, clamp01(a));
    }

    function onMotion(e){
      const acc = e.accelerationIncludingGravity || e.acceleration || {};
      ax = Number(acc.x) || 0;
      ay = Number(acc.y) || 0;
      az = Number(acc.z) || 0;

      const rot = e.rotationRate || {};
      // iOS uses alpha/beta/gamma in deg/s; some browsers use different axes — good enough for now
      rx = Number(rot.alpha) || 0;
      ry = Number(rot.beta)  || 0;
      rz = Number(rot.gamma) || 0;

      const now = performance.now();
      if (lastTs == null) lastTs = now;
      const dt = clamp((now - lastTs) / 1000, 0.001, 0.05);
      lastTs = now;

      // magnitude-ish signals
      const aMag = Math.sqrt(ax*ax + ay*ay + az*az);              // ~9.8 at rest if gravity included
      const rMag = Math.sqrt(rx*rx + ry*ry + rz*rz) / 360;        // normalized-ish

      // speed: more rotation rate = more speed
      const speedRaw = clamp01(rMag * 1.35);

      // “effort”: accel changes beyond gravity baseline become energy
      const effort = Math.abs(aMag - 9.8) / 6.0;                 // tune
      const energyRaw = clamp01(0.15 * speedRaw + 0.85 * clamp01(effort));

      // smooth: inverse of jerkiness (use accel delta)
      // cheap proxy: if energy spikes hard, smooth drops
      const jerk = Math.abs(energyRaw - energy01) / Math.max(0.001, dt);
      const smoothRaw = clamp01(1.0 - clamp01(jerk * 0.06));

      // orbit: more orientation “tilt travel” (beta/gamma) — we’ll fill from onOrient too,
      // but motion-only fallback uses accel x/y ratio
      const orbitRaw = clamp01(Math.sqrt(ax*ax + ay*ay) / 12.0);

      // shake: sharp effort spikes
      const shakeHit = (Math.abs(aMag - 9.8) > SHAKE_THRESH);
      if (shakeHit) lastShakeMs = now;
      const shakeRaw = clamp01((now - lastShakeMs) < 220 ? 1 : 0);

      // groove: rhythm confidence — derived from hz estimate below (0..1)
      // (we’ll compute hz using peaks in speed)
      // peak detect
      const sp = speedRaw;
      const rising = (sp > prevSpeed);
      if (!rising && prevSpeed > 0.55 && sp < prevSpeed) {
        const tMs = now;
        if (lastPeakMs > 0) {
          const period = (tMs - lastPeakMs) / 1000;
          if (period > 0.18 && period < 2.2) {
            hz = 1 / period;
          }
        }
        lastPeakMs = tMs;
      }
      prevSpeed = sp;

      const hzInBand = (hz >= LOCK_HZ_MIN && hz <= LOCK_HZ_MAX);
      const grooveRaw = hzInBand ? clamp01((hz - LOCK_HZ_MIN) / (LOCK_HZ_MAX - LOCK_HZ_MIN)) : 0;

      // lock requires stability over time while energy present
      const wantsLock = hzInBand && energyRaw > 0.18;
      if (wantsLock) {
        if (!lockStableSince) lockStableSince = now;
        const stableFor = now - lockStableSince;
        locked = stableFor >= LOCK_STABLE_MS;
      } else {
        lockStableSince = 0;
        locked = false;
      }

      // smooth outputs
      speed01  = ema(speed01,  speedRaw,  SMOOTH_ALPHA);
      energy01 = ema(energy01, energyRaw, SMOOTH_ALPHA);
      smooth01 = ema(smooth01, smoothRaw, SMOOTH_ALPHA);
      orbit01  = ema(orbit01,  orbitRaw,  SMOOTH_ALPHA);
      shake01  = ema(shake01,  shakeRaw,  0.35);
      groove01 = ema(groove01, grooveRaw, 0.22);

      // visuals + audio
      setGlow(energy01);
      setAudioFromEnergy(energy01);
    }

    function onOrient(e){
      // optional: orientation contributes lightly to orbit
      const b = Number(e.beta)  || 0;
      const g = Number(e.gamma) || 0;
      const tilt = Math.sqrt(b*b + g*g) / 90; // ~0..1
      orbit01 = ema(orbit01, clamp01(tilt), 0.08);
    }

    // ============================================================
    // ABLY PUBLISH
    // ============================================================
    let realtime = null;
    let channel = null;
    let publishTimer = null;

    async function connectAbly(roomCode){
      if (typeof Ably === "undefined" || !Ably.Realtime) {
        throw new Error("Ably lib failed to load.");
      }

      const authUrl = WORKER_BASE + "/token?room=" + encodeURIComponent(roomCode) + "&v=" + Date.now();
      realtime = new Ably.Realtime({ authUrl, echoMessages:false });
      channel = realtime.channels.get("orb:" + roomCode);

      // attach to validate room token quickly
      await new Promise((resolve, reject) => {
        channel.attach((err) => err ? reject(err) : resolve());
      });
    }

    function startPublishing(){
      const periodMs = Math.round(1000 / PUBLISH_HZ);
      publishTimer = setInterval(() => {
        if (!channel) return;

        const payload = {
          ts: Date.now(),
          energy01,
          speed01,
          groove01,
          orbit01,
          smooth01,
          shake01,
          locked,
          hz
        };

        channel.publish("orb", payload);
      }, periodMs);
    }

    function stopPublishing(){
      if (publishTimer) clearInterval(publishTimer);
      publishTimer = null;
      try { if (channel) channel.detach(); } catch(_) {}
      try { if (realtime) realtime.close(); } catch(_) {}
      channel = null;
      realtime = null;
    }

    // ============================================================
    // PERMISSIONS + START FLOW
    // ============================================================
    async function requestMotionPerms(){
      // iOS 13+ requires explicit permission calls
      if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
        const r = await DeviceMotionEvent.requestPermission();
        if (r !== "granted") throw new Error("Motion permission denied.");
      }
      if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
        const r = await DeviceOrientationEvent.requestPermission();
        // some iOS versions only gate motion; orientation may be denied while motion works
        // don't hard-fail unless BOTH are blocked
      }
    }

    function bindSensors(){
      window.addEventListener("devicemotion", onMotion, { passive:true });
      window.addEventListener("deviceorientation", onOrient, { passive:true });
    }

    // stop if tab hidden (saves freebies)
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        // aggressive: stop everything when hidden
        stopPublishing();
      } else {
        // user must hit START again to resume (keeps UI minimal & avoids surprise audio)
      }
    });

    // try to stop on pagehide
    window.addEventListener("pagehide", stopPublishing);

    startBtn.addEventListener("click", async () => {
      startBtn.disabled = true;
      startBtn.textContent = "Starting…";

      try{
        const room = readRoomFromUrl();

        await requestMotionPerms();
        await startAudio();
        bindSensors();

        await connectAbly(room);
        startPublishing();

        // hide button (UI disappears)
        startBtn.classList.add("gone");

        // haptic tap (if supported)
        try { navigator.vibrate && navigator.vibrate(20); } catch(_) {}

      }catch(err){
        console.error(err);
        startBtn.disabled = false;
        startBtn.textContent = "START";
        // keep UI minimal: only communicate via alert
        alert(String(err && err.message ? err.message : err));
      }
    });
  </script>
</body>
</html>
