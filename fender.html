<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Defender-ish SFX Generator â€” Mobile</title>
  <style>
    :root{
      --bg:#ff3b18;      /* fierce orange/red */
      --ink:#000;        /* UI stroke */
      --btnFill:#000;    /* flat black buttons */
      --btnText:var(--bg);

      --gap:10px;

      /* piano keys */
      --keyH: 56vh;        /* tall stripe height */
      --keyMinH: 320px;
      --keyBorder: 2px;

      /* sliders */
      --sliderTrack:#000;
      --sliderKnob:#000;
    }

    html,body{height:100%;}
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font:14px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      letter-spacing:.2px;
      overflow-x:hidden;
    }
    *{ box-sizing:border-box; }

    /* phone-first wrap */
    .wrap{
      width:100%;
      max-width:520px;
      margin:0 auto;
      padding:14px 12px calc(18px + env(safe-area-inset-bottom));
    }

    /* Start overlay */
    .startOverlay{
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.10);
      z-index:9999;
      padding:24px;
    }
    .startBtn{
      width:min(360px, calc(100vw - 48px));
      padding:18px 14px;
      font-size:18px;
      font-weight:950;
      text-transform:uppercase;
      letter-spacing:1.2px;
      color:var(--btnText);
      background:var(--btnFill);
      border:3px solid #000;
      cursor:pointer;
    }
    .startBtn:active{ transform:translateY(1px); }

    /* sections */
    .panel{
      border:2px solid #000;
      background:transparent;
      margin-bottom:12px;
    }

    /* ===== Piano stripe keys ===== */
    .keys{
      display:flex;
      width:100%;
      height:clamp(var(--keyMinH), var(--keyH), 520px);
      border-bottom:2px solid #000;
    }
    .key{
      flex:1 1 0%;
      min-width:0;
      height:100%;
      background:var(--btnFill);
      border:var(--keyBorder) solid #000;
      border-top:0;
      border-bottom:0;
      padding:0;
      margin:0;
      cursor:pointer;
      position:relative;
    }
    /* keep only vertical separators between keys */
    .key + .key{ border-left:0; }

    /* tiny identifier dots (no labels) */
    .key::after{
      content:"";
      position:absolute;
      left:50%;
      top:10px;
      width:10px;
      height:10px;
      margin-left:-5px;
      border:2px solid var(--btnText);
      border-radius:50%;
      background:transparent;
      opacity:.85;
    }

    /* category color cues via subtle top bar (still orange as "text" color) */
    .key::before{
      content:"";
      position:absolute;
      left:0; top:0;
      height:6px;
      width:100%;
      background:var(--btnText);
      opacity:.85;
    }

    /* active press feedback */
    .key:active{ filter:brightness(1.18); }

    /* RANDOMIZE: full width */
    .row{
      display:flex;
      gap:10px;
      padding:12px;
      border-bottom:2px solid #000;
      align-items:stretch;
    }
    .row:last-child{ border-bottom:0; }

    button.big{
      width:100%;
      min-height:54px;
      background:var(--btnFill);
      color:var(--btnText);
      border:3px solid #000;
      font-weight:950;
      text-transform:uppercase;
      letter-spacing:1.1px;
      font-size:14px;
      cursor:pointer;
    }
    button.big:active{ transform:translateY(1px); }
    button.big:hover{ filter:brightness(1.12); }
    button.big:disabled{ opacity:.35; cursor:not-allowed; transform:none; }

    /* compact control tiles */
    .tile{
      border:2px solid #000;
      padding:10px 12px;
      display:flex;
      flex-direction:column;
      gap:8px;
      width:100%;
      background:transparent;
    }
    .tileHeader{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
    }
    .label{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.9px;
      font-weight:950;
      color:#000;
    }
    .value{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.9px;
      font-weight:950;
      color:#000;
    }

    /* sliders: basic line + circle */
    input[type="range"]{
      width:100%;
      -webkit-appearance:none;
      appearance:none;
      background:transparent;
      height:22px;
    }
    input[type="range"]::-webkit-slider-runnable-track{
      height:2px;
      background:var(--sliderTrack);
      border:none;
      border-radius:0;
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance:none;
      width:14px; height:14px;
      margin-top:-6px;
      background:transparent;
      border:2px solid var(--sliderKnob);
      border-radius:50%;
    }
    input[type="range"]::-moz-range-track{
      height:2px;
      background:var(--sliderTrack);
      border:none;
      border-radius:0;
    }
    input[type="range"]::-moz-range-thumb{
      width:14px; height:14px;
      background:transparent;
      border:2px solid var(--sliderKnob);
      border-radius:50%;
    }
    input[type="range"]::-moz-range-progress{
      height:2px;
      background:var(--sliderTrack);
      border:none;
    }

    select{
      width:100%;
      background:transparent;
      border:2px solid #000;
      color:#000;
      padding:10px 10px;
      outline:none;
      min-height:44px;
      cursor:pointer;
      font-weight:950;
      text-transform:uppercase;
      letter-spacing:.8px;
    }

    .status{
      border-top:2px solid #000;
      padding:10px 12px 12px;
      min-height:18px;
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:1px;
      font-weight:950;
      color:#000;
    }

    /* make sure it still looks ok on desktop: center + keep phone width */
    @media (min-width: 700px){
      body{
        display:flex;
        align-items:center;
        justify-content:center;
        min-height:100vh;
      }
      .wrap{ padding:20px 16px; }
    }
  </style>
</head>
<body>

  <div class="startOverlay" id="startOverlay" role="dialog" aria-modal="true">
    <button class="startBtn" id="bigStartBtn">start</button>
  </div>

  <div class="wrap">

    <!-- Piano keys panel -->
    <div class="panel">
      <div class="keys" id="keys">
        <!-- 9 vertical stripes, no labels -->
        <button class="key" id="k_laser"      aria-label="Laser"></button>
        <button class="key" id="k_zap"        aria-label="Zap"></button>
        <button class="key" id="k_thrust"     aria-label="Thrust"></button>
        <button class="key" id="k_explosion"  aria-label="Explosion"></button>
        <button class="key" id="k_pickup"     aria-label="Pickup"></button>
        <button class="key" id="k_alarm"      aria-label="Alarm"></button>
        <button class="key" id="k_smartbomb"  aria-label="Smart Bomb"></button>
        <button class="key" id="k_hyperspace" aria-label="Hyperspace"></button>
        <button class="key" id="k_teleport"   aria-label="Teleport"></button>
      </div>

      <div class="row">
        <button class="big" id="randAll">RANDOMIZE</button>
      </div>
    </div>

    <!-- Controls flow below -->
    <div class="panel">
      <div class="row" style="flex-direction:column;">
        <div class="tile">
          <div class="tileHeader">
            <div class="label">Frequency</div>
            <div class="value" id="crushVal">0.042</div>
          </div>
          <input id="crush" type="range" min="0" max="1" step="0.001" value="0.042">
        </div>

        <div class="tile">
          <div class="tileHeader">
            <div class="label">Master</div>
            <div class="value" id="masterVal">0.824</div>
          </div>
          <input id="master" type="range" min="0" max="1" step="0.001" value="0.824">
        </div>

        <div class="tile">
          <div class="tileHeader">
            <div class="label">Mutation</div>
            <div class="value" id="mutVal">0.964</div>
          </div>
          <input id="mutAmt" type="range" min="0" max="1" step="0.001" value="0.964">
        </div>

        <div class="tile">
          <div class="tileHeader">
            <div class="label">Mode</div>
            <div class="value" id="modeVal">Chaos</div>
          </div>
          <select id="mode">
            <option value="faithful">Faithful</option>
            <option value="spicy">Spicy</option>
            <option value="chaos" selected>Chaos</option>
          </select>
        </div>
      </div>

      <div class="status" id="status"></div>
    </div>

  </div>

<script>
(() => {
  const $ = (q) => document.querySelector(q);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp  = (a, b, t) => a + (b - a) * t;

  const HIDDEN_SEED = "DEFENDER";

  function hash32(str){
    let h = 2166136261 >>> 0;
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }
  function mulberry32(seed){
    let t = seed >>> 0;
    return function(){
      t += 0x6D2B79F5;
      let r = Math.imul(t ^ (t >>> 15), 1 | t);
      r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
      return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
    };
  }
  function triRand(rng){ return (rng() + rng()) * 0.5; }
  function randSym(rng){ return (triRand(rng) - 0.5) * 2.0; }

  function makeDriveCurve(amount){
    const n = 1024;
    const curve = new Float32Array(n);
    const k = amount;
    for (let i=0;i<n;i++){
      const x = (i * 2 / (n - 1)) - 1;
      curve[i] = (1 + k) * x / (1 + k * Math.abs(x));
    }
    return curve;
  }

  function adsrToZeroLinear(param, t0, A, D, S, R, peak=1.0){
    const a = Math.max(0.0005, A);
    const d = Math.max(0.001, D);
    const r = Math.max(0.001, R);

    const tA = t0 + a;
    const tD = tA + d;
    const tS = tD + Math.max(0, S);
    const tR = tS + r;

    param.cancelScheduledValues(t0);
    param.setValueAtTime(0, t0);
    param.linearRampToValueAtTime(peak, tA);
    param.linearRampToValueAtTime(0, tD);
    param.setValueAtTime(0, tS);
    param.linearRampToValueAtTime(0, tR);
    return tR;
  }

  function modeConfig(mode){
    if (mode === "faithful") return { wide: 0.75, jumpP: 0.08, jumpScale: 0.55 };
    if (mode === "chaos")   return { wide: 3.00, jumpP: 0.28, jumpScale: 1.65 };
    return { wide: 1.55, jumpP: 0.16, jumpScale: 1.00 };
  }
  function pickVal(rng, base, min, max, mutAmt, modeWide, jumpP, jumpScale){
    const span = (max - min);
    const jitter = randSym(rng) * span * 0.42 * modeWide;
    const jump = (rng() < (jumpP * (0.35 + 0.65 * mutAmt)))
      ? randSym(rng) * span * 0.70 * modeWide * jumpScale
      : 0;

    const rerollP = (0.03 + 0.10 * (modeWide/3.0)) * (0.25 + 0.75 * mutAmt);
    if (rng() < rerollP) return min + rng() * span;

    const v = base + (jitter + jump) * (0.25 + 0.75 * mutAmt);
    return clamp(v, min, max);
  }
  function pickDur(rng, base, min, max, mutAmt, modeWide){
    const span = max - min;
    const pTail = clamp(0.10 + 0.25 * mutAmt + 0.12 * (modeWide/3.0), 0.10, 0.55);
    const pUni  = clamp(0.10 + 0.20 * mutAmt, 0.10, 0.35);
    const rr = rng();

    let v;
    if (rr < pTail){
      const u = Math.pow(rng(), 0.35);
      v = min + u * span;
    } else if (rr < pTail + pUni){
      v = min + rng() * span;
    } else {
      const tri = triRand(rng);
      const jitter = (tri - 0.5) * 2.0 * span * (0.35 + 0.45 * mutAmt) * modeWide;
      v = base + jitter;
    }
    return clamp(v, min, max);
  }

  let ctx = null;
  let masterGain, compressor, postGain, crusher = null;
  let globalStop = [];
  let audioReady = false;

  const STEREO = { entry:null, bands:[], dry:null };

  function ensureAudio(){
    if (ctx) return ctx;
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    masterGain = ctx.createGain();
    compressor = ctx.createDynamicsCompressor();
    postGain = ctx.createGain();

    masterGain.gain.value = parseFloat($("#master").value);
    compressor.threshold.value = -18;
    compressor.knee.value = 24;
    compressor.ratio.value = 8;
    compressor.attack.value = 0.003;
    compressor.release.value = 0.12;
    postGain.gain.value = 0.95;

    masterGain.connect(compressor);
    compressor.connect(postGain);
    postGain.connect(ctx.destination);

    buildStereoBands();
    return ctx;
  }

  const now = () => ctx.currentTime;

  function makeBitcrusher(ctx){
    const inGain = ctx.createGain();
    const outGain = ctx.createGain();
    const proc = ctx.createScriptProcessor(1024, 1, 1);
    proc._ph = 0;
    proc._last = 0;

    proc.onaudioprocess = (e) => {
      const input = e.inputBuffer.getChannelData(0);
      const output = e.outputBuffer.getChannelData(0);

      const amount = parseFloat($("#crush").value);
      const step = Math.floor(lerp(1, 20, amount));
      const bits = Math.floor(lerp(16, 5, amount));
      const levels = (1 << bits) - 1;

      let ph = proc._ph;
      let last = proc._last;

      for (let i=0;i<input.length;i++){
        ph++;
        if (ph >= step){
          ph = 0;
          const q = Math.round((input[i] * 0.5 + 0.5) * levels) / levels;
          last = (q - 0.5) * 2.0;
        }
        output[i] = last;
      }
      proc._ph = ph;
      proc._last = last;
    };

    inGain.connect(proc);
    proc.connect(outGain);
    return { input: inGain, output: outGain, node: proc };
  }

  function ensureCrusher(){
    if (!crusher){
      crusher = makeBitcrusher(ctx);
      crusher.output.connect(STEREO.entry);
    }
  }

  function buildStereoBands(){
    STEREO.entry = ctx.createGain();
    STEREO.entry.gain.value = 1.0;

    const centers = [80, 120, 180, 260, 380, 560, 820, 1200, 2000, 3800, 6500, 9000];
    const Qs      = [1.2,1.4,1.6,1.8,2.0,2.2,2.4,2.6,2.8,3.0,3.2,3.4];

    centers.forEach((fc, i) => {
      const bp = ctx.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.value = fc;
      bp.Q.value = Qs[i % Qs.length];

      const pan = ctx.createStereoPanner();
      pan.pan.value = 0;

      const g = ctx.createGain();
      g.gain.value = 0.16;

      STEREO.entry.connect(bp);
      bp.connect(g);
      g.connect(pan);
      pan.connect(masterGain);

      STEREO.bands.push({ pan, gain:g, fc });
    });

    STEREO.dry = ctx.createGain();
    STEREO.dry.gain.value = 0.55;
    STEREO.entry.connect(STEREO.dry);
    STEREO.dry.connect(masterGain);
  }

  function randomizeStereoByFreq(rng){
    if (!STEREO.entry || !STEREO.bands.length) return;
    STEREO.bands.forEach((b) => {
      const fNorm = clamp((Math.log(b.fc) - Math.log(80)) / (Math.log(9000) - Math.log(80)), 0, 1);
      const maxPan = lerp(0.35, 1.0, fNorm);
      const pan = (rng()*2 - 1) * maxPan;
      const gJ = lerp(0.10, 0.26, rng());
      b.gain.gain.setValueAtTime(gJ, now());
      b.pan.pan.setValueAtTime(pan, now());
    });
  }

  function stopAll(){
    globalStop.forEach(fn => { try{ fn(); }catch(e){} });
    globalStop.length = 0;
  }

  let noiseBuf = null;
  function getNoiseBuffer(){
    if (noiseBuf) return noiseBuf;
    const dur = 2.0;
    const len = Math.floor(ctx.sampleRate * dur);
    const buf = ctx.createBuffer(1, len, ctx.sampleRate);
    const d = buf.getChannelData(0);

    let lfsr = 0xACE1;
    for (let i=0;i<len;i++){
      const bit = ((lfsr >> 0) ^ (lfsr >> 2) ^ (lfsr >> 3) ^ (lfsr >> 5)) & 1;
      lfsr = (lfsr >> 1) | (bit << 15);
      d[i] = ((lfsr & 1) ? 1 : -1) * 0.9;
    }
    noiseBuf = buf;
    return noiseBuf;
  }
  function noiseSource(){
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    src.loop = true;
    return src;
  }

  function feedbackDelay(input, timeSec, feedback, wet){
    const d = ctx.createDelay(1.0);
    d.delayTime.value = timeSec;
    const fb = ctx.createGain();
    fb.gain.value = feedback;

    const wetG = ctx.createGain();
    wetG.gain.value = wet;

    const dryG = ctx.createGain();
    dryG.gain.value = 1.0 - wet;

    input.connect(dryG);
    input.connect(d);
    d.connect(fb);
    fb.connect(d);

    const out = ctx.createGain();
    dryG.connect(out);
    d.connect(wetG);
    wetG.connect(out);

    return { out };
  }

  const BASE = {
    laser:      { baseHz: 900,  sweepHz: 520,  sweepTime: 0.055, bite: 0.55, click: 0.12, noise: 0.08, hp: 260, dur: 0.14 },
    zap:        { baseHz: 220,  sweepHz: 1400, sweepTime: 0.090, fmAmt: 180, fmHz: 32, noise: 0.18, bp: 1200, q: 8, dur: 0.22 },
    thrust:     { noise: 0.75,  lp: 520, q: 0.8, flutterHz: 16, flutterAmt: 0.18, dur: 0.45 },
    explosion:  { noise: 1.0,   lp0: 3800, lp1: 240, sweepTime: 0.32, boomHz: 62, boomAmt: 0.65, crackle: 0.25, dur: 0.95 },
    pickup:     { baseHz: 660,  upHz: 1320, glide: 0.12, vibHz: 10, vibAmt: 0.02, twang: 0.35, dur: 0.35 },
    alarm:      { aHz: 520,     bHz: 860,  rate: 9.0, edge: 0.6, dur: 0.95 },

    smartbomb:  { dur: 1.40, boomHz: 44, boomAmt: 0.9, sweep0: 5200, sweep1: 180, sweepTime: 0.75, ringHz: 220, ringAmt: 0.35, noise: 1.0, crackle: 0.35 },
    hyperspace: { dur: 1.20, whooshLP0: 4200, whooshLP1: 220, whooshTime: 0.75, tone0: 180, tone1: 1500, toneTime: 0.55, edge: 0.55, delayT: 0.075, delayFb: 0.45, wet: 0.35 },
    teleport:   { dur: 0.60, chirp0: 420, chirp1: 2200, chirpTime: 0.14, sparkleBP: 1800, sparkleQ: 9, sparkle: 0.28, edge: 0.45, delayT: 0.045, delayFb: 0.25, wet: 0.22 }
  };
  let patch = JSON.parse(JSON.stringify(BASE));

  let REV = 0;

  function randomizeAll(){
    REV++;

    const mode = $("#mode").value;
    const mutAmt = parseFloat($("#mutAmt").value);
    const { wide, jumpP, jumpScale } = modeConfig(mode);

    const seedStr = `${HIDDEN_SEED}|${mode}|${REV}`;
    const rng = mulberry32(hash32(seedStr));

    randomizeStereoByFreq(rng);

    const r  = (name, key, min, max) => patch[name][key] = pickVal(rng, BASE[name][key], min, max, mutAmt, wide, jumpP, jumpScale);
    const rd = (name, key, min, max) => patch[name][key] = pickDur(rng, BASE[name][key], min, max, mutAmt, wide);

    r("laser","baseHz",   260, 2200); r("laser","sweepHz",  60,  2600); r("laser","sweepTime",0.018,0.22);
    r("laser","bite",     0.02,1.00); r("laser","click",    0.00,0.45); r("laser","noise",    0.00,0.65);
    r("laser","hp",       30,  2200); rd("laser","dur",     0.05,2.20);

    r("zap","baseHz",     50,  900);  r("zap","sweepHz",    180, 5000); r("zap","sweepTime",  0.020,0.35);
    r("zap","fmAmt",      0,   2200); r("zap","fmHz",       2,   220);  r("zap","noise",      0.00,0.90);
    r("zap","bp",         160, 5200); r("zap","q",          0.6, 40);   rd("zap","dur",       0.07,2.60);

    r("thrust","noise",     0.10,1.00); r("thrust","lp",        80,  2400); r("thrust","q",         0.2, 10.0);
    r("thrust","flutterHz", 0.5, 60);   r("thrust","flutterAmt",0.00,0.75); rd("thrust","dur",      0.12,3.20);

    r("explosion","noise",     0.15,1.00); r("explosion","lp0",       600, 10000); r("explosion","lp1",       40,  1200);
    r("explosion","sweepTime", 0.10,2.20); r("explosion","boomHz",    16,  220);   r("explosion","boomAmt",   0.05,1.00);
    r("explosion","crackle",   0.00,1.00); rd("explosion","dur",      0.18,4.20);

    r("pickup","baseHz",  120, 2200); r("pickup","upHz",    220, 8200); r("pickup","glide",   0.02,0.70);
    r("pickup","vibHz",   0.5, 50);   r("pickup","vibAmt",  0.0, 0.20); r("pickup","twang",   0.00,1.00);
    rd("pickup","dur",    0.05,2.80);

    r("alarm","aHz",  80,  2200); r("alarm","bHz",  120, 5200); r("alarm","rate", 0.5, 40.0);
    r("alarm","edge", 0.00,1.00); rd("alarm","dur", 0.12,5.00);

    rd("smartbomb","dur",      0.25,5.50); r("smartbomb","boomHz",    10,  160); r("smartbomb","boomAmt",   0.05,1.00);
    r("smartbomb","sweep0",    700, 12000); r("smartbomb","sweep1",    30,  1800); r("smartbomb","sweepTime", 0.12,4.00);
    r("smartbomb","ringHz",    30,  1600);  r("smartbomb","ringAmt",   0.00,1.00); r("smartbomb","noise",     0.10,1.00);
    r("smartbomb","crackle",   0.00,1.00);

    rd("hyperspace","dur",       0.18,4.50); r("hyperspace","whooshLP0",  500, 12000); r("hyperspace","whooshLP1",  40,  2200);
    r("hyperspace","whooshTime", 0.10,3.20); r("hyperspace","tone0",      20,  900);   r("hyperspace","tone1",      80,  9000);
    r("hyperspace","toneTime",   0.06,2.60); r("hyperspace","edge",       0.00,1.00);  r("hyperspace","delayT",     0.010,0.250);
    r("hyperspace","delayFb",    0.00,0.88); r("hyperspace","wet",        0.00,0.85);

    rd("teleport","dur",         0.06,2.80); r("teleport","chirp0",       40,  2200); r("teleport","chirp1",       120, 12000);
    r("teleport","chirpTime",    0.02,0.95); r("teleport","sparkleBP",    120, 9000); r("teleport","sparkleQ",     0.6, 55.0);
    r("teleport","sparkle",      0.00,1.00); r("teleport","edge",         0.00,1.00); r("teleport","delayT",       0.005,0.180);
    r("teleport","delayFb",      0.00,0.78); r("teleport","wet",          0.00,0.80);
  }

  function routeToConsoleStereo(node){
    ensureCrusher();
    const local = ctx.createGain();
    local.gain.value = 1.0;
    node.connect(local);
    local.connect(crusher.input);
    globalStop.push(() => { try{ local.disconnect(); }catch(e){} });
    return local;
  }

  function playLaser(rng){
    const p = patch.laser, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const osc = ctx.createOscillator();
    osc.type = "square";
    osc.frequency.setValueAtTime(p.baseHz + p.sweepHz, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(20, p.baseHz), t0 + p.sweepTime);

    const shaper = ctx.createWaveShaper();
    shaper.curve = makeDriveCurve(lerp(10, 900, p.bite));
    shaper.oversample = "2x";

    const n = noiseSource();
    const nG = ctx.createGain(); nG.gain.value = 0;

    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.value = p.hp;

    const mixTone = ctx.createGain(); mixTone.gain.value = 1.0 - p.noise;
    const mixNoise = ctx.createGain(); mixNoise.gain.value = p.noise;

    const tEnd = adsrToZeroLinear(g.gain, t0, 0.002, Math.max(0.04, p.dur), 0, 0.001, 0.9);
    adsrToZeroLinear(nG.gain, t0, 0.001, Math.min(0.12, 0.02 + p.dur*0.25), 0, 0.001, Math.max(0.001, p.click));

    osc.connect(shaper); shaper.connect(mixTone);
    n.connect(hp); hp.connect(nG); nG.connect(mixNoise);
    mixTone.connect(g); mixNoise.connect(g);

    g.connect(out);
    routeToConsoleStereo(out);

    osc.start(t0); osc.stop(tEnd + 0.05);
    n.start(t0);   n.stop(tEnd + 0.05);

    setTimeout(() => { try{ out.disconnect(); }catch(e){} }, Math.max(0, (tEnd - now()) * 1000) + 250);
  }

  function playZap(rng){
    const p = patch.zap, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const osc = ctx.createOscillator();
    osc.type = "sawtooth";
    osc.frequency.setValueAtTime(p.baseHz, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(30, p.sweepHz), t0 + p.sweepTime);

    const mod = ctx.createOscillator();
    mod.type = "sine";
    mod.frequency.value = p.fmHz;
    const modG = ctx.createGain();
    modG.gain.value = p.fmAmt;
    mod.connect(modG);
    modG.connect(osc.frequency);

    const n = noiseSource();
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = p.bp;
    bp.Q.value = p.q;

    const mixTone = ctx.createGain(); mixTone.gain.value = 0.85;
    const mixNoise= ctx.createGain(); mixNoise.gain.value= p.noise;

    const tEnd = adsrToZeroLinear(g.gain, t0, 0.003, Math.max(0.05, p.dur), 0, 0.001, 1.0);

    osc.connect(mixTone);
    n.connect(bp); bp.connect(mixNoise);
    mixTone.connect(g); mixNoise.connect(g);

    g.connect(out);
    routeToConsoleStereo(out);

    osc.start(t0); osc.stop(tEnd + 0.05);
    mod.start(t0); mod.stop(tEnd + 0.05);
    n.start(t0);   n.stop(tEnd + 0.05);

    setTimeout(() => { try{ out.disconnect(); }catch(e){} }, Math.max(0, (tEnd - now()) * 1000) + 300);
  }

  function playThrust(rng){
    const p = patch.thrust, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const n = noiseSource();
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(p.lp, t0);
    lp.Q.value = p.q;

    const lfo = ctx.createOscillator();
    lfo.type = "sine";
    lfo.frequency.value = p.flutterHz;
    const lfoG = ctx.createGain();
    lfoG.gain.value = p.flutterAmt * 0.35;
    lfo.connect(lfoG);
    lfoG.connect(g.gain);

    const tEnd = adsrToZeroLinear(g.gain, t0, 0.008, Math.max(0.08, p.dur), 0, 0.001, 0.7);

    const mix = ctx.createGain();
    mix.gain.value = p.noise;

    n.connect(lp); lp.connect(mix); mix.connect(g);
    g.connect(out);
    routeToConsoleStereo(out);

    n.start(t0); n.stop(tEnd + 0.08);
    lfo.start(t0); lfo.stop(tEnd + 0.08);

    setTimeout(() => { try{ out.disconnect(); }catch(e){} }, Math.max(0, (tEnd - now()) * 1000) + 350);
  }

  function playExplosion(rng){
    const p = patch.explosion, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const A = 0.003;
    const D = clamp(p.dur, 0.08, 6.0);
    const R = 0.012;
    const tEnd = adsrToZeroLinear(g.gain, t0, A, D, 0, R, 1.0);

    const n = noiseSource();
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(p.lp0, t0);
    lp.frequency.exponentialRampToValueAtTime(Math.max(50, p.lp1), t0 + Math.min(p.sweepTime, D));
    lp.Q.value = 0.7;
    const nG = ctx.createGain(); nG.gain.value = 0;
    adsrToZeroLinear(nG.gain, t0, A, D, 0, R, clamp(p.noise, 0, 1));

    const boom = ctx.createOscillator();
    boom.type = "sine";
    boom.frequency.setValueAtTime(p.boomHz * 1.2, t0);
    boom.frequency.exponentialRampToValueAtTime(Math.max(12, p.boomHz), t0 + Math.min(0.35, D));
    const boomG = ctx.createGain(); boomG.gain.value = 0;
    adsrToZeroLinear(boomG.gain, t0, 0.002, Math.max(0.06, D*0.65), 0, R, clamp(p.boomAmt, 0, 1));

    const crack = noiseSource();
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.value = 1200;
    const crackG = ctx.createGain(); crackG.gain.value = 0;
    adsrToZeroLinear(crackG.gain, t0, 0.001, Math.max(0.04, D*0.45), 0, R, clamp(p.crackle, 0, 1));

    const mix = ctx.createGain(); mix.gain.value = 1.0;

    n.connect(lp); lp.connect(nG); nG.connect(mix);
    boom.connect(boomG); boomG.connect(mix);
    crack.connect(hp); hp.connect(crackG); crackG.connect(mix);

    mix.connect(g);
    g.connect(out);
    routeToConsoleStereo(out);

    n.start(t0); n.stop(tEnd + 0.12);
    crack.start(t0); crack.stop(tEnd + 0.12);
    boom.start(t0); boom.stop(tEnd + 0.12);

    setTimeout(() => { try{ out.disconnect(); }catch(e){} }, Math.max(0, (tEnd - now()) * 1000) + 700);
  }

  function playPickup(rng){
    const p = patch.pickup, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const osc = ctx.createOscillator();
    osc.type = "triangle";
    osc.frequency.setValueAtTime(p.baseHz, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(30, p.upHz), t0 + p.glide);

    const vib = ctx.createOscillator();
    vib.type = "sine";
    vib.frequency.value = p.vibHz;
    const vibG = ctx.createGain();
    vibG.gain.value = p.vibAmt * p.baseHz;
    vib.connect(vibG);
    vibG.connect(osc.frequency);

    const sh = ctx.createWaveShaper();
    sh.curve = makeDriveCurve(lerp(5, 900, p.twang));
    sh.oversample = "2x";

    const tEnd = adsrToZeroLinear(g.gain, t0, 0.004, Math.max(0.06, p.dur), 0, 0.01, 0.8);

    osc.connect(sh); sh.connect(g);
    g.connect(out);
    routeToConsoleStereo(out);

    osc.start(t0); osc.stop(tEnd + 0.06);
    vib.start(t0); vib.stop(tEnd + 0.06);

    setTimeout(() => { try{ out.disconnect(); }catch(e){} }, Math.max(0, (tEnd - now()) * 1000) + 250);
  }

  function playAlarm(rng){
    const p = patch.alarm, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const osc = ctx.createOscillator();
    osc.type = "square";
    osc.frequency.setValueAtTime(p.aHz, t0);

    const step = ctx.createOscillator();
    step.type = "square";
    step.frequency.value = p.rate;

    const stepG = ctx.createGain();
    stepG.gain.value = (p.bHz - p.aHz) * 0.5;
    step.connect(stepG);
    stepG.connect(osc.frequency);

    const sh = ctx.createWaveShaper();
    sh.curve = makeDriveCurve(lerp(5, 900, p.edge));
    sh.oversample = "2x";

    const tEnd = adsrToZeroLinear(g.gain, t0, 0.010, Math.max(0.10, p.dur), 0, 0.01, 0.55);

    osc.connect(sh); sh.connect(g);
    g.connect(out);
    routeToConsoleStereo(out);

    osc.start(t0);  osc.stop(tEnd + 0.06);
    step.start(t0); step.stop(tEnd + 0.06);

    setTimeout(() => { try{ out.disconnect(); }catch(e){} }, Math.max(0, (tEnd - now()) * 1000) + 300);
  }

  function playSmartBomb(rng){
    const p = patch.smartbomb, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const A = 0.003;
    const D = clamp(p.dur, 0.10, 8.0);
    const R = 0.014;
    const tEnd = adsrToZeroLinear(g.gain, t0, A, D, 0, R, 1.0);

    const n = noiseSource();
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(p.sweep0, t0);
    lp.frequency.exponentialRampToValueAtTime(Math.max(40, p.sweep1), t0 + Math.min(p.sweepTime, D));
    lp.Q.value = 0.75;
    const nG = ctx.createGain(); nG.gain.value = 0;
    adsrToZeroLinear(nG.gain, t0, A, D, 0, R, clamp(p.noise, 0, 1));

    const boom = ctx.createOscillator();
    boom.type = "sine";
    boom.frequency.setValueAtTime(p.boomHz * 1.15, t0);
    boom.frequency.exponentialRampToValueAtTime(Math.max(10, p.boomHz), t0 + Math.min(0.50, D));
    const boomG = ctx.createGain(); boomG.gain.value = 0;
    adsrToZeroLinear(boomG.gain, t0, 0.002, Math.max(0.08, D*0.75), 0, R, clamp(p.boomAmt, 0, 1));

    const ring = ctx.createOscillator();
    ring.type = "square";
    ring.frequency.setValueAtTime(p.ringHz, t0);
    ring.frequency.exponentialRampToValueAtTime(Math.max(10, p.ringHz * 0.45), t0 + Math.min(1.0, D*0.6));
    const ringG = ctx.createGain(); ringG.gain.value = 0;
    adsrToZeroLinear(ringG.gain, t0, 0.002, Math.max(0.08, D*0.85), 0, R, clamp(p.ringAmt, 0, 1));

    const ringSh = ctx.createWaveShaper();
    ringSh.curve = makeDriveCurve(lerp(5, 700, 0.6));
    ringSh.oversample = "2x";

    const crack = noiseSource();
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.value = 1000;
    const crackG = ctx.createGain(); crackG.gain.value = 0;
    adsrToZeroLinear(crackG.gain, t0, 0.001, Math.max(0.05, D*0.55), 0, R, clamp(p.crackle, 0, 1));

    const mix = ctx.createGain(); mix.gain.value = 1.0;

    n.connect(lp); lp.connect(nG); nG.connect(mix);
    boom.connect(boomG); boomG.connect(mix);
    ring.connect(ringSh); ringSh.connect(ringG); ringG.connect(mix);
    crack.connect(hp); hp.connect(crackG); crackG.connect(mix);

    mix.connect(g);
    g.connect(out);
    routeToConsoleStereo(out);

    n.start(t0); n.stop(tEnd + 0.12);
    crack.start(t0); crack.stop(tEnd + 0.12);
    boom.start(t0); boom.stop(tEnd + 0.12);
    ring.start(t0); ring.stop(tEnd + 0.12);

    setTimeout(() => { try{ out.disconnect(); }catch(e){} }, Math.max(0, (tEnd - now()) * 1000) + 700);
  }

  function playHyperspace(rng){
    const p = patch.hyperspace, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const n = noiseSource();
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(p.whooshLP0, t0);
    lp.frequency.exponentialRampToValueAtTime(Math.max(60, p.whooshLP1), t0 + p.whooshTime);
    lp.Q.value = 0.8;
    const nG = ctx.createGain(); nG.gain.value = 0.65;

    const osc = ctx.createOscillator();
    osc.type = "sawtooth";
    osc.frequency.setValueAtTime(p.tone0, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(20, p.tone1), t0 + p.toneTime);

    const sh = ctx.createWaveShaper();
    sh.curve = makeDriveCurve(lerp(5, 1100, p.edge));
    sh.oversample = "2x";
    const oG = ctx.createGain(); oG.gain.value = 0.40;

    const mix = ctx.createGain();
    n.connect(lp); lp.connect(nG); nG.connect(mix);
    osc.connect(sh); sh.connect(oG); oG.connect(mix);

    const fx = feedbackDelay(mix, p.delayT, p.delayFb, p.wet);

    const tEnd = adsrToZeroLinear(g.gain, t0, 0.010, Math.max(0.10, p.dur), 0, 0.01, 0.85);

    fx.out.connect(g);
    g.connect(out);
    routeToConsoleStereo(out);

    n.start(t0);   n.stop(tEnd + 0.10);
    osc.start(t0); osc.stop(tEnd + 0.10);

    setTimeout(() => { try{ out.disconnect(); }catch(e){} }, Math.max(0, (tEnd - now()) * 1000) + 450);
  }

  function playTeleport(rng){
    const p = patch.teleport, t0 = now();
    randomizeStereoByFreq(rng);

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0;

    const osc = ctx.createOscillator();
    osc.type = "triangle";
    osc.frequency.setValueAtTime(p.chirp0, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(20, p.chirp1), t0 + p.chirpTime);

    const sh = ctx.createWaveShaper();
    sh.curve = makeDriveCurve(lerp(5, 1100, p.edge));
    sh.oversample = "2x";
    const oG = ctx.createGain(); oG.gain.value = 0.60;

    const n = noiseSource();
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = p.sparkleBP;
    bp.Q.value = p.sparkleQ;
    const nG = ctx.createGain(); nG.gain.value = p.sparkle;

    const mix = ctx.createGain();
    osc.connect(sh); sh.connect(oG); oG.connect(mix);
    n.connect(bp); bp.connect(nG); nG.connect(mix);

    const fx = feedbackDelay(mix, p.delayT, p.delayFb, p.wet);

    const tEnd = adsrToZeroLinear(g.gain, t0, 0.003, Math.max(0.06, p.dur), 0, 0.01, 0.85);

    fx.out.connect(g);
    g.connect(out);
    routeToConsoleStereo(out);

    osc.start(t0); osc.stop(tEnd + 0.08);
    n.start(t0);   n.stop(tEnd + 0.08);

    setTimeout(() => { try{ out.disconnect(); }catch(e){} }, Math.max(0, (tEnd - now()) * 1000) + 300);
  }

  function setControlsEnabled(enabled){
    const ids = [
      "k_laser","k_zap","k_thrust","k_explosion","k_pickup","k_alarm","k_smartbomb","k_hyperspace","k_teleport",
      "randAll","master","crush","mode","mutAmt"
    ];
    ids.forEach(id => { const el = $("#"+id); if (el) el.disabled = !enabled; });
  }

  function stopThenPlay(playFn){
    if (!audioReady || !ctx) return;
    stopAll();
    const tag = `${HIDDEN_SEED}|${$("#mode").value}|${REV}|play|${performance.now().toFixed(3)}`;
    const rng = mulberry32(hash32(tag));
    randomizeStereoByFreq(rng);
    playFn(rng);
  }

  async function startSession(){
    ensureAudio();
    ensureCrusher();
    if (ctx.state !== "running") await ctx.resume();
    audioReady = true;
    $("#startOverlay").style.display = "none";
    setControlsEnabled(true);
    masterGain.gain.value = parseFloat($("#master").value);
    $("#status").textContent = "";
  }

  function updateReadouts(){
    $("#crushVal").textContent  = (+$("#crush").value).toFixed(3);
    $("#masterVal").textContent = (+$("#master").value).toFixed(3);
    $("#mutVal").textContent    = (+$("#mutAmt").value).toFixed(3);
    const m = $("#mode").value;
    $("#modeVal").textContent = m.charAt(0).toUpperCase() + m.slice(1);
  }

  function hook(){
    setControlsEnabled(false);
    updateReadouts();

    $("#bigStartBtn").addEventListener("click", startSession);
    $("#startOverlay").addEventListener("click", (e) => {
      if (e.target.id === "startOverlay") startSession();
    });

    $("#master").addEventListener("input", (e) => {
      updateReadouts();
      if (masterGain) masterGain.gain.value = +e.target.value;
    });
    $("#crush").addEventListener("input", updateReadouts);
    $("#mutAmt").addEventListener("input", updateReadouts);
    $("#mode").addEventListener("change", updateReadouts);

    $("#randAll").addEventListener("click", () => {
      if (!audioReady) return;
      stopAll();
      randomizeAll();
      $("#status").textContent = "randomized";
      setTimeout(() => { if ($("#status").textContent === "randomized") $("#status").textContent = ""; }, 650);
    });

    // piano keys
    $("#k_laser").addEventListener("click", () => stopThenPlay(playLaser));
    $("#k_zap").addEventListener("click", () => stopThenPlay(playZap));
    $("#k_thrust").addEventListener("click", () => stopThenPlay(playThrust));
    $("#k_explosion").addEventListener("click", () => stopThenPlay(playExplosion));
    $("#k_pickup").addEventListener("click", () => stopThenPlay(playPickup));
    $("#k_alarm").addEventListener("click", () => stopThenPlay(playAlarm));
    $("#k_smartbomb").addEventListener("click", () => stopThenPlay(playSmartBomb));
    $("#k_hyperspace").addEventListener("click", () => stopThenPlay(playHyperspace));
    $("#k_teleport").addEventListener("click", () => stopThenPlay(playTeleport));

    // keyboard support (desktop testing)
    window.addEventListener("keydown", (e) => {
      if (e.repeat) return;
      if (!audioReady && (e.key === "Enter" || e.key === " ")){ e.preventDefault(); startSession(); return; }
      if (!audioReady) return;
      if (e.key === "r" || e.key === "R"){ $("#randAll").click(); return; }
      const map = {"1":"k_laser","2":"k_zap","3":"k_thrust","4":"k_explosion","5":"k_pickup","6":"k_alarm","7":"k_smartbomb","8":"k_hyperspace","9":"k_teleport"};
      if (map[e.key]) $("#"+map[e.key]).click();
    });
  }

  hook();
})();
</script>
</body>
</html>
