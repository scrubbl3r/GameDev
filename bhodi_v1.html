<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VECTOR LEVITATION — Incantation Test (Dual Circles v1)</title>
  <style>
    :root{
      --g:#32ff75;
      --g2:rgba(50,255,117,.60);
      --g3:rgba(50,255,117,.20);
      --bg:#020402;
      --hudbg: rgba(0,0,0,.42);
      --border: rgba(50,255,117,.18);
      --danger:#ff2b2b;
    }

    html, body {
      margin:0; height:100%;
      background: radial-gradient(1200px 700px at 50% 35%, #061306 0%, var(--bg) 55%, #000 100%);
      overflow:hidden;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      color: var(--g);
    }

    #wrap { position:fixed; inset:0; display:grid; place-items:center; }

    canvas {
      width: min(96vw, 940px);
      height: min(90vh, 640px);
      background: transparent;
      border-radius: 18px;
      box-shadow: 0 0 0 1px rgba(50,255,117,.18), 0 18px 80px rgba(0,0,0,.65);
    }

    /* CRT vibes */
    #crt { position:fixed; inset:0; pointer-events:none; }
    #crt::before{
      content:"";
      position:absolute; inset:0;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255,255,255,.035) 0px,
          rgba(255,255,255,.035) 1px,
          rgba(0,0,0,0) 3px,
          rgba(0,0,0,0) 4px
        );
      mix-blend-mode: overlay;
      opacity:.20;
    }
    #crt::after{
      content:"";
      position:absolute; inset:-20%;
      background: radial-gradient(circle at 50% 45%, rgba(50,255,117,.10), rgba(0,0,0,0) 55%);
      filter: blur(10px);
      opacity:.35;
    }

    #hud {
      position:fixed; left:14px; top:14px;
      font-size:12px; line-height:1.35;
      padding:10px 12px;
      border-radius: 12px;
      background: var(--hudbg);
      border: 1px solid var(--border);
      box-shadow: 0 0 22px rgba(50,255,117,.06);
      max-width: 820px;
      text-shadow: 0 0 10px rgba(50,255,117,.18);
      backdrop-filter: blur(6px);
    }
    #hud b { color: var(--g); }
    #hud .dim { opacity:.50; }
    #hud .ok { color: #7dffab; }
    #hud .bad { color: #ff8080; }
    #hud .warn { color: #ffd27d; }
    #hud .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    #hud label { cursor:pointer; user-select:none; }
    #hud input[type="checkbox"]{
      accent-color: var(--g);
      transform: translateY(1px);
    }

    /* WIN / GAME OVER overlay (existing) */
    #overlay {
      position:fixed; inset:0;
      display:none; place-items:center;
      background: rgba(0,0,0,.60);
    }
    #overlay .card{
      padding:22px 26px;
      border-radius: 18px;
      border: 1px solid rgba(50,255,117,.25);
      background: rgba(0,0,0,.62);
      box-shadow: 0 0 40px rgba(50,255,117,.10), 0 26px 120px rgba(0,0,0,.65);
      text-align:center;
      color: var(--g);
      text-shadow: 0 0 18px rgba(50,255,117,.22);
      min-width: 320px;
    }
    #overlay .card .sub{
      margin-top:8px;
      font-size:12px;
      opacity:.85;
      letter-spacing:0;
      font-weight:500;
    }
    #overlay .card .hint{
      margin-top:14px;
      font-size:11px;
      opacity:.65;
    }

    /* START GATE (new) */
    #startGate{
      position:fixed; inset:0;
      display:grid; place-items:center;
      background: rgba(0,0,0,.86);
      z-index: 50;
    }
    #startGate .card{
      width: min(92vw, 720px);
      padding: 26px 26px 22px;
      border-radius: 18px;
      background: rgba(0,0,0,.72);
      /* NO STROKE (schema update) */
      border: none;
      box-shadow: 0 0 0 1px rgba(50,255,117,.14), 0 0 60px rgba(50,255,117,.08), 0 30px 130px rgba(0,0,0,.75);
      text-align:center;
      color: var(--g);
      text-shadow: 0 0 18px rgba(50,255,117,.22);
      cursor: pointer;
      user-select:none;
    }
    #startGate .title{
      font-size: 22px;
      letter-spacing: 1.8px;
      text-transform: uppercase;
      line-height: 1.25;
    }
    #startGate .sub{
      margin-top: 10px;
      font-size: 12px;
      opacity:.85;
    }
    #startGate .hint{
      margin-top: 14px;
      font-size: 11px;
      opacity:.70;
    }
    #startGate .pillRow{
      margin-top: 16px;
      display:flex;
      justify-content:center;
      gap:10px;
      flex-wrap:wrap;
    }
    #startGate .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 7px 10px;
      border-radius: 999px;
      background: rgba(50,255,117,.08);
      box-shadow: 0 0 0 1px rgba(50,255,117,.16) inset;
      font-size: 11px;
      opacity:.95;
    }
    #startGate .dot{
      width:6px;height:6px;border-radius:99px;
      background: var(--g);
      box-shadow: 0 0 10px rgba(50,255,117,.35);
    }

    #webcam {
      position:fixed; right:14px; top:14px;
      width: 220px; height: 165px;
      border-radius: 14px;
      overflow:hidden;
      border:1px solid rgba(50,255,117,.22);
      box-shadow: 0 0 24px rgba(50,255,117,.08), 0 12px 50px rgba(0,0,0,.55);
      background:#000;
    }
    #webcam video {
      width:100%; height:100%;
      object-fit:cover;
      transform: scaleX(-1);
      filter: contrast(1.1) brightness(.95) saturate(1.05);
      opacity:.92;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="900" height="600"></canvas>
  </div>

  <!-- START SCREEN (new) -->
  <div id="startGate" aria-hidden="false">
    <div class="card" id="startCard" role="button" tabindex="0" aria-label="Start">
      <div class="title">TIME. IS. A. FLAT. CIRCLE.</div>
      <div class="sub">Click to begin — voice is pre-opted-in.</div>
      <div class="pillRow">
        <div class="pill"><span class="dot"></span> VOICE: ON</div>
        <div class="pill">V key toggles later</div>
        <div class="pill">Two hands → circles → lift</div>
      </div>
      <div class="hint">Browser requirement: this click starts speech recognition.</div>
    </div>
  </div>

  <div id="hud">
    <div><b>VECTOR LEVITATION</b> <span class="dim">— Incantation Test (Dual Circles v1)</span></div>
    <div class="dim">• <b>Two hands</b>: draw circles → combined levitation</div>
    <div class="dim">• <b>Steering</b>: circle quality difference steers (falls back to 1-hand steering if a hand drops)</div>
    <div class="dim">• <b>Danger</b>: touch the red teeth underside → <b>GAME OVER</b></div>
    <div class="dim">• <b>Spell</b>: approach the final platform until it glows, then speak: <b>"satanis mentis maximus"</b></div>

    <div class="row" style="margin-top:6px;">
      <label class="dim" title="Default ON in this build">
        <input id="voiceOpt" type="checkbox" checked />
        VOICE opt-in
      </label>
      <span class="dim">• Click the start screen once to begin.</span>
    </div>

    <hr style="border:none;border-top:1px solid rgba(50,255,117,.18); margin:10px 0;">
    <div id="status">Initializing…</div>
  </div>

  <div id="overlay">
    <div class="card" id="overlayCard">
      <div id="overlayTitle" style="font-size:22px; letter-spacing:1.2px; text-transform:uppercase;">—</div>
      <div class="sub" id="overlaySub">—</div>
      <div class="hint" id="overlayHint">Reload the page to try again.</div>
    </div>
  </div>

  <div id="webcam"><video id="video" playsinline autoplay muted></video></div>
  <div id="crt"></div>

  <script type="module">
    // NOTE: This build avoids optional chaining / nullish coalescing / Unicode property escapes
    // so a parse-time syntax error can’t hard-crash older runtimes.

    import vision from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";
    const HandLandmarker = vision.HandLandmarker;
    const FilesetResolver = vision.FilesetResolver;

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const video = document.getElementById("video");
    const statusEl = document.getElementById("status");
    const overlay = document.getElementById("overlay");

    const overlayTitle = document.getElementById("overlayTitle");
    const overlaySub   = document.getElementById("overlaySub");
    const overlayHint  = document.getElementById("overlayHint");
    const overlayCard  = document.getElementById("overlayCard");

    // START GATE (new)
    const startGate = document.getElementById("startGate");
    const startCard = document.getElementById("startCard");
    const voiceOpt  = document.getElementById("voiceOpt");

    // =========================================================================
    // TUNING
    // =========================================================================
    const TUNE = {
      worldH: 2000,
      camFollowYFrac: 0.50,
      camSmoothing: 10.0,
      floorOffsetPx: 53,
      proximityArmPx: 250,

      trailMax: 30,
      minTrailSamples: 14,
      minRadiusPx: 18,
      radialTolerance: 0.72,
      coverageBins: 12,
      coverageMin: 0.20,
      coverageFull: 0.75,
      loopLenMultiplier: 0.45,
      expRadial: 0.95,
      expCoverage: 0.95,
      expLoop: 0.5,

      gravity: 550,
      damping: 0.992,
      xDrag: 1.15,
      yDrag: 2.2,
      liftMax: 3400,

      chargeBuild: 7.8,
      chargeDecay: 4.2,
      liftGateLo: 0.12,
      liftGateHi: 1.20,

      maxRiseSpeed: 150,
      maxFallSpeed: 1800,

      spellXFrac: 0.50,
      spellYFrac: 0.52,
      spellRadius: 84,
      spellReticleBaseAlpha: 0.10,
      spellReticleGainAlpha: 0.65,
      spellActiveGraceMs: 520,

      steerCenterXFrac: 0.50,
      steerDeadzone: 0.03,
      steerExpo: 1.10,
      steerMaxSpeed: 1300,
      steerVxResponse: 24.0,
      steerCastGate: 0.25,
      showSteerLine: true,

      platformAlphaBase: 0.80,
      platformGlowReserve: 0.20,

      incantation: "time is a flat circle",

      handBlendGraceMs: 520,
      diffSteerDeadzone: 0.06,
      diffSteerExpo: 1.25,

      // collision energy retention (0..1)
      bounceSide: 0.25,
      bounceUnderWin: 0.20,

      // teeth look (triangle wave)
      teethHeight: 14,
      teethStep: 18
    };

    // =========================================================================
    // Helpers
    // =========================================================================
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    // FIX: no px1 typo (this was your previous crash)
    function distPointAABB(px, py, x0, y0, x1, y1) {
      const dx = (px < x0) ? (x0 - px) : (px > x1 ? (px - x1) : 0);
      const dy = (py < y0) ? (y0 - py) : (py > y1 ? (py - y1) : 0);
      return Math.hypot(dx, dy);
    }

    // Safer normalization (no \p{…} unicode property escapes)
    function normalizeSpeech(s){
      return String(s || "")
        .toLowerCase()
        .replace(/[^a-z0-9\s]+/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function matchesIncantation(transcript){
      const t = normalizeSpeech(transcript);
      const a = normalizeSpeech(TUNE.incantation);
      if (!t) return false;
      if (t.indexOf(a) !== -1) return true;
      return (t.indexOf("mentis") !== -1) && (t.indexOf("maximus") !== -1) &&
             ((t.indexOf("satanis") !== -1) || (t.indexOf("satanus") !== -1) || (t.indexOf("satana") !== -1));
    }

    function handWeight(lastSeenMs, now){
      const dt = now - lastSeenMs;
      return clamp(1 - (dt / TUNE.handBlendGraceMs), 0, 1);
    }

    function pointInAABB(px, py, x0, y0, x1, y1){
      return (px >= x0 && px <= x1 && py >= y0 && py <= y1);
    }

    function showOverlay(kind){
      overlay.style.display = "grid";

      if (kind === "win") {
        overlayTitle.textContent = "GOD IS DEAD";
        overlaySub.textContent   = "The platform heard you.";
        overlayHint.textContent  = "Reload the page to run the ritual again.";
        overlayCard.style.borderColor = "rgba(50,255,117,.25)";
        overlayCard.style.boxShadow   = "0 0 40px rgba(50,255,117,.10), 0 26px 120px rgba(0,0,0,.65)";
        overlayCard.style.color       = "var(--g)";
      } else {
        overlayTitle.textContent = "GAME OVER";
        overlaySub.textContent   = "You touched the red teeth.";
        overlayHint.textContent  = "Reload the page to try again.";
        overlayCard.style.borderColor = "rgba(255,43,43,.45)";
        overlayCard.style.boxShadow   = "0 0 55px rgba(255,43,43,.18), 0 26px 120px rgba(0,0,0,.65)";
        overlayCard.style.color       = "var(--danger)";
      }
    }

    // =========================================================================
    // World + camera
    // =========================================================================
    const W = canvas.width, H = canvas.height;
    const WORLD_H = TUNE.worldH;
    const floorY = WORLD_H - TUNE.floorOffsetPx;

    let camY = 0;
    let camTargetY = 0;
    function worldToScreenY(yw){ return yw - camY; }

    // =========================================================================
    // Platforms
    // =========================================================================
    function mulberry32(seed) {
      return function() {
        let t = seed += 0x6D2B79F5;
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }
    const rnd = mulberry32(1337);
    function randRange(a,b){ return a + (b-a)*rnd(); }

    const WIN_Y = 440;

    function makePlatforms(){
      const plats = [];

      let y = floorY - 220;
      const stopY = WIN_Y + 140;

      while (y > stopY) {
        const gap = Math.floor(randRange(100, 301));
        y -= gap;
        if (y <= stopY) break;

        const w = 220;
        const h = 18;
        const x = clamp(randRange(40, W - w - 40), 10, W - w - 10);

        plats.push({ x:x, y:y, w:w, h:h, isWinning:false, spelled:false });
      }

      plats.push({
        x: (W - 240) * 0.52,
        y: WIN_Y,
        w: 240,
        h: 18,
        isWinning: true,
        spelled: false
      });

      plats.sort(function(a,b){ return b.y - a.y; });
      return plats;
    }

    const platforms = makePlatforms();
    let winningPlatform = null;
    for (let i=0;i<platforms.length;i++){
      if (platforms[i].isWinning) { winningPlatform = platforms[i]; break; }
    }

    // =========================================================================
    // Ball
    // =========================================================================
    const ball = {
      r: 18,
      x: W * 0.5,
      y: floorY - 40,
      vx: 0,
      vy: 0,
      prevX: W * 0.5,
      prevY: floorY - 40,
      alive: true
    };

    let won = false;
    let gameOver = false;

    // =========================================================================
    // Hand tracking state
    // =========================================================================
    let handLandmarker = null;
    let runningMode = "VIDEO";
    let lastVideoTime = -1;

    let scoreL = 0;
    let scoreR = 0;

    let circleEnergy = 0;
    let liftCharge = 0;

    let castX = W * 0.5;

    const trailL = [];
    const trailR = [];
    let lastLeftSeenMs  = -1e9;
    let lastRightSeenMs = -1e9;

    function computeCircleScore(points) {
      if (points.length < TUNE.minTrailSamples) return 0;

      let cx = 0, cy = 0;
      for (let i=0;i<points.length;i++){ cx += points[i].x; cy += points[i].y; }
      cx /= points.length; cy /= points.length;

      const rs = new Array(points.length);
      let rSum = 0;
      for (let i=0;i<points.length;i++){
        const dx = points[i].x - cx;
        const dy = points[i].y - cy;
        const r = Math.hypot(dx, dy);
        rs[i] = r;
        rSum += r;
      }
      const rMean = rSum / rs.length;
      if (rMean < TUNE.minRadiusPx) return 0;

      let varR = 0;
      for (let i=0;i<rs.length;i++){
        const d = rs[i] - rMean;
        varR += d*d;
      }
      varR /= rs.length;
      const rStd = Math.sqrt(varR);
      const radialErr = rStd / rMean;
      const radialScore = clamp(1 - (radialErr / TUNE.radialTolerance), 0, 1);

      const bins = TUNE.coverageBins;
      const hit = new Array(bins);
      for (let i=0;i<bins;i++) hit[i] = false;

      for (let i=0;i<points.length;i++){
        const a = Math.atan2(points[i].y - cy, points[i].x - cx);
        const norm = (a + Math.PI) / (2 * Math.PI);
        const b = Math.floor(norm * bins) % bins;
        hit[b] = true;
      }
      let hitCount = 0;
      for (let i=0;i<bins;i++) if (hit[i]) hitCount++;
      const coverage = hitCount / bins;

      const coverageScore = clamp(
        (coverage - TUNE.coverageMin) / (TUNE.coverageFull - TUNE.coverageMin),
        0, 1
      );

      let pathLen = 0;
      for (let i=1;i<points.length;i++){
        pathLen += Math.hypot(points[i].x - points[i-1].x, points[i-1].y - points[i].y) * 0 + Math.hypot(points[i].x - points[i-1].x, points[i].y - points[i-1].y);
      }
      const circumference = 2 * Math.PI * rMean;
      const loopScore = clamp(pathLen / (circumference * TUNE.loopLenMultiplier), 0, 1);

      const s =
        Math.pow(radialScore, TUNE.expRadial) *
        Math.pow(coverageScore, TUNE.expCoverage) *
        Math.pow(loopScore, TUNE.expLoop);

      return clamp(s, 0, 1);
    }

    // =========================================================================
    // Webcam + MediaPipe init
    // =========================================================================
    async function setupWebcam() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user", width: 640, height: 480 },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
    }

    async function initLandmarker() {
      statusEl.innerHTML = "Loading hand model…";

      const visionFileset = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
      );

      const modelUrl =
        "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/latest/hand_landmarker.task";

      handLandmarker = await HandLandmarker.createFromOptions(visionFileset, {
        baseOptions: { modelAssetPath: modelUrl },
        runningMode: runningMode,
        numHands: 2,
        minHandDetectionConfidence: 0.55,
        minHandPresenceConfidence: 0.55,
        minTrackingConfidence: 0.55
      });

      statusEl.innerHTML = '<span class="ok">Webcam ready.</span> Click the start screen to enable voice.';
    }

    // =========================================================================
    // Hand controls (no optional chaining)
    // =========================================================================
    function pushTrail(trail, mx, my, now){
      trail.push({ x: mx, y: my, t: now });
      while (trail.length > TUNE.trailMax) trail.shift();
    }

    function decayTrail(trail){
      if (!trail.length) return;
      trail.splice(0, Math.max(2, Math.floor(trail.length * 0.30)));
    }

    function applyHandControls(result) {
      const handed = (result && (result.handedness || result.handednesses)) ? (result.handedness || result.handednesses) : [];
      const lms = (result && result.landmarks) ? result.landmarks : [];

      let leftTip = null;
      let rightTip = null;

      for (let i=0;i<lms.length;i++){
        const pts = lms[i];
        if (!pts || pts.length < 9) continue;

        // handedness extraction (many shapes exist)
        let name = null;
        const h = handed[i];
        if (h && h[0] && (h[0].categoryName || h[0].displayName)) name = h[0].categoryName || h[0].displayName;
        if (!name && h && h.categories && h.categories[0]) name = h.categories[0].categoryName || h.categories[0].displayName;

        const tip = { x: pts[8].x, y: pts[8].y };
        if (name === "Left")  leftTip = tip;
        if (name === "Right") rightTip = tip;
      }

      const now = performance.now();

      if (rightTip) {
        lastRightSeenMs = now;
        const mx = (1 - rightTip.x) * W;
        const my = rightTip.y * H;
        castX = mx;
        pushTrail(trailR, mx, my, now);
        scoreR = computeCircleScore(trailR);
      } else {
        scoreR *= 0.90;
        decayTrail(trailR);
      }

      if (leftTip) {
        lastLeftSeenMs = now;
        const mx = (1 - leftTip.x) * W;
        const my = leftTip.y * H;
        if (!rightTip) castX = mx;
        pushTrail(trailL, mx, my, now);
        scoreL = computeCircleScore(trailL);
      } else {
        scoreL *= 0.90;
        decayTrail(trailL);
      }
    }

    // =========================================================================
    // Speech
    // =========================================================================
    let voiceEnabled = false;
    let recognition = null;
    let lastHeard = "";
    let lastSpellMs = 0;

    function setupSpeechRecognition(){
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) return false;

      recognition = new SR();
      recognition.continuous = true;
      recognition.interimResults = true;
      recognition.lang = "en-US";

      recognition.onresult = function(event){
        const n = event.results.length;
        const start = Math.max(0, n - 4);
        for (let i=start;i<n;i++){
          const res = event.results[i];
          if (!res || !res[0]) continue;

          const transcript = res[0].transcript || "";
          lastHeard = transcript;

          const isFinal = !!res.isFinal;

          if (armed && winningPlatform && !winningPlatform.spelled && matchesIncantation(transcript) && (isFinal || transcript.length > 10)) {
            winningPlatform.spelled = true;
            lastSpellMs = performance.now();
            break;
          }
        }
      };

      recognition.onerror = function(){};
      recognition.onend = function(){
        if (voiceEnabled) {
          try { recognition.start(); } catch(e) {}
        }
      };

      return true;
    }

    function startVoice(){
      if (voiceEnabled) return;
      const ok = setupSpeechRecognition();
      if (!ok) { voiceEnabled = false; return; }
      voiceEnabled = true;
      try { recognition.start(); } catch(e) {}
    }

    function stopVoice(){
      if (!voiceEnabled) return;
      voiceEnabled = false;
      if (recognition) {
        try { recognition.stop(); } catch(e) {}
      }
    }

    // =========================================================================
    // START SCREEN GATE (new)
    // =========================================================================
    let started = false;

    function beginFromGate(){
      if (started) return;
      started = true;

      if (startGate) startGate.style.display = "none";

      // auto voice (opt-in is checked in this build)
      if (voiceOpt && voiceOpt.checked) startVoice();

      // small HUD nudge
      // (status will update on next step() call anyway)
    }

    if (startCard) {
      startCard.addEventListener("pointerdown", function(e){
        e.preventDefault();
        beginFromGate();
      }, { passive:false });
      startCard.addEventListener("keydown", function(e){
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          beginFromGate();
        }
      });
    }

    // toggle voice anytime (after start)
    window.addEventListener("keydown", function(e){
      if (e.key === "v" || e.key === "V") {
        if (!started) return; // keep the schema clean: start screen is the gesture
        if (voiceEnabled) stopVoice(); else startVoice();
      }
      if (!started && (e.key === "Enter" || e.key === " ")) {
        beginFromGate();
      }
    });

    if (voiceOpt) {
      voiceOpt.addEventListener("change", function(){
        if (!started) return;
        if (voiceOpt.checked) startVoice();
        else stopVoice();
      });
    }

    // =========================================================================
    // Background
    // =========================================================================
    const worldGroundY = floorY -  (TUNE.floorOffsetPx - 53);
    const mountainsBaseY = worldGroundY - 50;

    const mountains = (function(){
      const r2 = mulberry32(1337);
      const pts = [];
      const step = 26;
      let x = -20;
      while (x < W + 40) {
        const peak = r2() < 0.45;
        const dy = peak ? (18 + r2() * 52) : (6 + r2() * 22);
        pts.push({ x:x, y:(mountainsBaseY - dy) });
        x += step + r2() * 16;
      }
      pts.unshift({ x:-40, y:mountainsBaseY - 14 });
      pts.push({ x:W + 60, y:mountainsBaseY - 16 });
      return pts;
    })();

    function drawWorldPolyline(points, strokeStyle, lineWidth, alpha) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = lineWidth;
      ctx.beginPath();
      ctx.moveTo(points[0].x, worldToScreenY(points[0].y));
      for (let i=1;i<points.length;i++){
        ctx.lineTo(points[i].x, worldToScreenY(points[i].y));
      }
      ctx.stroke();
      ctx.restore();
    }

    function drawWorldLine(yWorld, strokeStyle, lineWidth, alpha){
      const y = worldToScreenY(yWorld);
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = strokeStyle;
      ctx.lineWidth = lineWidth;
      ctx.beginPath();
      ctx.moveTo(-40, y);
      ctx.lineTo(W+40, y);
      ctx.stroke();
      ctx.restore();
    }

    function drawStars(){
      ctx.save();
      ctx.globalAlpha = 0.16;
      ctx.fillStyle = "rgba(50,255,117,1)";
      for (let i=0;i<140;i++){
        const x = (i*97) % W;
        const yWorld = (i*211) % WORLD_H;
        const y = worldToScreenY(yWorld);
        if (y < -2 || y > H+2) continue;
        ctx.fillRect(x, y, 1, 1);
      }
      ctx.restore();
    }

    // =========================================================================
    // Spell reticle
    // =========================================================================
    function drawSpellReticle(e){
      const spellCx = W * TUNE.spellXFrac;
      const spellCy = H * TUNE.spellYFrac;
      const R = TUNE.spellRadius;

      const retAlpha = TUNE.spellReticleBaseAlpha + TUNE.spellReticleGainAlpha * e;

      ctx.save();
      ctx.globalAlpha = retAlpha;
      ctx.strokeStyle = "rgba(50,255,117,1)";
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(spellCx, spellCy, R, 0, Math.PI*2); ctx.stroke();

      ctx.globalAlpha = ret_toggleAlpha = retAlpha * 0.65;
      ctx.beginPath(); ctx.arc(spellCx, spellCy, R * 0.72, 0, Math.PI*2); ctx.stroke();

      ctx.globalAlpha = retAlpha * 0.85;
      ctx.beginPath();
      ctx.moveTo(spellCx - (R + 14), spellCy); ctx.lineTo(spellCx - (R + 6), spellCy);
      ctx.moveTo(spellCx + (R + 14), spellCy); ctx.lineTo(spellCx + (R + 6), spellCy);
      ctx.moveTo(spellCx, spellCy - (R + 14)); ctx.lineTo(spellCx, spellCy - (R + 6));
      ctx.moveTo(spellCx, spellCy + (R + 14)); ctx.lineTo(spellCx, spellCy + (R + 6));
      ctx.stroke();
      ctx.restore();
    }

    // =========================================================================
    // Arming logic
    // =========================================================================
    let armed = false;
    let armedGlowAmt = 0;

    function updateArming(){
      if (!winningPlatform || won || gameOver) { armed = false; armedGlowAmt = 0; return; }
      if (winningPlatform.spelled) { armed = false; armedGlowAmt = 0; return; }

      const x0 = winningPlatform.x;
      const y0 = winningPlatform.y;
      const x1 = winningPlatform.x + winningPlatform.w;
      const y1 = winningPlatform.y + winningPlatform.h;

      const d = distPointAABB(ball.x, ball.y, x0, y0, x1, y1);

      if (d <= TUNE.proximityArmPx) {
        armed = true;
        armedGlowAmt = clamp(1 - (d / TUNE.proximityArmPx), 0, 1);
      } else {
        armed = false;
        armedGlowAmt = 0;
      }
    }

    // =========================================================================
    // Steering intents
    // =========================================================================
    function intentFromCastX(){
      const centerX = W * TUNE.steerCenterXFrac;
      let dxN = (castX - centerX) / (W * 0.5);
      dxN = clamp(dxN, -1, 1);

      const adx = Math.abs(dxN);
      let intent = 0;
      if (adx > TUNE.steerDeadzone) {
        intent = (adx - TUNE.steerDeadzone) / (1 - TUNE.steerDeadzone);
        intent = Math.pow(intent, TUNE.steerExpo) * (dxN < 0 ? -1 : 1);
      }
      return intent;
    }

    function intentFromScoreDiff(diff){
      let d = clamp(diff, -1, 1);
      const ad = Math.abs(d);
      let intent = 0;
      if (ad > TUNE.diffSteerDeadzone) {
        intent = (ad - TUNE.diffSteerDeadzone) / (1 - TUNE.diffSteerDeadzone);
        intent = Math.pow(intent, TUNE.diffSteerExpo) * (d < 0 ? -1 : 1);
      }
      return intent;
    }

    // =========================================================================
    // Collision
    // =========================================================================
    function resolveSolidPlatformCollision(p){
      if (!ball.alive) return;

      const px0 = p.x, px1 = p.x + p.w;
      const py0 = p.y, py1 = p.y + p.h;

      const ex0 = px0 - ball.r;
      const ex1 = px1 + ball.r;
      const ey0 = py0 - ball.r;
      const ey1 = py1 + ball.r;

      if (!pointInAABB(ball.x, ball.y, ex0, ey0, ex1, ey1)) return;

      const prevX = ball.prevX, prevY = ball.prevY;

      // TOP landing
      if (prevY <= ey0 && ball.y > ey0 && ball.vy > 0) {
        ball.y = ey0;
        ball.vy = 0;

        if (p.isWinning && p.spelled) {
          won = true;
          showOverlay("win");
        }
        return;
      }

      // UNDERSIDE impact (teeth kill for non-winning)
      if (prevY >= ey1 && ball.y < ey1 && ball.vy < 0) {
        if (!p.isWinning) {
          ball.alive = false;
          gameOver = true;
          showOverlay("gameover");
          return;
        }
        ball.y = ey1;
        ball.vy = Math.abs(ball.vy) * TUNE.bounceUnderWin;
        return;
      }

      // LEFT
      if (prevX <= ex0 && ball.x > ex0 && ball.vx > 0) {
        ball.x = ex0;
        ball.vx = -Math.abs(ball.vx) * TUNE.bounceSide;
        return;
      }

      // RIGHT
      if (prevX >= ex1 && ball.x < ex1 && ball.vx < 0) {
        ball.x = ex1;
        ball.vx = Math.abs(ball.vx) * TUNE.bounceSide;
        return;
      }

      // Fallback push-out
      const dxL = (ball.x - ex0);
      const dxR = (ex1 - ball.x);
      const dyT = (ball.y - ey0);
      const dyB = (ey1 - ball.y);

      const minX = Math.min(dxL, dxR);
      const minY = Math.min(dyT, dyB);

      if (minX < minY) {
        if (dxL < dxR) {
          ball.x = ex0;
          if (ball.vx > 0) ball.vx = -Math.abs(ball.vx) * TUNE.bounceSide;
        } else {
          ball.x = ex1;
          if (ball.vx < 0) ball.vx = Math.abs(ball.vx) * TUNE.bounceSide;
        }
      } else {
        if (dyT < dyB) {
          ball.y = ey0;
          if (ball.vy > 0) ball.vy = 0;
          if (p.isWinning && p.spelled) {
            won = true;
            showOverlay("win");
          }
        } else {
          if (!p.isWinning && ball.vy < 0) {
            ball.alive = false;
            gameOver = true;
            showOverlay("gameover");
          } else {
            ball.y = ey1;
            if (ball.vy < 0) ball.vy = Math.abs(ball.vy) * TUNE.bounceUnderWin;
          }
        }
      }
    }

    // =========================================================================
    // Draw platforms with TRIANGLE-WAVE teeth underside (non-winning only)
    // =========================================================================
    function drawPlatformWithTeeth(p, sy, alpha, stroke, fill){
      ctx.save();
      ctx.globalAlpha = alpha;

      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2;
      ctx.strokeRect(p.x, sy, p.w, p.h);

      ctx.globalAlpha = alpha * 0.18;
      ctx.fillStyle = fill;
      ctx.fillRect(p.x, sy, p.w, p.h);

      if (!p.isWinning) {
        const bottom = sy + p.h;
        const toothH = TUNE.teethHeight;
        const step = Math.max(8, TUNE.teethStep);

        // bright red bottom edge
        ctx.globalAlpha = 0.85;
        ctx.strokeStyle = "rgba(255,43,43,1)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(p.x, bottom);
        ctx.lineTo(p.x + p.w, bottom);
        ctx.stroke();

        // sharp triangle zig-zag
        ctx.globalAlpha = 0.95;
        ctx.strokeStyle = "rgba(255,43,43,1)";
        ctx.lineWidth = 2;
        ctx.beginPath();

        let x = p.x;
        ctx.moveTo(x, bottom);

        let up = true;
        while (x < p.x + p.w - 0.001) {
          const nextX = Math.min(x + step * 0.5, p.x + p.w);
          const y = up ? (bottom + toothH) : bottom;
          ctx.lineTo(nextX, y);
          x = nextX;
          up = !up;
        }
        ctx.stroke();

        // faint fill under teeth
        ctx.globalAlpha = 0.18;
        ctx.fillStyle = "rgba(255,43,43,1)";
        ctx.beginPath();
        ctx.moveTo(p.x, bottom);

        x = p.x; up = true;
        while (x < p.x + p.w - 0.001) {
          const nextX = Math.min(x + step * 0.5, p.x + p.w);
          const y = up ? (bottom + toothH) : bottom;
          ctx.lineTo(nextX, y);
          x = nextX;
          up = !up;
        }
        ctx.lineTo(p.x + p.w, bottom);
        ctx.closePath();
        ctx.fill();
      }

      ctx.restore();
    }

    // =========================================================================
    // Update / render
    // =========================================================================
    let lastT = performance.now();

    function step(dt) {
      if (won || gameOver) return;

      const now = performance.now();
      const wL = handWeight(lastLeftSeenMs, now);
      const wR = handWeight(lastRightSeenMs, now);
      const wSum = wL + wR;

      const rawEnergy = (wSum > 1e-6) ? ((scoreL * wL + scoreR * wR) / wSum) : 0;

      const a = clamp(dt * 6.5, 0, 1);
      circleEnergy = lerp(circleEnergy, rawEnergy, a);

      const target = circleEnergy;
      if (target > liftCharge) liftCharge += (target - liftCharge) * clamp(dt * TUNE.chargeBuild, 0, 1);
      else liftCharge += (target - liftCharge) * clamp(dt * TUNE.chargeDecay, 0, 1);

      const steerGate = clamp(TUNE.steerCastGate + (1 - TUNE.steerCastGate) * circleEnergy, 0, 1);
      const twoHandBlend = clamp(Math.min(wL, wR), 0, 1);

      const intent1 = intentFromCastX();
      const intent2 = intentFromScoreDiff(scoreR - scoreL);
      const intent = lerp(intent1, intent2, twoHandBlend);

      const vxTarget = intent * TUNE.steerMaxSpeed * steerGate;

      ball.vx += (vxTarget - ball.vx) * clamp(dt * TUNE.steerVxResponse, 0, 1);
      ball.vx -= ball.vx * TUNE.xDrag * dt;
      ball.vx *= Math.pow(TUNE.damping, dt * 60);

      const gate = clamp((liftCharge - TUNE.liftGateLo) / (TUNE.liftGateHi - TUNE.liftGateLo), 0, 1);
      const lift = TUNE.liftMax * (gate * gate);

      ball.vy += (TUNE.gravity - lift) * dt;
      ball.vy -= ball.vy * TUNE.yDrag * dt;
      ball.vy *= Math.pow(TUNE.damping, dt * 60);
      ball.vy = clamp(ball.vy, -TUNE.maxRiseSpeed, TUNE.maxFallSpeed);

      ball.prevX = ball.x;
      ball.prevY = ball.y;

      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      if (ball.x < ball.r) { ball.x = ball.r; ball.vx *= -0.35; }
      if (ball.x > W - ball.r) { ball.x = W - ball.r; ball.vx *= -0.35; }

      if (ball.y > floorY - ball.r) { ball.y = floorY - ball.r; ball.vy = 0; }

      for (let i=0;i<platforms.length;i++){
        resolveSolidPlatformCollision(platforms[i]);
        if (won || gameOver) break;
      }

      camTargetY = clamp(ball.y - H * TUNE.camFollowYFrac, 0, WORLD_H - H);
      camY = lerp(camY, camTargetY, clamp(dt * TUNE.camSmoothing, 0, 1));

      updateArming();

      // HUD
      const ePct = Math.round(circleEnergy * 100);
      const lPct = Math.round(scoreL * 100);
      const rPct = Math.round(scoreR * 100);
      const cPct = Math.round(liftCharge * 100);

      const voiceStr =
        (window.SpeechRecognition || window.webkitSpeechRecognition)
          ? (voiceEnabled ? '<span class="ok">VOICE</span> <b>ON</b>' : '<span class="warn">VOICE</span> <b>OFF</b> (start screen)')
          : '<span class="bad">VOICE</span> <b>UNSUPPORTED</b>';

      const armStr = (winningPlatform && winningPlatform.spelled)
        ? '<span class="ok">ALTAR</span> <b>AWAKENED</b> (orange)'
        : (armed ? '<span class="ok">INCANTATION</span> <b>ARMED</b>' : '<span class="dim">INCANTATION</span> <b>DISARMED</b>');

      const heardNorm = normalizeSpeech(lastHeard);
      const heardStr = heardNorm
        ? '<span class="dim">HEARD</span> <b>' + heardNorm.slice(0,64) + (heardNorm.length>64?'…':'') + '</b>'
        : '<span class="dim">HEARD</span> <b>—</b>';

      const flash = (performance.now() - lastSpellMs) < 900;
      const handsStr =
        '<span class="dim">L</span> <b>' + lPct + '%</b> <span class="dim">R</span> <b>' + rPct + '%</b>' +
        ' <span class="dim">| blend</span> <b>' + twoHandBlend.toFixed(2) + '</b>';

      statusEl.innerHTML =
        voiceStr + ' <span class="dim">|</span> ' + armStr + (flash ? ' <span class="ok">✓</span>' : '') + '<br>' +
        handsStr + ' <span class="dim">| ENERGY</span> <b>' + ePct + '%</b>' +
        ' <span class="dim">| CHARGE</span> <b>' + cPct + '%</b><br>' +
        '<span class="dim">BALL</span> <b>' + Math.round(ball.x) + ', ' + Math.round(ball.y) + '</b>' +
        ' <span class="dim">| camY</span> <b>' + Math.round(camY) + '</b><br>' +
        heardStr;
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);

      drawStars();
      drawWorldPolyline(mountains, "rgba(50,255,117,0.55)", 2, 1);
      drawWorldLine(worldGroundY, "rgba(50,255,117,0.85)", 2, 1);

      if (TUNE.showSteerLine) {
        const cx = W * TUNE.steerCenterXFrac;
        ctx.save();
        ctx.globalAlpha = 0.16;
        ctx.strokeStyle = "rgba(50,255,117,1)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(cx, 0);
        ctx.lineTo(cx, H);
        ctx.stroke();
        ctx.restore();
      }

      for (let i=0;i<platforms.length;i++){
        const p = platforms[i];
        const sy = worldToScreenY(p.y);
        if (sy > H + 80 || sy < -120) continue;

        let fill = "rgba(50,255,117,1)";
        let stroke = "rgba(50,255,117,0.90)";
        let alpha = TUNE.platformAlphaBase;

        if (p.isWinning && !p.spelled) {
          alpha = TUNE.platformAlphaBase + TUNE.platformGlowReserve * armedGlowAmt;
          alpha = clamp(alpha, 0, 1);
        }

        if (p.isWinning && p.spelled) {
          fill = "rgba(255,140,0,1)";
          stroke = "rgba(255,180,80,1)";
          alpha = 1.0;
        }

        drawPlatformWithTeeth(p, sy, alpha, stroke, fill);

        if (p.isWinning && !p.spelled && armedGlowAmt > 0) {
          ctx.save();
          ctx.globalAlpha = clamp(0.25 * armedGlowAmt, 0, 0.25);
          ctx.strokeStyle = "rgba(50,255,117,1)";
          ctx.lineWidth = 6;
          ctx.strokeRect(p.x - 2, sy - 2, p.w + 4, p.h + 4);
          ctx.restore();
        }
      }

      drawSpellReticle(clamp(circleEnergy, 0, 1));

      const glow = clamp(liftCharge, 0, 1);
      const bx = ball.x;
      const by = worldToScreenY(ball.y);

      if (ball.alive) {
        ctx.save();
        ctx.globalAlpha = 0.22 * glow;
        ctx.strokeStyle = "rgba(50,255,117,1)";
        ctx.lineWidth = 8 + 14 * glow;
        ctx.beginPath();
        ctx.arc(bx, by, ball.r + 10, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();

        ctx.save();
        ctx.strokeStyle = "rgba(50,255,117,0.95)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(bx, by, ball.r, 0, Math.PI*2);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(bx - 9, by); ctx.lineTo(bx + 9, by);
        ctx.moveTo(bx, by - 9); ctx.lineTo(bx, by + 9);
        ctx.stroke();
        ctx.restore();
      }

      ctx.save();
      ctx.fillStyle = "rgba(50,255,117,0.75)";
      ctx.font = "600 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
      ctx.fillText("AVOID RED TEETH UNDERSIDES → REACH THE FINAL PLATFORM → SPEAK → LAND ON ORANGE", 18, H - 18);
      ctx.restore();
    }

    function loop() {
      const now = performance.now();
      const dt = clamp((now - lastT) / 1000, 0, 0.033);
      lastT = now;

      if (!won && !gameOver && handLandmarker && video.readyState >= 2) {
        if (video.currentTime !== lastVideoTime) {
          const res = handLandmarker.detectForVideo(video, now);
          applyHandControls(res);
          lastVideoTime = video.currentTime;
        }
      }

      step(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // =========================================================================
    // Boot
    // =========================================================================
    (async function main(){
      try {
        await setupWebcam();
        await initLandmarker();
        requestAnimationFrame(loop);
      } catch (err) {
        console.error(err);
        statusEl.innerHTML =
          '<span class="bad">Failed to init webcam/model.</span><br>' +
          '<span class="dim">' + String(err) + '</span>';
      }
    })();
  </script>
</body>
</html>
