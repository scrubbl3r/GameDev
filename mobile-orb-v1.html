<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Groove Orbit</title>
  <style>
    :root { --green:#7dd35f; }

    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      color: var(--green);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    .app {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 18px 14px 20px;
      box-sizing: border-box;
      text-align: center;
      gap: 14px;
    }

    .bigCharge {
      font-weight: 900;
      font-size: clamp(72px, 18vw, 180px);
      letter-spacing: -0.05em;
      color: var(--green);
      line-height: 0.95;
      text-shadow: 0 0 18px rgba(125,211,95,0.16);
      margin-top: 4px;
    }
    .bigSub {
      margin-top: -6px;
      font-size: 14px;
      opacity: 0.78;
    }

    button {
      font-size: 18px;
      padding: 12px 16px;
      background: transparent;
      border: 1px solid var(--green);
      color: var(--green);
      border-radius: 10px;
    }

    .statusRow {
      font-size: 14px;
      opacity: 0.92;
      margin-top: -4px;
      display: flex;
      gap: 10px;
      align-items: baseline;
      justify-content: center;
      flex-wrap: wrap;
    }

    .pill {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      padding: 4px 10px;
      border: 1px solid rgba(125,211,95,0.45);
      border-radius: 999px;
      background: rgba(125,211,95,0.06);
      font-size: 13px;
      opacity: 0.95;
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: rgba(125,211,95,0.20);
      box-shadow: 0 0 10px rgba(125,211,95,0.0);
    }
    .dot.on {
      background: var(--green);
      box-shadow: 0 0 14px rgba(125,211,95,0.35);
    }

    .panel {
      width: min(560px, 92vw);
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 6px;
    }

    .metric {
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: center;
    }
    .label {
      font-size: 16px;
      display: flex;
      gap: 10px;
      align-items: baseline;
      justify-content: center;
      flex-wrap: wrap;
    }
    .label .muted {
      opacity: 0.72;
      font-size: 13px;
    }

    .bar {
      height: 18px;
      width: 100%;
      border: 1px solid rgba(125,211,95,0.60);
      border-radius: 10px;
      overflow: hidden;
      background: rgba(125,211,95,0.08);
      box-sizing: border-box;
    }
    .fill {
      height: 100%;
      width: 0%;
      background: var(--green);
      transition: width 80ms linear;
    }

    .small {
      width: min(560px, 92vw);
      opacity: 0.75;
      font-size: 13px;
      margin-top: 2px;
      line-height: 1.35;
    }
    code {
      background: rgba(125,211,95,0.08);
      border: 1px solid rgba(125,211,95,0.35);
      padding: 2px 6px;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <main class="app">
    <div>
      <div id="bigCharge" class="bigCharge">0%</div>
      <div class="bigSub">energy</div>
    </div>

    <button id="startBtn">Start</button>

    <div class="statusRow">
      <span>Status: <span id="status">idle</span></span>
      <span class="pill"><span id="lockDot" class="dot"></span> GROOVE LOCK</span>
      <span class="pill">Hz: <span id="hz">—</span></span>
      <span class="pill">Mode: <span id="mode">idle</span></span>
    </div>

    <section class="panel">
      <div class="metric">
        <div class="label">
          Groove <span id="groove">0</span>
          <span class="muted">(periodicity / lock strength)</span>
        </div>
        <div class="bar"><div id="grooveBar" class="fill"></div></div>
      </div>

      <div class="metric">
        <div class="label">
          Orbit <span id="orbit">0</span>
          <span class="muted">(multi-axis bonus)</span>
        </div>
        <div class="bar"><div id="orbitBar" class="fill"></div></div>
      </div>

      <div class="metric">
        <div class="label">
          Smooth <span id="smooth">0</span>
          <span class="muted">(low jerk)</span>
        </div>
        <div class="bar"><div id="smoothBar" class="fill"></div></div>
      </div>

      <div class="metric">
        <div class="label">
          Speed <span id="speed">0</span>
          <span class="muted">(soft-saturated)</span>
        </div>
        <div class="bar"><div id="speedBar" class="fill"></div></div>
      </div>

      <div class="metric">
        <div class="label">Energy <span id="energy">0</span></div>
        <div class="bar"><div id="energyBar" class="fill"></div></div>
      </div>
    </section>

    <div class="small">
      Requires <code>https</code> + motion permission + audio started from the button (iOS).
    </div>
  </main>

<script>
(() => {
  // ===========================================================================
  // UI
  // ===========================================================================
  const startBtn = document.getElementById('startBtn');
  const statusEl = document.getElementById('status');
  const bigChargeEl = document.getElementById('bigCharge');

  const lockDot = document.getElementById('lockDot');
  const hzEl = document.getElementById('hz');
  const modeEl = document.getElementById('mode');

  const grooveEl = document.getElementById('groove');
  const orbitEl  = document.getElementById('orbit');
  const smoothEl = document.getElementById('smooth');
  const speedEl  = document.getElementById('speed');
  const energyEl = document.getElementById('energy');

  const grooveBar = document.getElementById('grooveBar');
  const orbitBar  = document.getElementById('orbitBar');
  const smoothBar = document.getElementById('smoothBar');
  const speedBar  = document.getElementById('speedBar');
  const energyBar = document.getElementById('energyBar');

  // ===========================================================================
  // DIAL PACK v3 — "ENERGY SHOULD RISE" + HAND WALKING (REPLACE THIS WHOLE SECTION)
  // ---------------------------------------------------------------------------
  // Fixes:
  //  - Energy no longer stuck at 0 when groove~0.30, speed~0.50, smooth~0.55.
  //  - Easier lock acquisition (real-world autocorr peaks are lower than v2).
  //  - Softer decay while you're "pretty groovy" but not fully locked yet.
  // ===========================================================================

  // Input smoothing
  const OMEGA_LPF = 0.22;

  // Two-window strategy
  const HUNT_WINDOW_SEC   = 1.35;
  const STABLE_WINDOW_SEC = 3.10;

  const MIN_WINDOW_SAMPLES = 55;
  const MAX_WINDOW_SAMPLES = 260;

  // Ignore tiny motion noise
  const MIN_OMEGA = 0.08;

  // SPEED
  const SPEED_NORM  = 140.0;
  const SPEED_SHAPE = 0.85;

  // Groove lock hysteresis (LOWERED so groove≈30 can lock)
  const LOCK_ON  = 0.30;     // was 0.48
  const LOCK_OFF = 0.22;     // was 0.34

  // Autocorrelation tempo bounds
  const MIN_HZ = 0.55;
  const MAX_HZ = 2.30;

  // Smoothness
  const JERK_TIGHT = 220.0;
  const JERK_LOOSE = 2600.0;

  // Orbit preference
  const ORBIT_FLOOR      = 0.75;
  const ORBIT_STRICTNESS = 1.0;

  // Energy dynamics (less "tax", more "feel alive")
  const ENERGY_GAIN_LOCKED = 1.25;
  const ENERGY_GAIN_FREE   = 0.65;   // was 0.30 (lets energy climb pre-lock)
  const ENERGY_DECAY       = 0.045;  // was 0.085

  // If you have *some* grooveQuality, decay is softened instead of annihilating you
  const COAST_QUALITY_MIN = 0.28;    // below = normal decay, above = coasting
  const COAST_DECAY_MULT  = 0.55;    // decay *= this during coasting

  // UI smoothing
  const UI_SMOOTH   = 0.10;
  const LOCK_SMOOTH = 0.14;

  // Hand-walking
  const GRACE_SEC = 0.75;
  const GRACE_SPEED_MIN = 0.12;

  const RECENTER_SEC = 0.85;
  const RECENTER_SPEED_MIN = 0.18;
  const RECENTER_GROOVE_MAX = 0.22;

  // Signal normalization
  const NORM_ALPHA = 0.10;

  // Audio
  const AUDIO_GATE   = 0.06;
  const AUDIO_MIN_DB = -50;
  const AUDIO_MAX_DB = -6;
  const AUDIO_EXP    = 1.8;

  const TONE_BASE_HZ    = 180;
  const TONE_MAX_ADD_HZ = 220;

  // ===========================================================================
  // Helpers
  // ===========================================================================
  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const lerp = (a,b,t) => a + (b-a)*t;
  const mag3 = (x,y,z) => Math.sqrt(x*x+y*y+z*z);
  const dbToGain = (db) => Math.pow(10, db/20);

  function speedCurve(norm01) {
    const x = Math.max(0, norm01);
    return clamp01(1 - Math.exp(-SPEED_SHAPE * x));
  }

  function energyToGain(e) {
    if (e <= AUDIO_GATE) return 0;
    const x = (e - AUDIO_GATE) / (1 - AUDIO_GATE);
    const shaped = Math.pow(clamp01(x), AUDIO_EXP);
    const db = AUDIO_MIN_DB + (AUDIO_MAX_DB - AUDIO_MIN_DB) * shaped;
    return dbToGain(db);
  }

  function eigenvaluesSym3(m00,m01,m02,m11,m12,m22) {
    let a00=m00, a01=m01, a02=m02, a11=m11, a12=m12, a22=m22;

    const iters = 10;
    for (let k=0;k<iters;k++) {
      let p=0,q=1;
      let apq = Math.abs(a01);
      const a02abs = Math.abs(a02);
      const a12abs = Math.abs(a12);
      if (a02abs > apq) { apq = a02abs; p=0; q=2; }
      if (a12abs > apq) { apq = a12abs; p=1; q=2; }
      if (apq < 1e-12) break;

      let app, aqq, apqv;
      if (p===0 && q===1) { app=a00; aqq=a11; apqv=a01; }
      else if (p===0 && q===2) { app=a00; aqq=a22; apqv=a02; }
      else { app=a11; aqq=a22; apqv=a12; }

      const phi = 0.5 * Math.atan2(2*apqv, (aqq - app));
      const c = Math.cos(phi);
      const s = Math.sin(phi);

      function rot(xp, xq) { return [c*xp - s*xq, s*xp + c*xq]; }

      const appNew = c*c*app - 2*s*c*apqv + s*s*aqq;
      const aqqNew = s*s*app + 2*s*c*apqv + c*c*aqq;

      if (p===0 && q===1) {
        const [a02n, a12n] = rot(a02, a12);
        a02=a02n; a12=a12n;
        a00=appNew; a11=aqqNew; a01=0;
      } else if (p===0 && q===2) {
        const [a01n, a12n] = rot(a01, a12);
        a01=a01n; a12=a12n;
        a00=appNew; a22=aqqNew; a02=0;
      } else {
        const [a01n, a02n] = rot(a01, a02);
        a01=a01n; a02=a02n;
        a11=appNew; a22=aqqNew; a12=0;
      }
    }

    let l1=a00, l2=a11, l3=a22;
    if (l1 < l2) [l1,l2]=[l2,l1];
    if (l2 < l3) [l2,l3]=[l3,l2];
    if (l1 < l2) [l1,l2]=[l2,l1];
    return [l1,l2,l3];
  }

  function autocorrPeak(signal, dt) {
    const n = signal.length;
    if (n < 24) return {peak: 0, lag: 0, hz: 0};

    let mean=0;
    for (let i=0;i<n;i++) mean += signal[i];
    mean /= n;

    let varr=0;
    for (let i=0;i<n;i++) {
      const d = signal[i]-mean;
      varr += d*d;
    }
    if (varr < 1e-9) return {peak: 0, lag: 0, hz: 0};

    const minLag = Math.max(2, Math.floor(1/(MAX_HZ*dt)));
    const maxLag = Math.min(n-3, Math.floor(1/(MIN_HZ*dt)));

    let best = -1;
    let bestLag = 0;

    for (let lag=minLag; lag<=maxLag; lag++) {
      let c=0;
      for (let i=0;i<n-lag;i++) {
        c += (signal[i]-mean) * (signal[i+lag]-mean);
      }
      const r = c / varr;
      if (r > best) { best = r; bestLag = lag; }
    }

    const hz = bestLag > 0 ? (1/(bestLag*dt)) : 0;
    return {peak: clamp01(best), lag: bestLag, hz};
  }

  function smoothnessFromJerk(avgJerk) {
    const t = (JERK_LOOSE - avgJerk) / (JERK_LOOSE - JERK_TIGHT);
    return clamp01(t);
  }

  function cov3(vecs) {
    const n = vecs.length;
    if (n < 10) return {xx:0,xy:0,xz:0,yy:0,yz:0,zz:0, trace:0};

    let mx=0,my=0,mz=0;
    for (const v of vecs) { mx+=v.x; my+=v.y; mz+=v.z; }
    mx/=n; my/=n; mz/=n;

    let xx=0,xy=0,xz=0,yy=0,yz=0,zz=0;
    for (const v of vecs) {
      const x=v.x-mx, y=v.y-my, z=v.z-mz;
      xx += x*x; xy += x*y; xz += x*z;
      yy += y*y; yz += y*z; zz += z*z;
    }
    const inv = 1/(n-1);
    xx*=inv; xy*=inv; xz*=inv; yy*=inv; yz*=inv; zz*=inv;
    return {xx,xy,xz,yy,yz,zz, trace:(xx+yy+zz)};
  }

  function orbitBonusFromDirCov(cov) {
    const eps = 1e-9;
    if (cov.trace < 1e-6) return ORBIT_FLOOR;
    const [l1,l2,l3] = eigenvaluesSym3(cov.xx,cov.xy,cov.xz,cov.yy,cov.yz,cov.zz);
    const iso = clamp01(1 - ((l1 - l3) / (l1 + eps)));
    const shaped = Math.pow(iso, ORBIT_STRICTNESS);
    return ORBIT_FLOOR + (1 - ORBIT_FLOOR) * shaped;
  }

  function computeAvg(arr) {
    if (!arr.length) return 0;
    let s=0;
    for (const x of arr) s+=x;
    return s/arr.length;
  }

  function trimToWindow(dtMean, targetSec, omegaMag, omegaNorm, omegaDir, jerkBuf, dtBuf) {
    let targetN = dtMean > 1e-4 ? Math.round(targetSec / dtMean) : MAX_WINDOW_SAMPLES;
    targetN = Math.max(MIN_WINDOW_SAMPLES, Math.min(MAX_WINDOW_SAMPLES, targetN));

    while (omegaMag.length  > targetN) omegaMag.shift();
    while (omegaNorm.length > targetN) omegaNorm.shift();
    while (omegaDir.length  > targetN) omegaDir.shift();
    while (jerkBuf.length   > targetN) jerkBuf.shift();
    while (dtBuf.length     > targetN) dtBuf.shift();

    return targetN;
  }

  // ===========================================================================
  // State
  // ===========================================================================
  let running = false;
  let lastT = null;

  let ox=0, oy=0, oz=0;

  const omegaMag  = [];
  const omegaNorm = [];
  const omegaDir  = [];
  const jerkBuf   = [];
  const dtBuf     = [];

  let emaMean = 0;
  let emaVar  = 1;

  let lock = false;
  let lockStrength = 0;
  let grooveHz = 0;

  let graceLeft = 0;
  let recenterBadTime = 0;

  let energy = 0;
  let energyUI = 0;

  let audioCtx = null, osc = null, gainNode = null;

  function ensureAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    gainNode = audioCtx.createGain();
    gainNode.gain.value = 0;

    osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = TONE_BASE_HZ;

    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    osc.start();
  }

  function setAudio(eUI, groove, locked) {
    if (!audioCtx || !gainNode || !osc) return;

    const gBase = energyToGain(eUI);
    const gGroove = locked ? (0.30 + 0.70*groove) : (0.08 + 0.22*groove);
    const g = gBase * gGroove;

    const f = TONE_BASE_HZ
            + TONE_MAX_ADD_HZ * (locked ? groove : 0.30*groove)
            + 60 * eUI;

    const now = audioCtx.currentTime;
    gainNode.gain.cancelScheduledValues(now);
    gainNode.gain.setTargetAtTime(g, now, 0.06);

    osc.frequency.cancelScheduledValues(now);
    osc.frequency.setTargetAtTime(f, now, 0.06);
  }

  function updateUI(vals) {
    const toPct = (x) => Math.round(clamp01(x)*100);

    const grooveP = toPct(vals.groove);
    const orbitP  = toPct(vals.orbit);
    const smoothP = toPct(vals.smooth);
    const speedP  = toPct(vals.speed);
    const energyP = toPct(vals.energy);

    grooveEl.textContent = grooveP;
    orbitEl.textContent  = orbitP;
    smoothEl.textContent = smoothP;
    speedEl.textContent  = speedP;
    energyEl.textContent = energyP;

    grooveBar.style.width = `${grooveP}%`;
    orbitBar.style.width  = `${orbitP}%`;
    smoothBar.style.width = `${smoothP}%`;
    speedBar.style.width  = `${speedP}%`;
    energyBar.style.width = `${energyP}%`;

    bigChargeEl.textContent = `${energyP}%`;

    lockDot.classList.toggle('on', vals.locked);
    hzEl.textContent = vals.hz > 0 ? vals.hz.toFixed(2) : '—';
    modeEl.textContent = vals.mode;
  }

  function flushHistorySoft() {
    const keep = Math.min(18, omegaMag.length);
    omegaMag.splice(0, Math.max(0, omegaMag.length - keep));
    omegaNorm.splice(0, Math.max(0, omegaNorm.length - keep));
    omegaDir.splice(0, Math.max(0, omegaDir.length - keep));
    jerkBuf.splice(0, Math.max(0, jerkBuf.length - keep));
    dtBuf.splice(0, Math.max(0, dtBuf.length - keep));
  }

  function onMotion(e) {
    if (!running) return;

    const t = performance.now() / 1000;
    const dt = (lastT == null) ? 0 : (t - lastT);
    lastT = t;

    if (dt > 0) dtBuf.push(dt);

    const rr = e.rotationRate;
    if (!rr) return;

    const x = rr.beta ?? 0;
    const y = rr.gamma ?? 0;
    const z = rr.alpha ?? 0;

    const prevOx=ox, prevOy=oy, prevOz=oz;

    ox = lerp(ox, x, OMEGA_LPF);
    oy = lerp(oy, y, OMEGA_LPF);
    oz = lerp(oz, z, OMEGA_LPF);

    const m = mag3(ox,oy,oz);
    const dtMean = Math.max(1e-3, computeAvg(dtBuf.slice(-50)));

    const speedScore = speedCurve(m / SPEED_NORM);

    if (dt > 0) graceLeft = Math.max(0, graceLeft - dt);

    if (m > MIN_OMEGA) {
      omegaMag.push(m);

      const d = m - emaMean;
      emaMean = emaMean + NORM_ALPHA * d;

      const d2 = (m - emaMean);
      emaVar = emaVar + NORM_ALPHA * (d2*d2 - emaVar);

      const rms = Math.sqrt(Math.max(1e-6, emaVar));
      omegaNorm.push((m - emaMean) / rms);

      const inv = 1/m;
      omegaDir.push({x:ox*inv, y:oy*inv, z:oz*inv});

      if (dt > 0) {
        jerkBuf.push(mag3(ox-prevOx, oy-prevOy, oz-prevOz) / dt);
      }
    } else {
      if (omegaMag.length) omegaMag.shift();
      if (omegaNorm.length) omegaNorm.shift();
      if (omegaDir.length) omegaDir.shift();
      if (jerkBuf.length)  jerkBuf.shift();
    }

    const inStableMode = lock || graceLeft > 0;
    const windowSec = inStableMode ? STABLE_WINDOW_SEC : HUNT_WINDOW_SEC;
    const nTarget = trimToWindow(dtMean, windowSec, omegaMag, omegaNorm, omegaDir, jerkBuf, dtBuf);

    if (omegaNorm.length < Math.min(MIN_WINDOW_SAMPLES, nTarget)) {
      if (dt > 0) {
        energy = clamp01(energy - ENERGY_DECAY * 0.6 * dt);
        energyUI = lerp(energyUI, energy, UI_SMOOTH);
      }
      updateUI({ groove:0, orbit:0, smooth:0, speed:speedScore, energy:energyUI, locked:false, hz:0, mode:'idle' });
      setAudio(energyUI, 0, false);
      return;
    }

    const ac = autocorrPeak(omegaNorm, dtMean);
    lockStrength = lerp(lockStrength, ac.peak, LOCK_SMOOTH);
    grooveHz = ac.hz;

    const avgJerk = computeAvg(jerkBuf.slice(-Math.min(jerkBuf.length, 70)));
    const smoothScore = smoothnessFromJerk(avgJerk);

    const dirCov = cov3(omegaDir);
    const orbitBonus = orbitBonusFromDirCov(dirCov);
    const orbitShown = (orbitBonus - ORBIT_FLOOR) / (1 - ORBIT_FLOOR);

    // Lock state machine
    let mode = 'hunt';

    if (!lock) {
      if (lockStrength > LOCK_ON && speedScore > 0.16) {
        lock = true;
        graceLeft = 0;
        mode = 'locked';
      } else {
        mode = 'hunt';
      }
    } else {
      mode = 'locked';
      const shouldDrop = (lockStrength < LOCK_OFF) || (speedScore < 0.08);
      if (shouldDrop) {
        lock = false;
        graceLeft = GRACE_SEC;
        mode = 'grace';
      }
    }

    const inGrace = (!lock && graceLeft > 0);
    if (inGrace) {
      mode = 'grace';
      if (lockStrength > LOCK_ON && speedScore > GRACE_SPEED_MIN) {
        lock = true;
        graceLeft = 0;
        mode = 'locked';
      }
    }

    // Recenter when moving-but-not-grooving (regime change / hand-walk)
    if (dt > 0) {
      const moving = speedScore >= RECENTER_SPEED_MIN;
      const badGroove = lockStrength <= RECENTER_GROOVE_MAX;
      const notLockedNow = !lock;

      if (moving && badGroove && notLockedNow) recenterBadTime += dt;
      else recenterBadTime = Math.max(0, recenterBadTime - 1.5*dt);

      if (recenterBadTime >= RECENTER_SEC) {
        flushHistorySoft();
        recenterBadTime = 0;
      }
    }

    // Groove quality
    const grooveQuality = clamp01(
      0.62 * lockStrength +
      0.30 * smoothScore +
      0.08 * orbitShown
    );

    // Energy
    if (dt > 0) {
      const earnBase = speedScore * grooveQuality * orbitBonus;
      const effectivelyLocked = lock || inGrace;

      const gain = effectivelyLocked ? ENERGY_GAIN_LOCKED : ENERGY_GAIN_FREE;
      const earn = gain * earnBase;

      // Decay shaping: coast if you're already somewhat groovy
      let decay = ENERGY_DECAY;
      if (inGrace) decay *= 0.45;
      if (speedScore < 0.06) decay *= 1.35;
      if (grooveQuality >= COAST_QUALITY_MIN) decay *= COAST_DECAY_MULT;

      energy = clamp01(energy + (earn - decay) * dt);
      energyUI = lerp(energyUI, energy, UI_SMOOTH);
    }

    updateUI({
      groove: lockStrength,
      orbit: orbitShown,
      smooth: smoothScore,
      speed: speedScore,
      energy: energyUI,
      locked: (lock || inGrace),
      hz: grooveHz,
      mode
    });

    setAudio(energyUI, lockStrength, (lock || inGrace));
  }

  async function requestMotionPermissionIfNeeded() {
    const needs = (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function')
               || (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function');
    if (!needs) return true;

    const reqs = [];
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
      reqs.push(DeviceMotionEvent.requestPermission().then(s => s === 'granted'));
    }
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      reqs.push(DeviceOrientationEvent.requestPermission().then(s => s === 'granted'));
    }
    const results = await Promise.all(reqs);
    return results.every(Boolean);
  }

  async function start() {
    statusEl.textContent = 'requesting permission…';

    if (!window.isSecureContext) {
      statusEl.textContent = 'needs https';
      return;
    }

    const ok = await requestMotionPermissionIfNeeded();
    if (!ok) {
      statusEl.textContent = 'permission denied';
      return;
    }

    ensureAudio();
    try { await audioCtx.resume(); } catch(_) {}

    running = true;
    lastT = null;

    ox=oy=oz=0;

    omegaMag.length  = 0;
    omegaNorm.length = 0;
    omegaDir.length  = 0;
    jerkBuf.length   = 0;
    dtBuf.length     = 0;

    emaMean = 0;
    emaVar  = 1;

    lock = false;
    lockStrength = 0;
    grooveHz = 0;

    graceLeft = 0;
    recenterBadTime = 0;

    energy = 0;
    energyUI = 0;

    setAudio(0,0,false);

    window.addEventListener('devicemotion', onMotion, { passive: true });
    statusEl.textContent = 'running';
    startBtn.textContent = 'Stop';
    modeEl.textContent = 'hunt';
  }

  function stop() {
    running = false;
    window.removeEventListener('devicemotion', onMotion);

    if (audioCtx && gainNode) {
      const now = audioCtx.currentTime;
      gainNode.gain.cancelScheduledValues(now);
      gainNode.gain.setTargetAtTime(0, now, 0.05);
    }

    statusEl.textContent = 'stopped';
    startBtn.textContent = 'Start';
    lockDot.classList.remove('on');
    modeEl.textContent = 'idle';
  }

  startBtn.addEventListener('click', () => {
    if (!running) start();
    else stop();
  });
})();
</script>
</body>
</html>
