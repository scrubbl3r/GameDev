<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Groove Orbit</title>
  <style>
    :root { --green:#7dd35f; }

    html, body {
      height: 100%;
      margin: 0;
      background: #000; /* overridden dynamically */
      color: var(--green);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      transition: background-color 80ms linear;
    }

    .app {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 18px 14px 22px;
      box-sizing: border-box;
      text-align: center;
      gap: 14px;
    }

    .bigCharge {
      font-weight: 900;
      font-size: clamp(72px, 18vw, 180px);
      letter-spacing: -0.05em;
      color: var(--green);
      line-height: 0.95;
      text-shadow: 0 0 18px rgba(125,211,95,0.16);
      margin-top: 4px;
    }
    .bigSub {
      margin-top: -6px;
      font-size: 14px;
      opacity: 0.78;
    }

    .panel {
      width: min(560px, 92vw);
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 6px;
    }

    .metric {
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: center;
    }
    .label {
      font-size: 16px;
      display: flex;
      gap: 10px;
      align-items: baseline;
      justify-content: center;
      flex-wrap: wrap;
    }
    .label .muted {
      opacity: 0.72;
      font-size: 13px;
    }

    .bar {
      height: 18px;
      width: 100%;
      border: 1px solid rgba(125,211,95,0.60);
      border-radius: 10px;
      overflow: hidden;
      background: rgba(125,211,95,0.08);
      box-sizing: border-box;
    }
    .fill {
      height: 100%;
      width: 0%;
      background: var(--green);
      transition: width 80ms linear;
    }

    .small {
      width: min(560px, 92vw);
      opacity: 0.75;
      font-size: 13px;
      line-height: 1.35;
      margin-top: 2px;
    }
    code {
      background: rgba(125,211,95,0.08);
      border: 1px solid rgba(125,211,95,0.35);
      padding: 2px 6px;
      border-radius: 6px;
    }

    button {
      font-size: 18px;
      padding: 12px 16px;
      background: transparent;
      border: 1px solid var(--green);
      color: var(--green);
      border-radius: 10px;
      width: min(560px, 92vw);
    }
  </style>
</head>
<body>
  <main class="app">
    <div>
      <div id="bigCharge" class="bigCharge">0%</div>
      <div class="bigSub">energy</div>
    </div>

    <section class="panel">
      <div class="metric">
        <div class="label">
          Groove <span id="groove">0</span>
          <span class="muted">(periodicity / lock strength)</span>
        </div>
        <div class="bar"><div id="grooveBar" class="fill"></div></div>
      </div>

      <div class="metric">
        <div class="label">
          Orbit <span id="orbit">0</span>
          <span class="muted">(multi-axis bonus)</span>
        </div>
        <div class="bar"><div id="orbitBar" class="fill"></div></div>
      </div>

      <div class="metric">
        <div class="label">
          Smooth <span id="smooth">0</span>
          <span class="muted">(low jerk)</span>
        </div>
        <div class="bar"><div id="smoothBar" class="fill"></div></div>
      </div>

      <div class="metric">
        <div class="label">
          Speed <span id="speed">0</span>
          <span class="muted">(soft-saturated)</span>
        </div>
        <div class="bar"><div id="speedBar" class="fill"></div></div>
      </div>

      <div class="metric">
        <div class="label">Energy <span id="energy">0</span></div>
        <div class="bar"><div id="energyBar" class="fill"></div></div>
      </div>

      <br>
      <button id="startBtn">Start</button>

      <div class="small">
        Requires <code>https</code> + motion permission + audio started from the button (iOS).<br>
        Relay: pass <code>?room=orb:XXXX</code> in the URL to pair with the game.
      </div>
    </section>
  </main>

  <!-- Ably JS -->
  <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>

<script>
(() => {
  // ===========================================================================
  // UI
  // ===========================================================================
  const startBtn = document.getElementById('startBtn');
  const bigChargeEl = document.getElementById('bigCharge');

  const grooveEl = document.getElementById('groove');
  const orbitEl  = document.getElementById('orbit');
  const smoothEl = document.getElementById('smooth');
  const speedEl  = document.getElementById('speed');
  const energyEl = document.getElementById('energy');

  const grooveBar = document.getElementById('grooveBar');
  const orbitBar  = document.getElementById('orbitBar');
  const smoothBar = document.getElementById('smoothBar');
  const speedBar  = document.getElementById('speedBar');
  const energyBar = document.getElementById('energyBar');

  // Background: linear from black (0) to bright red-orange (1)
  const BG0 = { r: 0,   g: 0,  b: 0  };
  const BG1 = { r: 255, g: 42, b: 0  };
  function setBgFromEnergy(e01) {
    const t = Math.max(0, Math.min(1, e01));
    const r = Math.round(BG0.r + (BG1.r - BG0.r) * t);
    const g = Math.round(BG0.g + (BG1.g - BG0.g) * t);
    const b = Math.round(BG0.b + (BG1.b - BG0.b) * t);
    document.body.style.backgroundColor = `rgb(${r},${g},${b})`;
  }
  setBgFromEnergy(0);

  // ===========================================================================
  // RELAY (Ably via Cloudflare Worker token) — DROP-IN SECTION
  // ---------------------------------------------------------------------------
  // Game generates a room like "orb:7H2K9P" and QR points to:
  //   mobile-orb-v1.html?room=orb:7H2K9P
  //
  // We connect with token auth (no API key in browser):
  //   https://orb-token.mrgarthwilliams.workers.dev/token?room=orb:7H2K9P&clientId=phone-ABCD
  // ===========================================================================
  const WORKER_BASE = "https://orb-token.mrgarthwilliams.workers.dev";
  const TOKEN_URL = WORKER_BASE + "/token";

  function getRoomFromUrl(){
    const u = new URL(window.location.href);
    return u.searchParams.get("room") || "orb:test";
  }

  let ably = null;
  let ablyChannel = null;
  let room = getRoomFromUrl();

  function connectRelay(){
    // Safe reconnect
    try { if (ablyChannel) ablyChannel.detach(); } catch(e) {}
    try { if (ably) ably.close(); } catch(e) {}
    ably = null; ablyChannel = null;

    ably = new Ably.Realtime({
      authUrl: TOKEN_URL + "?room=" + encodeURIComponent(room) + "&clientId=" + encodeURIComponent("phone-" + Math.random().toString(16).slice(2,6)),
      autoConnect: true
    });
    ablyChannel = ably.channels.get(room);
  }

  function disconnectRelay(){
    try { if (ablyChannel) ablyChannel.detach(); } catch(e) {}
    try { if (ably) ably.close(); } catch(e) {}
    ably = null; ablyChannel = null;
  }

  // Publish throttle (~25 Hz)
  const PUBLISH_HZ = 25;
  const PUBLISH_DT = 1 / PUBLISH_HZ;
  let publishAcc = 0;

  function publishOrb(payload, dt){
    if (!ablyChannel) return;
    publishAcc += dt;
    if (publishAcc < PUBLISH_DT) return;
    publishAcc = 0;

    // One message type: "orb"
    try {
      ablyChannel.publish("orb", payload);
    } catch (e) {
      // ignore transient publish errors
    }
  }

  // ===========================================================================
  // DIAL PACK v4 — "FASTER DECAY" (PRESERVED)
  // ===========================================================================
  const OMEGA_LPF = 0.22;

  const HUNT_WINDOW_SEC   = 1.35;
  const STABLE_WINDOW_SEC = 3.10;

  const MIN_WINDOW_SAMPLES = 55;
  const MAX_WINDOW_SAMPLES = 260;

  const MIN_OMEGA = 0.08;

  const SPEED_NORM  = 140.0;
  const SPEED_SHAPE = 0.85;

  const LOCK_ON  = 0.30;
  const LOCK_OFF = 0.22;

  const MIN_HZ = 0.55;
  const MAX_HZ = 2.30;

  const JERK_TIGHT = 220.0;
  const JERK_LOOSE = 2600.0;

  const ORBIT_FLOOR      = 0.75;
  const ORBIT_STRICTNESS = 1.0;

  // Sensitivity knobs for build-up:
  // - ENERGY_GAIN_LOCKED / ENERGY_GAIN_FREE (overall earning multiplier)
  // - grooveQuality weights (0.62/0.30/0.08)
  // - SPEED_NORM / SPEED_SHAPE (how quickly speedScore ramps)
  const ENERGY_GAIN_LOCKED = 1.25;
  const ENERGY_GAIN_FREE   = 0.65;

  const ENERGY_DECAY       = 0.090;
  const STOP_SPEED_THRESH  = 0.06;
  const STOP_DECAY_MULT    = 1.0;

  const COAST_QUALITY_MIN  = 0.28;
  const COAST_DECAY_MULT   = 0.65;

  const UI_SMOOTH   = 0.10;
  const LOCK_SMOOTH = 0.14;

  const GRACE_SEC = 0.75;
  const GRACE_SPEED_MIN = 0.12;

  const RECENTER_SEC = 0.85;
  const RECENTER_SPEED_MIN = 0.18;
  const RECENTER_GROOVE_MAX = 0.22;

  const NORM_ALPHA = 0.10;

  // ===========================================================================
  // AUDIO MAPPING — gentler curve, audible by ~10% energy
  // + MASTER GAIN (your ask)
  // ===========================================================================
  const AUDIO_GATE   = 0.02;
  const AUDIO_MIN_DB = -42;
  const AUDIO_MAX_DB = -6;
  const AUDIO_EXP    = 1.15;

  const MASTER_GAIN  = 2.2;  // <— overall loudness (try 1.5 .. 3.5)

  const TONE_BASE_HZ    = 180;
  const TONE_MAX_ADD_HZ = 220;

  // ===========================================================================
  // Helpers
  // ===========================================================================
  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const lerp = (a,b,t) => a + (b-a)*t;
  const mag3 = (x,y,z) => Math.sqrt(x*x+y*y+z*z);
  const dbToGain = (db) => Math.pow(10, db/20);

  function speedCurve(norm01) {
    const x = Math.max(0, norm01);
    return clamp01(1 - Math.exp(-SPEED_SHAPE * x));
  }

  function energyToGain(e) {
    if (e <= AUDIO_GATE) return 0;
    const x = (e - AUDIO_GATE) / (1 - AUDIO_GATE);
    const shaped = Math.pow(clamp01(x), AUDIO_EXP);
    const db = AUDIO_MIN_DB + (AUDIO_MAX_DB - AUDIO_MIN_DB) * shaped;
    return dbToGain(db);
  }

  function eigenvaluesSym3(m00,m01,m02,m11,m12,m22) {
    let a00=m00, a01=m01, a02=m02, a11=m11, a12=m12, a22=m22;

    const iters = 10;
    for (let k=0;k<iters;k++) {
      let p=0,q=1;
      let apq = Math.abs(a01);
      const a02abs = Math.abs(a02);
      const a12abs = Math.abs(a12);
      if (a02abs > apq) { apq = a02abs; p=0; q=2; }
      if (a12abs > apq) { apq = a12abs; p=1; q=2; }
      if (apq < 1e-12) break;

      let app, aqq, apqv;
      if (p===0 && q===1) { app=a00; aqq=a11; apqv=a01; }
      else if (p===0 && q===2) { app=a00; aqq=a22; apqv=a02; }
      else { app=a11; aqq=a22; apqv=a12; }

      const phi = 0.5 * Math.atan2(2*apqv, (aqq - app));
      const c = Math.cos(phi);
      const s = Math.sin(phi);

      function rot(xp, xq) { return [c*xp - s*xq, s*xp + c*xq]; }

      const appNew = c*c*app - 2*s*c*apqv + s*s*aqq;
      const aqqNew = s*s*app + 2*s*c*apqv + c*c*aqq;

      if (p===0 && q===1) {
        const [a02n, a12n] = rot(a02, a12);
        a02=a02n; a12=a12n;
        a00=appNew; a11=aqqNew; a01=0;
      } else if (p===0 && q===2) {
        const [a01n, a12n] = rot(a01, a12);
        a01=a01n; a12=a12n;
        a00=appNew; a22=aqqNew; a02=0;
      } else {
        const [a01n, a02n] = rot(a01, a02);
        a01=a01n; a02=a02n;
        a11=appNew; a22=aqqNew; a12=0;
      }
    }

    let l1=a00, l2=a11, l3=a22;
    if (l1 < l2) [l1,l2]=[l2,l1];
    if (l2 < l3) [l2,l3]=[l3,l2];
    if (l1 < l2) [l1,l2]=[l2,l1];
    return [l1,l2,l3];
  }

  function autocorrPeak(signal, dt) {
    const n = signal.length;
    if (n < 24) return {peak: 0, lag: 0, hz: 0};

    let mean=0;
    for (let i=0;i<n;i++) mean += signal[i];
    mean /= n;

    let varr=0;
    for (let i=0;i<n;i++) {
      const d = signal[i]-mean;
      varr += d*d;
    }
    if (varr < 1e-9) return {peak: 0, lag: 0, hz: 0};

    const minLag = Math.max(2, Math.floor(1/(MAX_HZ*dt)));
    const maxLag = Math.min(n-3, Math.floor(1/(MIN_HZ*dt)));

    let best = -1;
    let bestLag = 0;

    for (let lag=minLag; lag<=maxLag; lag++) {
      let c=0;
      for (let i=0;i<n-lag;i++) {
        c += (signal[i]-mean) * (signal[i+lag]-mean);
      }
      const r = c / varr;
      if (r > best) { best = r; bestLag = lag; }
    }

    const hz = bestLag > 0 ? (1/(bestLag*dt)) : 0;
    return {peak: clamp01(best), lag: bestLag, hz};
  }

  function smoothnessFromJerk(avgJerk) {
    const t = (JERK_LOOSE - avgJerk) / (JERK_LOOSE - JERK_TIGHT);
    return clamp01(t);
  }

  function cov3(vecs) {
    const n = vecs.length;
    if (n < 10) return {xx:0,xy:0,xz:0,yy:0,yz:0,zz:0, trace:0};

    let mx=0,my=0,mz=0;
    for (const v of vecs) { mx+=v.x; my+=v.y; mz+=v.z; }
    mx/=n; my/=n; mz/=n;

    let xx=0,xy=0,xz=0,yy=0,yz=0,zz=0;
    for (const v of vecs) {
      const x=v.x-mx, y=v.y-my, z=v.z-mz;
      xx += x*x; xy += x*y; xz += x*z;
      yy += y*y; yz += y*z; zz += z*z;
    }
    const inv = 1/(n-1);
    xx*=inv; xy*=inv; xz*=inv; yy*=inv; yz*=inv; zz*=inv;
    return {xx,xy,xz,yy,yz,zz, trace:(xx+yy+zz)};
  }

  function orbitBonusFromDirCov(cov) {
    const eps = 1e-9;
    if (cov.trace < 1e-6) return ORBIT_FLOOR;
    const [l1,l2,l3] = eigenvaluesSym3(cov.xx,cov.xy,cov.xz,cov.yy,cov.yz,cov.zz);
    const iso = clamp01(1 - ((l1 - l3) / (l1 + eps)));
    const shaped = Math.pow(iso, ORBIT_STRICTNESS);
    return ORBIT_FLOOR + (1 - ORBIT_FLOOR) * shaped;
  }

  function computeAvg(arr) {
    if (!arr.length) return 0;
    let s=0;
    for (const x of arr) s+=x;
    return s/arr.length;
  }

  function trimToWindow(dtMean, targetSec, omegaMag, omegaNorm, omegaDir, jerkBuf, dtBuf) {
    let targetN = dtMean > 1e-4 ? Math.round(targetSec / dtMean) : MAX_WINDOW_SAMPLES;
    targetN = Math.max(MIN_WINDOW_SAMPLES, Math.min(MAX_WINDOW_SAMPLES, targetN));

    while (omegaMag.length  > targetN) omegaMag.shift();
    while (omegaNorm.length > targetN) omegaNorm.shift();
    while (omegaDir.length  > targetN) omegaDir.shift();
    while (jerkBuf.length   > targetN) jerkBuf.shift();
    while (dtBuf.length     > targetN) dtBuf.shift();

    return targetN;
  }

  // ===========================================================================
  // State
  // ===========================================================================
  let running = false;
  let lastT = null;

  let ox=0, oy=0, oz=0;

  const omegaMag  = [];
  const omegaNorm = [];
  const omegaDir  = [];
  const jerkBuf   = [];
  const dtBuf     = [];

  let emaMean = 0;
  let emaVar  = 1;

  let lock = false;
  let lockStrength = 0;
  let grooveHz = 0;

  let graceLeft = 0;
  let recenterBadTime = 0;

  let energy = 0;
  let energyUI = 0;

  let audioCtx = null, osc = null, gainNode = null;

  function ensureAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    gainNode = audioCtx.createGain();
    gainNode.gain.value = 0;

    osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = TONE_BASE_HZ;

    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    osc.start();
  }

  function setAudio(eUI, groove, locked) {
    if (!audioCtx || !gainNode || !osc) return;

    const gBase = energyToGain(eUI);

    const gGroove = locked ? (0.30 + 0.70*groove) : (0.08 + 0.22*groove);

    // MASTER_GAIN applied here:
    const g = MASTER_GAIN * gBase * gGroove;

    const f = TONE_BASE_HZ
            + TONE_MAX_ADD_HZ * (locked ? groove : 0.30*groove)
            + 60 * eUI;

    const now = audioCtx.currentTime;
    gainNode.gain.cancelScheduledValues(now);
    gainNode.gain.setTargetAtTime(g, now, 0.06);

    osc.frequency.cancelScheduledValues(now);
    osc.frequency.setTargetAtTime(f, now, 0.06);
  }

  function updateUI(vals) {
    const toPct = (x) => Math.round(clamp01(x)*100);

    const grooveP = toPct(vals.groove);
    const orbitP  = toPct(vals.orbit);
    const smoothP = toPct(vals.smooth);
    const speedP  = toPct(vals.speed);
    const energyP = toPct(vals.energy);

    grooveEl.textContent = grooveP;
    orbitEl.textContent  = orbitP;
    smoothEl.textContent = smoothP;
    speedEl.textContent  = speedP;
    energyEl.textContent = energyP;

    grooveBar.style.width = `${grooveP}%`;
    orbitBar.style.width  = `${orbitP}%`;
    smoothBar.style.width = `${smoothP}%`;
    speedBar.style.width  = `${speedP}%`;
    energyBar.style.width = `${energyP}%`;

    bigChargeEl.textContent = `${energyP}%`;
    setBgFromEnergy(vals.energy);
  }

  function flushHistorySoft() {
    const keep = Math.min(18, omegaMag.length);
    omegaMag.splice(0, Math.max(0, omegaMag.length - keep));
    omegaNorm.splice(0, Math.max(0, omegaNorm.length - keep));
    omegaDir.splice(0, Math.max(0, omegaDir.length - keep));
    jerkBuf.splice(0, Math.max(0, jerkBuf.length - keep));
    dtBuf.splice(0, Math.max(0, dtBuf.length - keep));
  }

  function onMotion(e) {
    if (!running) return;

    const t = performance.now() / 1000;
    const dt = (lastT == null) ? 0 : (t - lastT);
    lastT = t;

    if (dt > 0) dtBuf.push(dt);

    const rr = e.rotationRate;
    if (!rr) return;

    const x = rr.beta ?? 0;
    const y = rr.gamma ?? 0;
    const z = rr.alpha ?? 0;

    const prevOx=ox, prevOy=oy, prevOz=oz;

    ox = lerp(ox, x, OMEGA_LPF);
    oy = lerp(oy, y, OMEGA_LPF);
    oz = lerp(oz, z, OMEGA_LPF);

    const m = mag3(ox,oy,oz);
    const dtMean = Math.max(1e-3, computeAvg(dtBuf.slice(-50)));

    const speedScore = speedCurve(m / SPEED_NORM);

    if (dt > 0) graceLeft = Math.max(0, graceLeft - dt);

    if (m > MIN_OMEGA) {
      omegaMag.push(m);

      const d = m - emaMean;
      emaMean = emaMean + NORM_ALPHA * d;

      const d2 = (m - emaMean);
      emaVar = emaVar + NORM_ALPHA * (d2*d2 - emaVar);

      const rms = Math.sqrt(Math.max(1e-6, emaVar));
      omegaNorm.push((m - emaMean) / rms);

      const inv = 1/m;
      omegaDir.push({x:ox*inv, y:oy*inv, z:oz*inv});

      if (dt > 0) jerkBuf.push(mag3(ox-prevOx, oy-prevOy, oz-prevOz) / dt);
    } else {
      if (omegaMag.length) omegaMag.shift();
      if (omegaNorm.length) omegaNorm.shift();
      if (omegaDir.length) omegaDir.shift();
      if (jerkBuf.length)  jerkBuf.shift();
    }

    const inStableMode = lock || graceLeft > 0;
    const windowSec = inStableMode ? STABLE_WINDOW_SEC : HUNT_WINDOW_SEC;
    const nTarget = trimToWindow(dtMean, windowSec, omegaMag, omegaNorm, omegaDir, jerkBuf, dtBuf);

    if (omegaNorm.length < Math.min(MIN_WINDOW_SAMPLES, nTarget)) {
      if (dt > 0) {
        const d = ENERGY_DECAY * STOP_DECAY_MULT;
        energy = clamp01(energy - d * dt);
        energyUI = lerp(energyUI, energy, UI_SMOOTH);
      }

      const lockedNow = false;
      const payload = {
        room,
        t: performance.now(),
        energy01: energyUI,
        groove01: 0,
        orbit01: 0,
        smooth01: 0,
        speed01: speedScore,
        locked: lockedNow,
        hz: 0
      };
      publishOrb(payload, dt);

      updateUI({ groove:0, orbit:0, smooth:0, speed:speedScore, energy:energyUI });
      setAudio(energyUI, 0, false);
      return;
    }

    const ac = autocorrPeak(omegaNorm, dtMean);
    lockStrength = lerp(lockStrength, ac.peak, LOCK_SMOOTH);
    grooveHz = ac.hz;

    const avgJerk = computeAvg(jerkBuf.slice(-Math.min(jerkBuf.length, 70)));
    const smoothScore = smoothnessFromJerk(avgJerk);

    const dirCov = cov3(omegaDir);
    const orbitBonus = orbitBonusFromDirCov(dirCov);
    const orbitShown = (orbitBonus - ORBIT_FLOOR) / (1 - ORBIT_FLOOR);

    if (!lock) {
      if (lockStrength > LOCK_ON && speedScore > 0.16) {
        lock = true;
        graceLeft = 0;
      }
    } else {
      const shouldDrop = (lockStrength < LOCK_OFF) || (speedScore < 0.08);
      if (shouldDrop) {
        lock = false;
        graceLeft = GRACE_SEC;
      }
    }

    const inGrace = (!lock && graceLeft > 0);
    if (inGrace) {
      if (lockStrength > LOCK_ON && speedScore > GRACE_SPEED_MIN) {
        lock = true;
        graceLeft = 0;
      }
    }

    if (dt > 0) {
      const moving = speedScore >= RECENTER_SPEED_MIN;
      const badGroove = lockStrength <= RECENTER_GROOVE_MAX;
      const notLockedNow = !lock;

      if (moving && badGroove && notLockedNow) recenterBadTime += dt;
      else recenterBadTime = Math.max(0, recenterBadTime - 1.5*dt);

      if (recenterBadTime >= RECENTER_SEC) {
        flushHistorySoft();
        recenterBadTime = 0;
      }
    }

    const grooveQuality = clamp01(
      0.62 * lockStrength +
      0.30 * smoothScore +
      0.08 * orbitShown
    );

    if (dt > 0) {
      const earnBase = speedScore * grooveQuality * orbitBonus;
      const effectivelyLocked = lock || inGrace;

      const gain = effectivelyLocked ? ENERGY_GAIN_LOCKED : ENERGY_GAIN_FREE;
      const earn = gain * earnBase;

      let decay = ENERGY_DECAY;
      if (speedScore < STOP_SPEED_THRESH) decay *= STOP_DECAY_MULT;
      if (inGrace) decay *= 0.70;
      if (speedScore >= STOP_SPEED_THRESH && grooveQuality >= COAST_QUALITY_MIN) {
        decay *= COAST_DECAY_MULT;
      }

      energy = clamp01(energy + (earn - decay) * dt);
      energyUI = lerp(energyUI, energy, UI_SMOOTH);
    }

    const lockedNow = !!(lock || inGrace);

    const payload = {
      room,
      t: performance.now(),
      energy01: energyUI,
      groove01: lockStrength,
      orbit01: orbitShown,
      smooth01: smoothScore,
      speed01: speedScore,
      locked: lockedNow,
      hz: grooveHz
    };
    if (dt > 0) publishOrb(payload, dt);

    updateUI({
      groove: lockStrength,
      orbit: orbitShown,
      smooth: smoothScore,
      speed: speedScore,
      energy: energyUI
    });

    setAudio(energyUI, lockStrength, lockedNow);
  }

  async function requestMotionPermissionIfNeeded() {
    const needs = (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function')
               || (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function');
    if (!needs) return true;

    const reqs = [];
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
      reqs.push(DeviceMotionEvent.requestPermission().then(s => s === 'granted'));
    }
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      reqs.push(DeviceOrientationEvent.requestPermission().then(s => s === 'granted'));
    }
    const results = await Promise.all(reqs);
    return results.every(Boolean);
  }

  async function start() {
    if (!window.isSecureContext) return;

    // Connect relay on start (so you only pair when running)
    connectRelay();
    publishAcc = 0;

    const ok = await requestMotionPermissionIfNeeded();
    if (!ok) return;

    ensureAudio();
    try { await audioCtx.resume(); } catch(_) {}

    running = true;
    lastT = null;

    ox=oy=oz=0;

    omegaMag.length  = 0;
    omegaNorm.length = 0;
    omegaDir.length  = 0;
    jerkBuf.length   = 0;
    dtBuf.length     = 0;

    emaMean = 0;
    emaVar  = 1;

    lock = false;
    lockStrength = 0;
    grooveHz = 0;

    graceLeft = 0;
    recenterBadTime = 0;

    energy = 0;
    energyUI = 0;

    setAudio(0,0,false);
    setBgFromEnergy(0);

    window.addEventListener('devicemotion', onMotion, { passive: true });
    startBtn.textContent = 'Stop';
  }

  function stop() {
    running = false;
    window.removeEventListener('devicemotion', onMotion);

    if (audioCtx && gainNode) {
      const now = audioCtx.currentTime;
      gainNode.gain.cancelScheduledValues(now);
      gainNode.gain.setTargetAtTime(0, now, 0.05);
    }

    disconnectRelay();

    startBtn.textContent = 'Start';
  }

  startBtn.addEventListener('click', () => {
    if (!running) start();
    else stop();
  });
})();
</script>
</body>
</html>
