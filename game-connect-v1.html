<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Orb Relay (Game) — Ably + Worker</title>
  <style>
    :root { --green:#7dd35f; --bg:#0b0b0b; }
    html,body { height:100%; margin:0; background:var(--bg); color:#ddd; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; }
    .wrap { max-width:980px; margin:0 auto; padding:18px; }
    h1 { margin:0 0 10px; font-size:20px; font-weight:800; letter-spacing:.2px; }
    .row { display:flex; gap:14px; flex-wrap:wrap; align-items:flex-start; }
    .card {
      flex: 1 1 360px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 14px;
    }
    .card h2 { margin:0 0 10px; font-size:14px; opacity:.9; }
    button {
      font-size:16px; padding:10px 14px; border-radius:12px;
      border: 1px solid rgba(125,211,95,0.65);
      background: transparent; color: var(--green); cursor:pointer;
    }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .mono { font:12px ui-monospace,SFMono-Regular,Menlo,monospace; opacity:.9; }
    .kv { display:grid; grid-template-columns: 140px 1fr; gap:8px 10px; margin-top:10px; }
    .kv div { padding:6px 0; border-bottom:1px solid rgba(255,255,255,0.06); }
    .pill {
      display:inline-block; padding:3px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.14); background:rgba(255,255,255,0.03);
      font-size:12px; opacity:.95;
    }
    #qr { width: 260px; height: 260px; display:flex; align-items:center; justify-content:center; background:#fff; border-radius:12px; overflow:hidden; }
    #qr img, #qr canvas { width: 100% !important; height: 100% !important; }
    .muted { opacity:.7; }
    .good { color: var(--green); }
    .warn { color: #ffd37a; }
    .bad  { color: #ff7a7a; }
    .big { font-size:42px; font-weight:900; letter-spacing:-0.03em; margin:0; }
    .sub { margin:0; opacity:.75; }
    a { color: var(--green); }
    code { background: rgba(125,211,95,0.08); border: 1px solid rgba(125,211,95,0.30); padding: 2px 6px; border-radius: 8px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Orb Relay (Game) — Ably via Worker Token</h1>

    <div class="row">
      <div class="card">
        <h2>Controls</h2>
        <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
          <button id="connectBtn">Connect + Generate QR</button>
          <button id="disconnectBtn" disabled>Disconnect</button>
          <span class="pill mono" id="statusPill">idle</span>
        </div>

        <div class="kv mono">
          <div class="muted">Worker</div><div id="workerOut"></div>
          <div class="muted">Room channel</div><div id="roomOut"></div>
          <div class="muted">Phone URL</div><div id="phoneUrlOut"></div>
          <div class="muted">Last msg</div><div id="lastMsgOut" class="muted">—</div>
        </div>

        <p class="mono muted" style="margin-top:10px;">
          Cache-buster: we append <code>&v=TIMESTAMP</code> so iPhone Chrome loads the newest phone page every scan.
        </p>
      </div>

      <div class="card" style="flex:0 0 320px;">
        <h2>QR (scan on phone)</h2>
        <div id="qr"></div>
        <p class="mono muted" style="margin-top:10px;">
          If QR is blank: open DevTools → Console for errors.
        </p>
      </div>

      <div class="card">
        <h2>Live Energy</h2>
        <p class="big" id="energyBig">0%</p>
        <p class="sub" id="energySub">waiting for messages…</p>

        <div class="kv mono" style="margin-top:14px;">
          <div class="muted">groove</div><div id="grooveOut">0</div>
          <div class="muted">orbit</div><div id="orbitOut">0</div>
          <div class="muted">smooth</div><div id="smoothOut">0</div>
          <div class="muted">speed</div><div id="speedOut">0</div>
          <div class="muted">locked</div><div id="lockedOut">false</div>
          <div class="muted">hz</div><div id="hzOut">0</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Ably (CDN) -->
  <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>

  <!-- QRCode library (you said you now have this working) -->
  <!-- Put qrcode.min.js in the same folder as this HTML, or change the src to your path -->
  <script src="./qrcode.min.js"></script>

  <script>
  (() => {
    // ========= CONFIG =========
    const WORKER_BASE = "https://orb-token.mrgarthwilliams.workers.dev";
    const TOKEN_URL   = WORKER_BASE + "/token";

    // CHANGE THIS to your published mobile page URL:
    // Example: "https://mrgarthwilliams.github.io/orb/mobile-orb-v1.html"
    const PHONE_PAGE_URL = "https://mrgarthwilliams.github.io/YOUR_REPO/mobile-orb-v1.html";

    // Room naming strategy:
    // channel is always "orb:<code>"
    function makeRoomCode() {
      return Math.random().toString(36).slice(2, 8).toUpperCase(); // e.g. "7H2K9P"
    }

    // ========= UI =========
    const $ = (id) => document.getElementById(id);
    const connectBtn = $("connectBtn");
    const disconnectBtn = $("disconnectBtn");
    const statusPill = $("statusPill");
    const workerOut = $("workerOut");
    const roomOut = $("roomOut");
    const phoneUrlOut = $("phoneUrlOut");
    const lastMsgOut = $("lastMsgOut");

    const energyBig = $("energyBig");
    const energySub = $("energySub");
    const grooveOut = $("grooveOut");
    const orbitOut  = $("orbitOut");
    const smoothOut = $("smoothOut");
    const speedOut  = $("speedOut");
    const lockedOut = $("lockedOut");
    const hzOut     = $("hzOut");

    workerOut.textContent = WORKER_BASE;

    function setStatus(text, cls) {
      statusPill.textContent = text;
      statusPill.classList.remove("good","warn","bad");
      if (cls) statusPill.classList.add(cls);
    }

    function pct(x01) {
      const n = Math.max(0, Math.min(1, Number(x01) || 0));
      return Math.round(n * 100);
    }

    // ========= QR =========
    function renderQR(url) {
      const qrEl = document.getElementById("qr");
      qrEl.innerHTML = "";
      // QRCode.js supports either new QRCode(el, opts) or QRCode.toCanvas, depending on build.
      // This is the common constructor-style build.
      try {
        new QRCode(qrEl, {
          text: url,
          width: 260,
          height: 260,
          correctLevel: QRCode.CorrectLevel.M
        });
      } catch (e) {
        console.error("QR render failed. Check qrcode.min.js.", e);
        qrEl.innerHTML = "<div class='mono bad'>QR render failed (see console)</div>";
      }
    }

    // ========= Ably =========
    let ably = null;
    let channel = null;
    let roomCode = null;
    let roomChannelName = null;

    function buildPhoneUrl(roomCode) {
      // *** THIS IS THE IMPORTANT PART ***
      // Add a cache-buster query param so iPhone Chrome doesn't use old cached HTML.
      const v = Date.now(); // unique per connect click
      const u = new URL(PHONE_PAGE_URL);
      u.searchParams.set("room", roomCode); // phone will convert to orb:<code> if needed
      u.searchParams.set("v", String(v));   // cache-buster
      return u.toString();
    }

    function buildAuthUrl(roomCode) {
      // Worker expects ?room=<code> and will mint capability for orb:<code>
      const clientId = "game-" + Math.random().toString(16).slice(2,6);
      const u = new URL(TOKEN_URL);
      u.searchParams.set("room", roomCode);
      u.searchParams.set("clientId", clientId);
      u.searchParams.set("v", String(Date.now())); // also avoids caching for token fetch
      return u.toString();
    }

    async function connect() {
      if (!PHONE_PAGE_URL.includes("http")) {
        alert("Edit PHONE_PAGE_URL at the top of the file to your real GitHub Pages URL.");
        return;
      }

      // Fresh room every time for bulletproof pairing
      roomCode = makeRoomCode();
      roomChannelName = "orb:" + roomCode;

      const phoneUrl = buildPhoneUrl(roomCode);
      const authUrl  = buildAuthUrl(roomCode);

      roomOut.textContent = roomChannelName;
      phoneUrlOut.innerHTML = `<a href="${phoneUrl}" target="_blank" rel="noopener" class="good">${phoneUrl}</a>`;
      renderQR(phoneUrl);

      setStatus("minting token…", "warn");

      // Preflight token fetch so failures show clearly
      try {
        const r = await fetch(authUrl, { method: "GET", cache: "no-store" });
        const j = await r.json();
        if (!r.ok || !j.token) {
          console.error("TOKEN ERROR:", r.status, j);
          setStatus("token FAILED (console)", "bad");
          return;
        }
      } catch (e) {
        console.error("TOKEN FETCH FAILED:", e);
        setStatus("token fetch FAILED", "bad");
        return;
      }

      setStatus("connecting…", "warn");

      // Clean old connection
      try { if (channel) channel.detach(); } catch(_) {}
      try { if (ably) ably.close(); } catch(_) {}
      ably = null; channel = null;

      ably = new Ably.Realtime({ authUrl, autoConnect: true });

      ably.connection.on("connected", () => setStatus("ably connected ✓", "good"));
      ably.connection.on("failed", (st) => { console.error("ABLY FAILED:", st); setStatus("ably FAILED", "bad"); });
      ably.connection.on("disconnected", (st) => { console.warn("ABLY disconnected:", st); setStatus("disconnected", "warn"); });

      channel = ably.channels.get(roomChannelName);

      channel.attach((err) => {
        if (err) {
          console.error("CHANNEL ATTACH ERROR:", err);
          setStatus("channel attach FAILED", "bad");
          return;
        }
        setStatus("channel attached ✓", "good");
        disconnectBtn.disabled = false;
        connectBtn.disabled = true;
      });

      channel.subscribe("orb", (msg) => {
        const d = msg.data || {};
        lastMsgOut.textContent = new Date().toLocaleTimeString() + " • " + JSON.stringify(d).slice(0, 140);

        const e = pct(d.energy01);
        energyBig.textContent = e + "%";
        energySub.textContent = "receiving…";

        grooveOut.textContent = pct(d.groove01);
        orbitOut.textContent  = pct(d.orbit01);
        smoothOut.textContent = pct(d.smooth01);
        speedOut.textContent  = pct(d.speed01);
        lockedOut.textContent = String(!!d.locked);
        hzOut.textContent     = (Number(d.hz) || 0).toFixed(2);
      });
    }

    function disconnect() {
      try { if (channel) channel.detach(); } catch(_) {}
      try { if (ably) ably.close(); } catch(_) {}
      ably = null; channel = null;

      setStatus("idle", "");
      disconnectBtn.disabled = true;
      connectBtn.disabled = false;

      energyBig.textContent = "0%";
      energySub.textContent = "waiting for messages…";
      lastMsgOut.textContent = "—";
    }

    connectBtn.addEventListener("click", connect);
    disconnectBtn.addEventListener("click", disconnect);

    // Optional: auto-connect if URL includes ?autoconnect=1
    const url = new URL(location.href);
    if (url.searchParams.get("autoconnect") === "1") connect();
  })();
  </script>
</body>
</html>
