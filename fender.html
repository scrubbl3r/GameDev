<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Defender-ish Sound Generator (Procedural, No Samples)</title>
  <style>
    :root{
      --bg:#07090b;
      --ink:#d7f7e3;
      --muted:#89a39a;
      --accent:#39ff88;
      --border:rgba(57,255,136,.18);
      --shadow:rgba(0,0,0,.45);
      --warn:#ffb84d;
    }
    html,body{height:100%;}
    body{
      margin:0;
      background:radial-gradient(1200px 700px at 40% 0%, #0b1216 0%, var(--bg) 55%);
      color:var(--ink);
      font:14px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      letter-spacing:.2px;
    }
    .wrap{max-width:1120px;margin:24px auto;padding:0 14px;}
    .title{
      display:flex;align-items:flex-end;justify-content:space-between;gap:12px;flex-wrap:wrap;
      margin:6px 0 14px 0;
    }
    h1{font-size:18px;margin:0;font-weight:650;}
    .sub{color:var(--muted);font-size:12px;margin-top:4px;}
    .badge{
      border:1px solid var(--border);
      background:rgba(0,0,0,.25);
      padding:8px 10px;border-radius:12px;
      box-shadow:0 10px 24px var(--shadow);
      color:var(--muted);
      max-width:620px;
    }
    .grid{
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap:12px;
    }
    @media (max-width: 900px){ .grid{grid-template-columns:1fr;} }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.015));
      border:1px solid var(--border);
      border-radius:16px;
      box-shadow:0 18px 42px var(--shadow);
      overflow:hidden;
    }
    .card h2{
      margin:0;padding:12px 14px;
      font-size:13px;font-weight:650;
      border-bottom:1px solid rgba(255,255,255,.06);
      color:#eafdf4;
    }
    .card .body{padding:12px 14px;}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin:8px 0;}
    button{
      appearance:none;border:1px solid var(--border);
      background:rgba(0,0,0,.35);
      color:var(--ink);
      padding:10px 12px;border-radius:12px;
      cursor:pointer;
      transition:transform .04s ease, background .12s ease, border-color .12s ease;
      box-shadow:0 10px 24px var(--shadow);
    }
    button:hover{background:rgba(57,255,136,.10);border-color:rgba(57,255,136,.35);}
    button:active{transform:translateY(1px);}
    button.primary{
      background:rgba(57,255,136,.14);
      border-color:rgba(57,255,136,.35);
    }
    button.danger{
      background:rgba(255,184,77,.12);
      border-color:rgba(255,184,77,.35);
      color:#fff2dc;
    }
    .pill{
      display:inline-flex;align-items:center;gap:8px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.25);
      padding:8px 10px;border-radius:999px;
      color:var(--muted);
    }
    label{color:var(--muted);font-size:12px;}
    input[type="range"]{width:210px;}
    input[type="text"], select{
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.10);
      color:var(--ink);
      border-radius:10px;
      padding:8px 10px;
      outline:none;
    }
    select{cursor:pointer;}
    .kvs{
      display:grid;grid-template-columns: 155px 1fr;
      gap:8px 10px;align-items:center;
      margin-top:8px;
    }
    .mono{font:12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;}
    .hint{color:var(--muted);font-size:12px;line-height:1.35;}
    .warn{color:var(--warn);}
    .small{font-size:12px;color:var(--muted);}
    .divider{height:1px;background:rgba(255,255,255,.06);margin:12px 0;}
    .tag{padding:2px 8px;border:1px solid rgba(255,255,255,.10);border-radius:999px;color:var(--muted);}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="title">
      <div>
        <h1>Defender-ish Sound Generator <span class="small">(procedural Web Audio, no samples)</span></h1>
        <div class="sub">Randomize generates a new “variant set” for every category (bigger swings + longer tail potential).</div>
      </div>
      <div class="badge">
        <div class="mono">Note</div>
        <div class="hint">
          Original synth inspired by early-80s arcade *characteristics* — <span class="warn">no ROM / proprietary code</span>.
        </div>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <h2>Play SFX</h2>
        <div class="body">
          <div class="row">
            <button class="primary" id="btnStart">Start Audio</button>
            <span class="pill"><span>Master</span><input id="master" type="range" min="0" max="1" step="0.001" value="0.35"><span class="mono" id="masterVal">0.35</span></span>
            <span class="pill"><span>Lo-Fi</span><input id="crush" type="range" min="0" max="1" step="0.001" value="0.35"><span class="mono" id="crushVal">0.35</span></span>
            <span class="tag mono" id="revTag">rev#0</span>
          </div>

          <div class="row">
            <button id="laser">Laser</button>
            <button id="zap">Zap</button>
            <button id="thrust">Thrust</button>
            <button id="explosion">Explosion</button>
            <button id="pickup">Pickup</button>
            <button id="alarm">Alarm</button>
          </div>

          <div class="row">
            <button id="smartbomb">Smart Bomb</button>
            <button id="hyperspace">Hyperspace</button>
            <button id="teleport">Teleport</button>
            <button class="danger" id="panic">Stop All</button>
          </div>

          <div class="divider"></div>

          <div class="row">
            <label for="mode">Randomize Mode</label>
            <select id="mode">
              <option value="faithful">Faithful (tight)</option>
              <option value="spicy" selected>Spicy (sweet spot)</option>
              <option value="chaos">Chaos (big swings)</option>
            </select>

            <label for="mutAmt">Mutation</label>
            <input id="mutAmt" type="range" min="0" max="1" step="0.001" value="0.85">
            <span class="mono" id="mutAmtVal">0.85</span>

            <label for="seed">Seed</label>
            <input id="seed" type="text" value="DEFENDER" class="mono" style="width:180px;">
            <button id="randAll" class="primary">Randomize All</button>
            <button id="resetBase">Reset to Base</button>
          </div>

          <div class="hint">
            Changes in this drop:
            <span class="mono">Chaos</span> now has *much* wider ranges + more “jump” events, and durations are biased to include
            longer tails (without eliminating short blips).
          </div>

          <div class="divider"></div>
          <div class="mono small" id="status">Audio not started.</div>
        </div>
      </div>

      <div class="card">
        <h2>Current Patch (per effect)</h2>
        <div class="body">
          <div class="hint">These are the live params used by each category model. Randomize replaces them.</div>
          <div class="divider"></div>
          <div class="kvs mono" id="patchView"></div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ----------------------------
  // Utils
  // ----------------------------
  const $ = (q) => document.querySelector(q);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp  = (a, b, t) => a + (b - a) * t;

  function hash32(str){
    let h = 2166136261 >>> 0;
    for (let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }
  function mulberry32(seed){
    let t = seed >>> 0;
    return function(){
      t += 0x6D2B79F5;
      let r = Math.imul(t ^ (t >>> 15), 1 | t);
      r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
      return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
    };
  }
  function triRand(rng){ return (rng() + rng()) * 0.5; } // centered-ish
  function randSym(rng){ return (triRand(rng) - 0.5) * 2.0; }

  function makeDriveCurve(amount){
    const n = 1024;
    const curve = new Float32Array(n);
    const k = amount;
    for (let i=0;i<n;i++){
      const x = (i * 2 / (n - 1)) - 1;
      curve[i] = (1 + k) * x / (1 + k * Math.abs(x));
    }
    return curve;
  }

  function modeConfig(mode){
    // wide: multiplies *range*; jumpP/jumpScale: more big leaps in chaos
    if (mode === "faithful") return { wide: 0.75, jumpP: 0.08, jumpScale: 0.55 };
    if (mode === "chaos")   return { wide: 3.00, jumpP: 0.28, jumpScale: 1.65 };
    return { wide: 1.55, jumpP: 0.16, jumpScale: 1.00 }; // spicy
  }

  // BIGGER variation:
  // - jitter is now much larger
  // - more frequent/bigger jumps, especially in chaos
  // - occasional "reroll anywhere in range" events
  function pickVal(rng, base, min, max, mutAmt, modeWide, jumpP, jumpScale){
    const span = (max - min);

    // Normal-ish jitter around base
    const jitter = randSym(rng) * span * 0.42 * modeWide;  // was ~0.18; now much bigger

    // Big jump events
    const jump = (rng() < (jumpP * (0.35 + 0.65 * mutAmt)))
      ? randSym(rng) * span * 0.70 * modeWide * jumpScale
      : 0;

    // Rare full reroll across full range (chaos loves this)
    const rerollP = (0.03 + 0.10 * (modeWide/3.0)) * (0.25 + 0.75 * mutAmt);
    if (rng() < rerollP){
      return min + rng() * span;
    }

    // Blend base->wild by mutation amount
    const v = base + (jitter + jump) * (0.25 + 0.75 * mutAmt);
    return clamp(v, min, max);
  }

  // Duration picker biased to include longer tails sometimes.
  // We keep short sounds alive, but introduce a heavy-tail option.
  function pickDur(rng, base, min, max, mutAmt, modeWide){
    const span = max - min;

    // Mix of:
    // - tight-ish around base (triangular)
    // - wide uniform
    // - heavy tail via power curve (bias high)
    const pTail = clamp(0.10 + 0.25 * mutAmt + 0.12 * (modeWide/3.0), 0.10, 0.55);
    const pUni  = clamp(0.10 + 0.20 * mutAmt, 0.10, 0.35);
    const r = rng();

    let v;
    if (r < pTail){
      // heavy tail: bias toward max
      const u = Math.pow(rng(), 0.35); // smaller exponent => more near 1
      v = min + u * span;
    } else if (r < pTail + pUni){
      v = min + rng() * span;
    } else {
      // around base with wider jitter
      const tri = triRand(rng);
      const jitter = (tri - 0.5) * 2.0 * span * (0.35 + 0.45 * mutAmt) * modeWide;
      v = base + jitter;
    }
    return clamp(v, min, max);
  }

  // ----------------------------
  // Audio Graph
  // ----------------------------
  let ctx = null;
  let masterGain, compressor, postGain, crusher = null;
  let globalStop = [];

  function ensureAudio(){
    if (ctx) return ctx;
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    masterGain = ctx.createGain();
    compressor = ctx.createDynamicsCompressor();
    postGain = ctx.createGain();

    masterGain.gain.value = parseFloat($("#master").value);
    compressor.threshold.value = -18;
    compressor.knee.value = 24;
    compressor.ratio.value = 8;
    compressor.attack.value = 0.003;
    compressor.release.value = 0.12;
    postGain.gain.value = 0.95;

    masterGain.connect(compressor);
    compressor.connect(postGain);
    postGain.connect(ctx.destination);
    return ctx;
  }
  const now = () => ctx.currentTime;

  function makeBitcrusher(ctx){
    const inGain = ctx.createGain();
    const outGain = ctx.createGain();
    const proc = ctx.createScriptProcessor(1024, 1, 1);
    proc._ph = 0;
    proc._last = 0;

    proc.onaudioprocess = (e) => {
      const input = e.inputBuffer.getChannelData(0);
      const output = e.outputBuffer.getChannelData(0);

      const amount = parseFloat($("#crush").value);
      const step = Math.floor(lerp(1, 20, amount));
      const bits = Math.floor(lerp(16, 5, amount));
      const levels = (1 << bits) - 1;

      let ph = proc._ph;
      let last = proc._last;

      for (let i=0;i<input.length;i++){
        ph++;
        if (ph >= step){
          ph = 0;
          const q = Math.round((input[i] * 0.5 + 0.5) * levels) / levels;
          last = (q - 0.5) * 2.0;
        }
        output[i] = last;
      }
      proc._ph = ph;
      proc._last = last;
    };

    inGain.connect(proc);
    proc.connect(outGain);
    return { input: inGain, output: outGain, node: proc };
  }

  function connectToMaster(node){
    if (!crusher) crusher = makeBitcrusher(ctx);
    node.connect(crusher.input);
    crusher.output.connect(masterGain);
  }

  function scheduleStopDisconnect(node, tStop){
    globalStop.push(() => { try{ node.disconnect(); }catch(e){} });
    if (tStop != null){
      setTimeout(() => { try{ node.disconnect(); }catch(e){} }, Math.max(0, (tStop - now()) * 1000));
    }
  }

  function stopAll(){
    globalStop.forEach(fn => { try{ fn(); }catch(e){} });
    globalStop.length = 0;
  }

  // ----------------------------
  // Noise buffer (LFSR-ish)
  // ----------------------------
  let noiseBuf = null;
  function getNoiseBuffer(){
    if (noiseBuf) return noiseBuf;
    const dur = 2.0;
    const len = Math.floor(ctx.sampleRate * dur);
    const buf = ctx.createBuffer(1, len, ctx.sampleRate);
    const d = buf.getChannelData(0);

    let lfsr = 0xACE1;
    for (let i=0;i<len;i++){
      const bit = ((lfsr >> 0) ^ (lfsr >> 2) ^ (lfsr >> 3) ^ (lfsr >> 5)) & 1;
      lfsr = (lfsr >> 1) | (bit << 15);
      d[i] = ((lfsr & 1) ? 1 : -1) * 0.9;
    }
    noiseBuf = buf;
    return noiseBuf;
  }

  function noiseSource(){
    const src = ctx.createBufferSource();
    src.buffer = getNoiseBuffer();
    src.loop = true;
    return src;
  }

  // Envelope helper:
  // - p.dur is interpreted as "tail length" (release)
  // - we also allow a longer sustain plateau by using a higher sustain value on long sounds
  function expEnv(param, t0, a, d, peak, sustain, rel){
    const tA = t0 + a;
    const tD = tA + d;

    param.cancelScheduledValues(t0);
    param.setValueAtTime(0.0001, t0);
    param.exponentialRampToValueAtTime(Math.max(0.0001, peak), tA);
    param.exponentialRampToValueAtTime(Math.max(0.0001, sustain), tD);

    if (rel != null){
      const tR = tD + rel;
      param.exponentialRampToValueAtTime(0.0001, tR);
      return tR;
    }
    return tD;
  }

  function feedbackDelay(input, timeSec, feedback, wet){
    const d = ctx.createDelay(1.0);
    d.delayTime.value = timeSec;
    const fb = ctx.createGain();
    fb.gain.value = feedback;

    const wetG = ctx.createGain();
    wetG.gain.value = wet;

    const dryG = ctx.createGain();
    dryG.gain.value = 1.0 - wet;

    input.connect(dryG);
    input.connect(d);
    d.connect(fb);
    fb.connect(d);

    const out = ctx.createGain();
    dryG.connect(out);
    d.connect(wetG);
    wetG.connect(out);

    return { out, delay:d, fb, wetG, dryG };
  }

  // ----------------------------
  // Base Patch (template)
  // ----------------------------
  const BASE = {
    laser:      { baseHz: 900,  sweepHz: 520,  sweepTime: 0.055, bite: 0.55, click: 0.12, noise: 0.08, hp: 260, dur: 0.14 },
    zap:        { baseHz: 220,  sweepHz: 1400, sweepTime: 0.090, fmAmt: 180, fmHz: 32, noise: 0.18, bp: 1200, q: 8, dur: 0.22 },
    thrust:     { noise: 0.75,  lp: 520, q: 0.8, flutterHz: 16, flutterAmt: 0.18, dur: 0.45 },
    explosion:  { noise: 1.0,   lp0: 3800, lp1: 240, sweepTime: 0.32, boomHz: 62, boomAmt: 0.65, crackle: 0.25, dur: 0.95 },
    pickup:     { baseHz: 660,  upHz: 1320, glide: 0.12, vibHz: 10, vibAmt: 0.02, twang: 0.35, dur: 0.35 },
    alarm:      { aHz: 520,     bHz: 860,  rate: 9.0, edge: 0.6, dur: 0.95 },

    smartbomb:  { dur: 1.40, boomHz: 44, boomAmt: 0.9, sweep0: 5200, sweep1: 180, sweepTime: 0.75, ringHz: 220, ringAmt: 0.35, noise: 1.0, crackle: 0.35 },
    hyperspace: { dur: 1.20, whooshLP0: 4200, whooshLP1: 220, whooshTime: 0.75, tone0: 180, tone1: 1500, toneTime: 0.55, edge: 0.55, delayT: 0.075, delayFb: 0.45, wet: 0.35 },
    teleport:   { dur: 0.60, chirp0: 420, chirp1: 2200, chirpTime: 0.14, sparkleBP: 1800, sparkleQ: 9, sparkle: 0.28, edge: 0.45, delayT: 0.045, delayFb: 0.25, wet: 0.22 }
  };

  let patch = deepClone(BASE);
  function deepClone(o){ return JSON.parse(JSON.stringify(o)); }

  // ----------------------------
  // Randomizer (BIGGER + longer tails)
  // ----------------------------
  let REV = 0;

  function resetToBase(){
    patch = deepClone(BASE);
    renderPatch();
  }

  function randomizeAll(){
    REV++;
    $("#revTag").textContent = `rev#${REV}`;

    const mode = $("#mode").value;
    const mutAmt = parseFloat($("#mutAmt").value);
    const { wide, jumpP, jumpScale } = modeConfig(mode);

    const seedStr = `${$("#seed").value}|${mode}|${REV}`;
    const rng = mulberry32(hash32(seedStr));

    const r = (name, key, min, max) => {
      patch[name][key] = pickVal(rng, BASE[name][key], min, max, mutAmt, wide, jumpP, jumpScale);
    };
    const rd = (name, key, min, max) => {
      patch[name][key] = pickDur(rng, BASE[name][key], min, max, mutAmt, wide);
    };

    // LASER
    r("laser","baseHz",   260, 2200);
    r("laser","sweepHz",  60,  2600);
    r("laser","sweepTime",0.018,0.22);
    r("laser","bite",     0.02,1.00);
    r("laser","click",    0.00,0.45);
    r("laser","noise",    0.00,0.65);
    r("laser","hp",       30,  2200);
    rd("laser","dur",     0.05,2.20);   // MUCH longer possible

    // ZAP
    r("zap","baseHz",     50,  900);
    r("zap","sweepHz",    180, 5000);
    r("zap","sweepTime",  0.020,0.35);
    r("zap","fmAmt",      0,   2200);
    r("zap","fmHz",       2,   220);
    r("zap","noise",      0.00,0.90);
    r("zap","bp",         160, 5200);
    r("zap","q",          0.6, 40);
    rd("zap","dur",       0.07,2.60);

    // THRUST
    r("thrust","noise",     0.10,1.00);
    r("thrust","lp",        80,  2400);
    r("thrust","q",         0.2, 10.0);
    r("thrust","flutterHz", 0.5, 60);
    r("thrust","flutterAmt",0.00,0.75);
    rd("thrust","dur",      0.12,3.20);

    // EXPLOSION
    r("explosion","noise",     0.15,1.00);
    r("explosion","lp0",       600, 10000);
    r("explosion","lp1",       40,  1200);
    r("explosion","sweepTime", 0.10,2.20);
    r("explosion","boomHz",    16,  220);
    r("explosion","boomAmt",   0.05,1.00);
    r("explosion","crackle",   0.00,1.00);
    rd("explosion","dur",      0.18,4.20);

    // PICKUP
    r("pickup","baseHz",  120, 2200);
    r("pickup","upHz",    220, 8200);
    r("pickup","glide",   0.02,0.70);
    r("pickup","vibHz",   0.5, 50);
    r("pickup","vibAmt",  0.0, 0.20);
    r("pickup","twang",   0.00,1.00);
    rd("pickup","dur",    0.05,2.80);

    // ALARM
    r("alarm","aHz",  80,  2200);
    r("alarm","bHz",  120, 5200);
    r("alarm","rate", 0.5, 40.0);
    r("alarm","edge", 0.00,1.00);
    rd("alarm","dur", 0.12,5.00);  // alarms can get LONG

    // SMART BOMB
    rd("smartbomb","dur",      0.25,5.50);
    r("smartbomb","boomHz",    10,  160);
    r("smartbomb","boomAmt",   0.05,1.00);
    r("smartbomb","sweep0",    700, 12000);
    r("smartbomb","sweep1",    30,  1800);
    r("smartbomb","sweepTime", 0.12,4.00);
    r("smartbomb","ringHz",    30,  1600);
    r("smartbomb","ringAmt",   0.00,1.00);
    r("smartbomb","noise",     0.10,1.00);
    r("smartbomb","crackle",   0.00,1.00);

    // HYPERSPACE
    rd("hyperspace","dur",       0.18,4.50);
    r("hyperspace","whooshLP0",  500, 12000);
    r("hyperspace","whooshLP1",  40,  2200);
    r("hyperspace","whooshTime", 0.10,3.20);
    r("hyperspace","tone0",      20,  900);
    r("hyperspace","tone1",      80,  9000);
    r("hyperspace","toneTime",   0.06,2.60);
    r("hyperspace","edge",       0.00,1.00);
    r("hyperspace","delayT",     0.010,0.250);
    r("hyperspace","delayFb",    0.00,0.88);
    r("hyperspace","wet",        0.00,0.85);

    // TELEPORT
    rd("teleport","dur",         0.06,2.80);
    r("teleport","chirp0",       40,  2200);
    r("teleport","chirp1",       120, 12000);
    r("teleport","chirpTime",    0.02,0.95);
    r("teleport","sparkleBP",    120, 9000);
    r("teleport","sparkleQ",     0.6, 55.0);
    r("teleport","sparkle",      0.00,1.00);
    r("teleport","edge",         0.00,1.00);
    r("teleport","delayT",       0.005,0.180);
    r("teleport","delayFb",      0.00,0.78);
    r("teleport","wet",          0.00,0.80);

    renderPatch();
  }

  // ----------------------------
  // Sound Models
  // (Key change: release/tails are now longer when p.dur is long.
  //  We also use a higher sustain for longer durations so it doesn't vanish instantly.)
  // ----------------------------
  function tailSustainFromDur(d){
    // short blips: low sustain; long sounds: keep more body
    return clamp(lerp(0.10, 0.32, clamp(d / 2.5, 0, 1)), 0.08, 0.36);
  }

  function playLaser(){
    const p = patch.laser;
    const t0 = now();

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0.0001;

    const osc = ctx.createOscillator();
    osc.type = "square";
    osc.frequency.setValueAtTime(p.baseHz + p.sweepHz, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(20, p.baseHz), t0 + p.sweepTime);

    const shaper = ctx.createWaveShaper();
    shaper.curve = makeDriveCurve(lerp(10, 900, p.bite));
    shaper.oversample = "2x";

    const n = noiseSource();
    const nG = ctx.createGain(); nG.gain.value = 0.0001;

    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.value = p.hp;

    const mixTone = ctx.createGain(); mixTone.gain.value = 1.0 - p.noise;
    const mixNoise = ctx.createGain(); mixNoise.gain.value = p.noise;

    const sustain = tailSustainFromDur(p.dur);
    const tEnd = expEnv(g.gain, t0, 0.002, 0.030, 0.85, sustain, p.dur);
    expEnv(nG.gain, t0, 0.001, 0.010, p.click, 0.0001, Math.min(0.20, 0.04 + p.dur*0.10));

    osc.connect(shaper); shaper.connect(mixTone);
    n.connect(hp); hp.connect(nG); nG.connect(mixNoise);
    mixTone.connect(g); mixNoise.connect(g);

    g.connect(out);
    connectToMaster(out);

    osc.start(t0); osc.stop(tEnd + 0.03);
    n.start(t0);   n.stop(tEnd + 0.03);

    scheduleStopDisconnect(out, tEnd + 0.18);
  }

  function playZap(){
    const p = patch.zap;
    const t0 = now();

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0.0001;

    const osc = ctx.createOscillator();
    osc.type = "sawtooth";
    osc.frequency.setValueAtTime(p.baseHz, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(30, p.sweepHz), t0 + p.sweepTime);

    const mod = ctx.createOscillator();
    mod.type = "sine";
    mod.frequency.value = p.fmHz;
    const modG = ctx.createGain();
    modG.gain.value = p.fmAmt;
    mod.connect(modG);
    modG.connect(osc.frequency);

    const n = noiseSource();
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = p.bp;
    bp.Q.value = p.q;

    const mixTone = ctx.createGain(); mixTone.gain.value = 0.85;
    const mixNoise= ctx.createGain(); mixNoise.gain.value= p.noise;

    const sustain = tailSustainFromDur(p.dur);
    const tEnd = expEnv(g.gain, t0, 0.004, 0.05, 0.95, sustain, p.dur);

    osc.connect(mixTone);
    n.connect(bp); bp.connect(mixNoise);
    mixTone.connect(g); mixNoise.connect(g);

    g.connect(out);
    connectToMaster(out);

    osc.start(t0); osc.stop(tEnd + 0.03);
    mod.start(t0); mod.stop(tEnd + 0.03);
    n.start(t0);   n.stop(tEnd + 0.03);

    scheduleStopDisconnect(out, tEnd + 0.20);
  }

  function playThrust(){
    const p = patch.thrust;
    const t0 = now();

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0.0001;

    const n = noiseSource();
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(p.lp, t0);
    lp.Q.value = p.q;

    // Flutter tremolo on gain
    const lfo = ctx.createOscillator();
    lfo.type = "sine";
    lfo.frequency.value = p.flutterHz;
    const lfoG = ctx.createGain();
    lfoG.gain.value = p.flutterAmt;
    lfo.connect(lfoG);
    lfoG.connect(g.gain);

    const sustain = tailSustainFromDur(p.dur);
    const tEnd = expEnv(g.gain, t0, 0.010, 0.12, 0.65, sustain, p.dur);

    const mix = ctx.createGain();
    mix.gain.value = p.noise;

    n.connect(lp); lp.connect(mix); mix.connect(g);
    g.connect(out);
    connectToMaster(out);

    n.start(t0); n.stop(tEnd + 0.05);
    lfo.start(t0); lfo.stop(tEnd + 0.05);

    scheduleStopDisconnect(out, tEnd + 0.25);
  }

  function playExplosion(){
    const p = patch.explosion;
    const t0 = now();

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0.0001;

    const n = noiseSource();
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(p.lp0, t0);
    lp.frequency.exponentialRampToValueAtTime(Math.max(50, p.lp1), t0 + p.sweepTime);
    lp.Q.value = 0.7;

    const boom = ctx.createOscillator();
    boom.type = "sine";
    boom.frequency.setValueAtTime(p.boomHz * 1.15, t0);
    boom.frequency.exponentialRampToValueAtTime(Math.max(12, p.boomHz), t0 + 0.30);
    const boomG = ctx.createGain(); boomG.gain.value = 0.0001;

    const crack = noiseSource();
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.value = 1200;
    const crackG = ctx.createGain(); crackG.gain.value = 0.0001;

    const sustain = tailSustainFromDur(p.dur);
    const tEnd = expEnv(g.gain, t0, 0.004, 0.12, 1.00, sustain, p.dur);

    // boom/crackle tails scale with dur (so long explosions keep body)
    expEnv(boomG.gain, t0, 0.002, 0.14, p.boomAmt, 0.0001, clamp(0.25 + p.dur*0.40, 0.18, 3.20));
    expEnv(crackG.gain, t0, 0.001, 0.08, p.crackle, 0.0001, clamp(0.15 + p.dur*0.25, 0.12, 2.20));

    const mixN = ctx.createGain(); mixN.gain.value = p.noise;
    const mixB = ctx.createGain(); mixB.gain.value = 0.75;

    n.connect(lp); lp.connect(mixN);
    boom.connect(boomG); boomG.connect(mixB);
    crack.connect(hp); hp.connect(crackG);

    mixN.connect(g);
    mixB.connect(g);
    crackG.connect(g);

    g.connect(out);
    connectToMaster(out);

    n.start(t0);     n.stop(tEnd + 0.06);
    crack.start(t0); crack.stop(tEnd + 0.06);
    boom.start(t0);  boom.stop(tEnd + 0.06);

    scheduleStopDisconnect(out, tEnd + 0.30);
  }

  function playPickup(){
    const p = patch.pickup;
    const t0 = now();

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0.0001;

    const osc = ctx.createOscillator();
    osc.type = "triangle";
    osc.frequency.setValueAtTime(p.baseHz, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(30, p.upHz), t0 + p.glide);

    const vib = ctx.createOscillator();
    vib.type = "sine";
    vib.frequency.value = p.vibHz;
    const vibG = ctx.createGain();
    vibG.gain.value = p.vibAmt * p.baseHz;
    vib.connect(vibG);
    vibG.connect(osc.frequency);

    const sh = ctx.createWaveShaper();
    sh.curve = makeDriveCurve(lerp(5, 900, p.twang));
    sh.oversample = "2x";

    const sustain = tailSustainFromDur(p.dur);
    const tEnd = expEnv(g.gain, t0, 0.004, 0.07, 0.75, sustain, p.dur);

    osc.connect(sh); sh.connect(g);
    g.connect(out);
    connectToMaster(out);

    osc.start(t0); osc.stop(tEnd + 0.03);
    vib.start(t0); vib.stop(tEnd + 0.03);

    scheduleStopDisconnect(out, tEnd + 0.20);
  }

  function playAlarm(){
    const p = patch.alarm;
    const t0 = now();

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0.0001;

    const osc = ctx.createOscillator();
    osc.type = "square";
    osc.frequency.setValueAtTime(p.aHz, t0);

    // toggles freq (arcade alarm)
    const step = ctx.createOscillator();
    step.type = "square";
    step.frequency.value = p.rate;

    const stepG = ctx.createGain();
    stepG.gain.value = (p.bHz - p.aHz) * 0.5;
    step.connect(stepG);
    stepG.connect(osc.frequency);

    const sh = ctx.createWaveShaper();
    sh.curve = makeDriveCurve(lerp(5, 900, p.edge));
    sh.oversample = "2x";

    // alarms: keep more sustain on long dur
    const sustain = clamp(lerp(0.18, 0.40, clamp(p.dur/3.0, 0, 1)), 0.14, 0.48);
    const tEnd = expEnv(g.gain, t0, 0.010, 0.08, 0.50, sustain, p.dur);

    osc.connect(sh); sh.connect(g);
    g.connect(out);
    connectToMaster(out);

    osc.start(t0);  osc.stop(tEnd + 0.03);
    step.start(t0); step.stop(tEnd + 0.03);

    scheduleStopDisconnect(out, tEnd + 0.25);
  }

  function playSmartBomb(){
    const p = patch.smartbomb;
    const t0 = now();

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0.0001;

    const n = noiseSource();
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(p.sweep0, t0);
    lp.frequency.exponentialRampToValueAtTime(Math.max(40, p.sweep1), t0 + p.sweepTime);
    lp.Q.value = 0.7;

    const boom = ctx.createOscillator();
    boom.type = "sine";
    boom.frequency.setValueAtTime(p.boomHz * 1.1, t0);
    boom.frequency.exponentialRampToValueAtTime(Math.max(10, p.boomHz), t0 + 0.40);
    const boomG = ctx.createGain(); boomG.gain.value = 0.0001;

    const ring = ctx.createOscillator();
    ring.type = "square";
    ring.frequency.setValueAtTime(p.ringHz, t0);
    ring.frequency.exponentialRampToValueAtTime(Math.max(10, p.ringHz * 0.45), t0 + Math.min(1.2, 0.4 + p.dur*0.2));
    const ringG = ctx.createGain(); ringG.gain.value = 0.0001;

    const crack = noiseSource();
    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.value = 1000;
    const crackG = ctx.createGain(); crackG.gain.value = 0.0001;

    const sustain = clamp(lerp(0.12, 0.36, clamp(p.dur/3.0, 0, 1)), 0.10, 0.40);
    const tEnd = expEnv(g.gain, t0, 0.006, 0.14, 1.00, sustain, p.dur);

    expEnv(boomG.gain, t0, 0.002, 0.10, p.boomAmt, 0.0001, clamp(0.30 + p.dur*0.55, 0.18, 4.20));
    expEnv(ringG.gain, t0, 0.002, 0.08, p.ringAmt, 0.0001, clamp(0.25 + p.dur*0.60, 0.18, 4.60));
    expEnv(crackG.gain, t0, 0.001, 0.10, p.crackle, 0.0001, clamp(0.18 + p.dur*0.35, 0.15, 3.20));

    const mixN = ctx.createGain(); mixN.gain.value = p.noise;
    const mixB = ctx.createGain(); mixB.gain.value = 0.80;

    n.connect(lp); lp.connect(mixN);
    boom.connect(boomG); boomG.connect(mixB);

    const ringSh = ctx.createWaveShaper();
    ringSh.curve = makeDriveCurve(lerp(5, 700, 0.6));
    ringSh.oversample = "2x";
    ring.connect(ringSh); ringSh.connect(ringG);

    crack.connect(hp); hp.connect(crackG);

    mixN.connect(g);
    mixB.connect(g);
    ringG.connect(g);
    crackG.connect(g);

    g.connect(out);
    connectToMaster(out);

    n.start(t0);      n.stop(tEnd + 0.08);
    boom.start(t0);   boom.stop(tEnd + 0.08);
    ring.start(t0);   ring.stop(tEnd + 0.08);
    crack.start(t0);  crack.stop(tEnd + 0.08);

    scheduleStopDisconnect(out, tEnd + 0.40);
  }

  function playHyperspace(){
    const p = patch.hyperspace;
    const t0 = now();

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0.0001;

    const n = noiseSource();
    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(p.whooshLP0, t0);
    lp.frequency.exponentialRampToValueAtTime(Math.max(60, p.whooshLP1), t0 + p.whooshTime);
    lp.Q.value = 0.8;

    const nG = ctx.createGain(); nG.gain.value = 0.65;

    const osc = ctx.createOscillator();
    osc.type = "sawtooth";
    osc.frequency.setValueAtTime(p.tone0, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(20, p.tone1), t0 + p.toneTime);

    const sh = ctx.createWaveShaper();
    sh.curve = makeDriveCurve(lerp(5, 1100, p.edge));
    sh.oversample = "2x";

    const oG = ctx.createGain(); oG.gain.value = 0.40;

    const mix = ctx.createGain();
    n.connect(lp); lp.connect(nG); nG.connect(mix);
    osc.connect(sh); sh.connect(oG); oG.connect(mix);

    const fx = feedbackDelay(mix, p.delayT, p.delayFb, p.wet);

    const sustain = clamp(lerp(0.10, 0.34, clamp(p.dur/3.0, 0, 1)), 0.10, 0.38);
    const tEnd = expEnv(g.gain, t0, 0.010, 0.10, 0.80, sustain, p.dur);

    fx.out.connect(g);
    g.connect(out);
    connectToMaster(out);

    n.start(t0);   n.stop(tEnd + 0.10);
    osc.start(t0); osc.stop(tEnd + 0.10);

    scheduleStopDisconnect(out, tEnd + 0.45);
  }

  function playTeleport(){
    const p = patch.teleport;
    const t0 = now();

    const out = ctx.createGain();
    const g = ctx.createGain(); g.gain.value = 0.0001;

    const osc = ctx.createOscillator();
    osc.type = "triangle";
    osc.frequency.setValueAtTime(p.chirp0, t0);
    osc.frequency.exponentialRampToValueAtTime(Math.max(20, p.chirp1), t0 + p.chirpTime);

    const sh = ctx.createWaveShaper();
    sh.curve = makeDriveCurve(lerp(5, 1100, p.edge));
    sh.oversample = "2x";

    const oG = ctx.createGain(); oG.gain.value = 0.60;

    const n = noiseSource();
    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = p.sparkleBP;
    bp.Q.value = p.sparkleQ;
    const nG = ctx.createGain(); nG.gain.value = p.sparkle;

    const mix = ctx.createGain();
    osc.connect(sh); sh.connect(oG); oG.connect(mix);
    n.connect(bp); bp.connect(nG); nG.connect(mix);

    const fx = feedbackDelay(mix, p.delayT, p.delayFb, p.wet);

    const sustain = tailSustainFromDur(p.dur);
    const tEnd = expEnv(g.gain, t0, 0.003, 0.06, 0.85, sustain, p.dur);

    fx.out.connect(g);
    g.connect(out);
    connectToMaster(out);

    osc.start(t0); osc.stop(tEnd + 0.08);
    n.start(t0);   n.stop(tEnd + 0.08);

    scheduleStopDisconnect(out, tEnd + 0.30);
  }

  // ----------------------------
  // UI render + wiring
  // ----------------------------
  const patchView = $("#patchView");
  const status = $("#status");

  function fmt(v){
    if (typeof v !== "number") return String(v);
    if (Math.abs(v) >= 1000) return v.toFixed(0);
    if (Math.abs(v) >= 100)  return v.toFixed(1);
    if (Math.abs(v) >= 10)   return v.toFixed(2);
    return v.toFixed(3);
  }

  function renderPatch(){
    const lines = [];
    for (const [name, obj] of Object.entries(patch)){
      lines.push(`<div style="grid-column:1 / -1;color:#eafdf4;margin:6px 0 2px 0;">${name.toUpperCase()}</div>`);
      for (const [k,v] of Object.entries(obj)){
        lines.push(`<div>${k}</div><div>${fmt(v)}</div>`);
      }
      lines.push(`<div style="grid-column:1 / -1;height:1px;background:rgba(255,255,255,.06);margin:8px 0;"></div>`);
    }
    patchView.innerHTML = lines.join("");
  }

  function ifReady(fn){
    if (!ctx){
      status.textContent = "Click Start Audio first (browser gesture requirement).";
      return;
    }
    fn();
  }

  function hook(){
    $("#btnStart").addEventListener("click", async () => {
      ensureAudio();
      if (ctx.state !== "running") await ctx.resume();
      status.textContent = "Audio running. Randomize All will regenerate every category.";
    });

    $("#panic").addEventListener("click", () => {
      if (!ctx) return;
      stopAll();
      status.textContent = "Stopped all voices.";
    });

    $("#master").addEventListener("input", (e) => {
      $("#masterVal").textContent = (+e.target.value).toFixed(2);
      if (masterGain) masterGain.gain.value = +e.target.value;
    });

    $("#crush").addEventListener("input", (e) => {
      $("#crushVal").textContent = (+e.target.value).toFixed(2);
    });

    $("#mutAmt").addEventListener("input", (e) => {
      $("#mutAmtVal").textContent = (+e.target.value).toFixed(2);
    });

    $("#randAll").addEventListener("click", () => {
      randomizeAll();
      status.textContent = `Randomized patches (${ $("#mode").value }) — rev#${REV}.`;
    });

    $("#resetBase").addEventListener("click", () => {
      resetToBase();
      status.textContent = "Reset patch to base defaults.";
    });

    $("#laser").addEventListener("click", () => { ifReady(playLaser); });
    $("#zap").addEventListener("click", () => { ifReady(playZap); });
    $("#thrust").addEventListener("click", () => { ifReady(playThrust); });
    $("#explosion").addEventListener("click", () => { ifReady(playExplosion); });
    $("#pickup").addEventListener("click", () => { ifReady(playPickup); });
    $("#alarm").addEventListener("click", () => { ifReady(playAlarm); });

    $("#smartbomb").addEventListener("click", () => { ifReady(playSmartBomb); });
    $("#hyperspace").addEventListener("click", () => { ifReady(playHyperspace); });
    $("#teleport").addEventListener("click", () => { ifReady(playTeleport); });

    // Keyboard: 1..9 trigger, R randomize
    window.addEventListener("keydown", (e) => {
      if (e.repeat) return;
      if (e.key === "r" || e.key === "R"){ $("#randAll").click(); return; }
      const map = {
        "1":"laser","2":"zap","3":"thrust","4":"explosion","5":"pickup","6":"alarm",
        "7":"smartbomb","8":"hyperspace","9":"teleport"
      };
      if (map[e.key]) { $("#"+map[e.key]).click(); }
    });
  }

  // Init
  renderPatch();
  hook();
})();
</script>
</body>
</html>
