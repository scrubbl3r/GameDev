<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gyro Energy</title>
  <style>
    :root { --green:#7dd35f; }

    html, body {
      height: 100%;
      margin: 0;
      background: #000;
      color: var(--green);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }

    .app {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 18px 14px 20px;
      box-sizing: border-box;
      text-align: center;
      gap: 14px;
    }

    /* Big readout is now part of normal flow (no overlay), so it can't overlap */
    .bigCharge {
      font-weight: 900;
      font-size: clamp(72px, 18vw, 180px);
      letter-spacing: -0.05em;
      color: var(--green);
      line-height: 0.95;
      text-shadow: 0 0 18px rgba(125,211,95,0.16);
      margin-top: 4px;
    }
    .bigSub {
      margin-top: -6px;
      font-size: 14px;
      opacity: 0.75;
    }

    button {
      font-size: 18px;
      padding: 12px 16px;
      background: transparent;
      border: 1px solid var(--green);
      color: var(--green);
      border-radius: 10px;
    }

    .statusRow {
      font-size: 14px;
      opacity: 0.9;
      margin-top: -4px;
    }

    .panel {
      width: min(560px, 92vw);
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 6px;
    }

    .metric {
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: center;
    }
    .label {
      font-size: 16px;
    }

    .bar {
      height: 18px;
      width: 100%;
      border: 1px solid rgba(125,211,95,0.60);
      border-radius: 10px;
      overflow: hidden;
      background: rgba(125,211,95,0.08);
      box-sizing: border-box;
    }
    .fill {
      height: 100%;
      width: 0%;
      background: var(--green);
      transition: width 80ms linear;
    }

    .small {
      width: min(560px, 92vw);
      opacity: 0.75;
      font-size: 13px;
      margin-top: 2px;
      line-height: 1.35;
    }
    code {
      background: rgba(125,211,95,0.08);
      border: 1px solid rgba(125,211,95,0.35);
      padding: 2px 6px;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <main class="app">
    <div>
      <div id="bigCharge" class="bigCharge">0%</div>
      <div class="bigSub">charge</div>
    </div>

    <button id="startBtn">Start</button>
    <div class="statusRow">Status: <span id="status">idle</span></div>

    <section class="panel">
      <div class="metric">
        <div class="label">Precision: <span id="precision">0</span></div>
        <div class="bar"><div id="precisionBar" class="fill"></div></div>
      </div>

      <div class="metric">
        <div class="label">Speed: <span id="speed">0</span></div>
        <div class="bar"><div id="speedBar" class="fill"></div></div>
      </div>

      <div class="metric">
        <div class="label">Energy: <span id="energy">0</span></div>
        <div class="bar"><div id="energyBar" class="fill"></div></div>
      </div>
    </section>

    <div class="small">
      iOS requires <code>https</code> + motion permission + audio started from a button.
    </div>
  </main>

<script>
(() => {
  const startBtn = document.getElementById('startBtn');
  const statusEl = document.getElementById('status');

  const precisionEl = document.getElementById('precision');
  const speedEl = document.getElementById('speed');
  const energyEl = document.getElementById('energy');

  const precisionBar = document.getElementById('precisionBar');
  const speedBar = document.getElementById('speedBar');
  const energyBar = document.getElementById('energyBar');

  const bigChargeEl = document.getElementById('bigCharge');

  // ===========================================================================
  // SSOT TUNABLES (ADJUSTED)
  // ===========================================================================

  // Filters
  const OMEGA_LPF = 0.25;          // was 0.18 (snappier so windows fill)
  const UI_SMOOTH = 0.10;

  // Motion gate (lowered so it actually registers)
  const MIN_OMEGA = 0.08;          // was 0.25

  // SPEED: starting point (tune after)
  const SPEED_NORM = 22.0;
  const SPEED_SHAPE = 1.35;

  // Windows
  const WINDOW_SAMPLES = 48;

  // Balance
  const BALANCE_WEIGHT = 1.0;

  // Coverage thresholds (loosened)
  const COVERAGE_R_SINGLE = 0.98;  // was 0.93
  const COVERAGE_R_GOOD   = 0.70;  // was 0.42

  // Smoothness thresholds (loosened)
  const JERK_TIGHT = 25.0;         // was 10
  const JERK_LOOSE = 140.0;        // was 60

  // Energy earn/decay
  const ENERGY_GAIN  = 0.75;
  const ENERGY_DECAY = 0.16;

  // Audio mapping
  const AUDIO_GATE   = 0.06;
  const AUDIO_MIN_DB = -50;
  const AUDIO_MAX_DB = -6;
  const AUDIO_EXP    = 1.8;
  const TONE_HZ      = 220;

  // ===========================================================================
  // Helpers
  // ===========================================================================
  const clamp01 = (x) => Math.max(0, Math.min(1, x));
  const lerp = (a,b,t) => a + (b-a)*t;
  const mag3 = (x,y,z) => Math.sqrt(x*x+y*y+z*z);
  const dbToGain = (db) => Math.pow(10, db/20);

  function energyToGain(e) {
    if (e <= AUDIO_GATE) return 0;
    const x = (e - AUDIO_GATE) / (1 - AUDIO_GATE);
    const shaped = Math.pow(clamp01(x), AUDIO_EXP);
    const db = AUDIO_MIN_DB + (AUDIO_MAX_DB - AUDIO_MIN_DB) * shaped;
    return dbToGain(db);
  }

  function speedCurve(norm01) {
    const x = Math.max(0, norm01);
    return clamp01(1 - Math.exp(-SPEED_SHAPE * x));
  }

  function balanceScoreFromRMS(rmsX, rmsY, rmsZ) {
    const sum = rmsX + rmsY + rmsZ;
    if (sum < 1e-6) return 0;
    const px = rmsX / sum, py = rmsY / sum, pz = rmsZ / sum;
    const m = (px + py + pz) / 3;
    const varr = ((px-m)*(px-m) + (py-m)*(py-m) + (pz-m)*(pz-m)) / 3;
    const std = Math.sqrt(varr);
    const MAX_STD = Math.sqrt(2/9); // ~0.4714
    return clamp01(1 - (std / MAX_STD));
  }

  function coverageFromDirs(dirs) {
    if (dirs.length < 8) return 0;
    let mx=0,my=0,mz=0;
    for (const d of dirs) { mx+=d.x; my+=d.y; mz+=d.z; }
    const inv = 1 / dirs.length;
    mx*=inv; my*=inv; mz*=inv;

    const R = mag3(mx,my,mz); // 0..1 (1 = locked direction)
    const t = (COVERAGE_R_SINGLE - R) / (COVERAGE_R_SINGLE - COVERAGE_R_GOOD);
    return clamp01(t);
  }

  function smoothnessFromJerks(jerks) {
    if (jerks.length < 6) return 0;
    let acc = 0;
    for (const j of jerks) acc += j;
    const avg = acc / jerks.length;
    const t = (JERK_LOOSE - avg) / (JERK_LOOSE - JERK_TIGHT);
    return clamp01(t);
  }

  async function requestMotionPermissionIfNeeded() {
    const needs = (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function')
              || (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function');
    if (!needs) return true;

    const reqs = [];
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
      reqs.push(DeviceMotionEvent.requestPermission().then(s => s === 'granted'));
    }
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
      reqs.push(DeviceOrientationEvent.requestPermission().then(s => s === 'granted'));
    }
    const results = await Promise.all(reqs);
    return results.every(Boolean);
  }

  // ===========================================================================
  // State
  // ===========================================================================
  let running = false;
  let lastT = null;

  let ox=0, oy=0, oz=0;

  const omegaWin = [];
  const dirWin = [];
  const jerkWin = [];

  let energy = 0;
  let energyUI = 0;

  // Audio
  let audioCtx = null, osc = null, gainNode = null;

  function ensureAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    gainNode = audioCtx.createGain();
    gainNode.gain.value = 0;

    osc = audioCtx.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = TONE_HZ;

    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    osc.start();
  }

  function setAudioFromEnergy(eUI) {
    if (!gainNode) return;
    const g = energyToGain(eUI);
    const now = audioCtx.currentTime;
    gainNode.gain.cancelScheduledValues(now);
    gainNode.gain.setTargetAtTime(g, now, 0.06);
  }

  function updateUI(precisionScore, speedScore, energy01) {
    const p = Math.round(precisionScore * 100);
    const s = Math.round(speedScore * 100);
    const e = Math.round(energy01 * 100);

    precisionEl.textContent = p;
    speedEl.textContent = s;
    energyEl.textContent = e;

    precisionBar.style.width = `${p}%`;
    speedBar.style.width = `${s}%`;
    energyBar.style.width = `${e}%`;

    bigChargeEl.textContent = `${e}%`;
  }

  function onMotion(e) {
    if (!running) return;

    const t = performance.now() / 1000;
    const dt = (lastT == null) ? 0 : (t - lastT);
    lastT = t;

    const rr = e.rotationRate;
    if (!rr) return;

    const x = rr.beta ?? 0;
    const y = rr.gamma ?? 0;
    const z = rr.alpha ?? 0;

    const prevOx = ox, prevOy = oy, prevOz = oz;

    ox = lerp(ox, x, OMEGA_LPF);
    oy = lerp(oy, y, OMEGA_LPF);
    oz = lerp(oz, z, OMEGA_LPF);

    const m = mag3(ox,oy,oz);

    // Speed
    const speedRaw = m / SPEED_NORM;
    const speedScore = speedCurve(speedRaw);

    // Windows
    if (m > MIN_OMEGA) {
      omegaWin.push({x: ox, y: oy, z: oz});
      if (omegaWin.length > WINDOW_SAMPLES) omegaWin.shift();

      const inv = 1 / m;
      dirWin.push({x: ox*inv, y: oy*inv, z: oz*inv});
      if (dirWin.length > WINDOW_SAMPLES) dirWin.shift();

      if (dt > 0) {
        const dx = ox - prevOx, dy = oy - prevOy, dz = oz - prevOz;
        const jerk = mag3(dx,dy,dz) / dt;
        jerkWin.push(jerk);
        if (jerkWin.length > WINDOW_SAMPLES) jerkWin.shift();
      }
    } else {
      if (omegaWin.length) omegaWin.shift();
      if (dirWin.length) dirWin.shift();
      if (jerkWin.length) jerkWin.shift();
    }

    // Precision components
    let rmsX=0,rmsY=0,rmsZ=0;
    if (omegaWin.length) {
      let sx=0,sy=0,sz=0;
      for (const o of omegaWin) { sx += o.x*o.x; sy += o.y*o.y; sz += o.z*o.z; }
      const invN = 1 / omegaWin.length;
      rmsX = Math.sqrt(sx*invN);
      rmsY = Math.sqrt(sy*invN);
      rmsZ = Math.sqrt(sz*invN);
    }

    const balance = balanceScoreFromRMS(rmsX, rmsY, rmsZ);
    const coverage = coverageFromDirs(dirWin);
    const smooth = smoothnessFromJerks(jerkWin);

    const precisionScore = clamp01(
      smooth * lerp(1.0, balance, BALANCE_WEIGHT) * coverage
    );

    // Energy
    if (dt > 0) {
      const earn = speedScore * precisionScore;
      const delta = (ENERGY_GAIN * earn - ENERGY_DECAY) * dt;
      energy = clamp01(energy + delta);
      energyUI = lerp(energyUI, energy, UI_SMOOTH);
    }

    updateUI(precisionScore, speedScore, energyUI);

    if (audioCtx && audioCtx.state === 'running') {
      setAudioFromEnergy(energyUI);
    }
  }

  async function start() {
    statusEl.textContent = 'requesting permissionâ€¦';

    if (!window.isSecureContext) {
      statusEl.textContent = 'needs https (secure context)';
      return;
    }

    const ok = await requestMotionPermissionIfNeeded();
    if (!ok) {
      statusEl.textContent = 'permission denied';
      return;
    }

    ensureAudio();
    try { await audioCtx.resume(); } catch (_) {}

    running = true;
    lastT = null;

    ox=oy=oz=0;
    omegaWin.length = 0;
    dirWin.length = 0;
    jerkWin.length = 0;

    energy = 0;
    energyUI = 0;

    setAudioFromEnergy(0);

    window.addEventListener('devicemotion', onMotion, { passive: true });
    statusEl.textContent = 'running';
    startBtn.textContent = 'Stop';
  }

  function stop() {
    running = false;
    window.removeEventListener('devicemotion', onMotion);

    if (audioCtx && gainNode) {
      const now = audioCtx.currentTime;
      gainNode.gain.cancelScheduledValues(now);
      gainNode.gain.setTargetAtTime(0, now, 0.05);
    }

    statusEl.textContent = 'stopped';
    startBtn.textContent = 'Start';
  }

  startBtn.addEventListener('click', () => {
    if (!running) start();
    else stop();
  });
})();
</script>
</body>
</html>
