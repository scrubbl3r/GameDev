<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Groove Orbit</title>
  <style>
    :root { --green:#7dd35f; }

    html, body {
        height: 100%;
        margin: 0;
        background: #000;
        color: var(--green);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        transition: background-color 80ms linear; /* keep phone glow mapping */
        touch-action: manipulation;
    }

    .app{
        height: calc(var(--vh, 1vh) * 100);
        display: grid;
        place-items: center;
    }

    /* Single centered round Start button */
    #startBtn {
      width: min(180px, 46vw);
      height: min(180px, 46vw);
      border-radius: 999px;
      border: 2px solid var(--green);
      background: rgba(0,0,0,0.15);
      color: var(--green);
      font-size: 22px;
      font-weight: 800;
      letter-spacing: 0.02em;
      box-shadow: 0 0 22px rgba(125,211,95,0.18);
      -webkit-tap-highlight-color: transparent;
    }
    #startBtn:active { transform: scale(0.98); }
    #startBtn:disabled { opacity: 0.55; }
  </style>
</head>
<body>
  <main class="app">
    <button id="startBtn">Start</button>
  </main>

  <!-- Ably JS -->
  <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>

  <!-- center button on screen hack -->
  <script>
    (function setVhUnit(){
        const root = document.documentElement;

        const set = () => {
        const vv = window.visualViewport;
        const h = (vv && vv.height) ? vv.height : window.innerHeight;
        root.style.setProperty('--vh', (h * 0.01) + 'px');
        };

        set();

        // iOS Chrome: visualViewport changes when bars show/hide & during scroll
        window.addEventListener('resize', set, { passive: true });
        window.addEventListener('orientationchange', set, { passive: true });
        if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', set, { passive: true });
        window.visualViewport.addEventListener('scroll', set, { passive: true });
        }
    })();
  </script>

  <script>
  (() => {
    // =========================================================================
    // UI (single button only)
    // =========================================================================
    const startBtn = document.getElementById('startBtn');

    // =========================================================================
    // Keep phone glow mapping (background color), driven by energy
    // =========================================================================
    const BG0 = { r: 0,   g: 0,  b: 0  };
    const BG1 = { r: 255, g: 42, b: 0  };
    function setBgFromEnergy(e01) {
      const t = Math.max(0, Math.min(1, e01));
      const r = Math.round(BG0.r + (BG1.r - BG0.r) * t);
      const g = Math.round(BG0.g + (BG1.g - BG0.g) * t);
      const b = Math.round(BG0.b + (BG1.b - BG0.b) * t);
      document.body.style.backgroundColor = `rgb(${r},${g},${b})`;
    }
    setBgFromEnergy(0);

    // =========================================================================
    // RELAY (Ably via Cloudflare Worker token) — logic preserved
    // =========================================================================
    const WORKER_BASE = "https://orb-token.mrgarthwilliams.workers.dev";
    const TOKEN_URL = WORKER_BASE + "/token";

    function parseRoom() {
      const u = new URL(window.location.href);
      const raw = (u.searchParams.get("room") || "test").trim();
      const roomCode = raw.startsWith("orb:") ? raw.slice(4) : raw;
      const channelName = "orb:" + roomCode;
      return { raw, roomCode, channelName };
    }

    let ably = null;
    let ablyChannel = null;

    const roomInfo = parseRoom();
    const room = roomInfo.channelName;
    const roomCode = roomInfo.roomCode;

    async function connectRelay() {
      try { if (ablyChannel) ablyChannel.detach(); } catch(e) {}
      try { if (ably) ably.close(); } catch(e) {}
      ably = null; ablyChannel = null;

      const authUrl =
        TOKEN_URL +
        "?room=" + encodeURIComponent(roomCode) +
        "&clientId=" + encodeURIComponent("phone-" + Math.random().toString(16).slice(2,6));

      try {
        const r = await fetch(authUrl, { method: "GET", cache: "no-store" });
        const j = await r.json();
        if (!r.ok || !j.token) return false;
      } catch (e) {
        return false;
      }

      ably = new Ably.Realtime({ authUrl, autoConnect: true });
      ablyChannel = ably.channels.get(room);
      ablyChannel.attach(() => {});
      return true;
    }

    function disconnectRelay() {
      try { if (ablyChannel) ablyChannel.detach(); } catch(e) {}
      try { if (ably) ably.close(); } catch(e) {}
      ably = null; ablyChannel = null;
    }

    // =========================================================================
    // ✅ NETWORK THROTTLE (unchanged)
    // =========================================================================
    const SEND_HZ = 12;
    const SEND_MIN_MS = 1000 / SEND_HZ;

    const EPS = {
      energy01: 0.006,
      groove01: 0.008,
      orbit01:  0.008,
      smooth01: 0.008,
      speed01:  0.008,
      shake01:  0.015,
      hz:       0.030,
    };

    let nextSendAtMs = 0;
    let lastSig = null;

    function roundN(x, n=4){
      const v = Number(x);
      if (!isFinite(v)) return 0;
      const p = Math.pow(10, n);
      return Math.round(v * p) / p;
    }

    function buildSigFromPayload(p){
      return {
        energy01: roundN(p.energy01, 4),
        groove01: roundN(p.groove01, 4),
        orbit01:  roundN(p.orbit01, 4),
        smooth01: roundN(p.smooth01, 4),
        speed01:  roundN(p.speed01, 4),
        shake01:  roundN(p.shake01, 4),
        locked:   !!p.locked,
        shakeHit: !!p.shakeHit,
        hz:       roundN(p.hz, 3),
      };
    }

    function sigChanged(sig){
      if (!lastSig) return true;

      if (sig.shakeHit && !lastSig.shakeHit) return true;
      if (sig.locked !== lastSig.locked) return true;

      if (Math.abs(sig.energy01 - lastSig.energy01) > EPS.energy01) return true;
      if (Math.abs(sig.groove01 - lastSig.groove01) > EPS.groove01) return true;
      if (Math.abs(sig.orbit01  - lastSig.orbit01 ) > EPS.orbit01 ) return true;
      if (Math.abs(sig.smooth01 - lastSig.smooth01) > EPS.smooth01) return true;
      if (Math.abs(sig.speed01  - lastSig.speed01 ) > EPS.speed01 ) return true;
      if (Math.abs(sig.shake01  - lastSig.shake01 ) > EPS.shake01 ) return true;
      if (Math.abs(sig.hz       - lastSig.hz      ) > EPS.hz      ) return true;

      return false;
    }

    function publishOrb(payload, dt, force=false) {
      if (!ablyChannel) return;

      const now = performance.now();
      if (!force && now < nextSendAtMs) return;

      const sig = buildSigFromPayload(payload);
      if (!force && !sigChanged(sig)) return;

      lastSig = sig;
      nextSendAtMs = now + SEND_MIN_MS;

      const out = {
        ...payload,

        // ✅ keep existing “debug-ish” fields
        t: roundN(payload.t, 1),
        dt: roundN(payload.dt, 4),
        wRaw: roundN(payload.wRaw, 2),
        wCap: roundN(payload.wCap, 2),
        wFilt: roundN(payload.wFilt, 2),
        cap: roundN(payload.cap, 2),

        // ✅ core meters
        energy01: sig.energy01,
        groove01: sig.groove01,
        orbit01:  sig.orbit01,
        smooth01: sig.smooth01,
        speed01:  sig.speed01,
        shake01:  sig.shake01,
        locked:   sig.locked,
        shakeHit: sig.shakeHit,
        hz:       sig.hz,

        // ✅ ORBIT DEBUG (numbers are already present in payload; normalize precision here)
        o_r2:      roundN(payload.o_r2, 4),
        o_r3:      roundN(payload.o_r3, 4),
        o_gate:    roundN(payload.o_gate, 4),
        o_balance: roundN(payload.o_balance, 4),
        o_couple:  roundN(payload.o_couple, 4),
      };

      ablyChannel.publish("orb", out, () => {});
    }

    // =========================================================================
    // DIAL PACK v4 — base detection (PRESERVED)
    // =========================================================================
    const OMEGA_LPF = 0.22; // was .22

    const HUNT_WINDOW_SEC   = .80; // was 1.35
    const STABLE_WINDOW_SEC = 1.60; // was 3.10

    const MIN_WINDOW_SAMPLES = 28;  // was 55
    const MAX_WINDOW_SAMPLES = 260;

    const MIN_OMEGA = 0.02;

    const LOCK_ON  = 0.30;
    const LOCK_OFF = 0.22;

    const MIN_HZ = 0.55;
    const MAX_HZ = 2.30;

    const JERK_TIGHT = 220.0;
    const JERK_LOOSE = 2600.0;

    // =========================================================================
    // ✅ ORBIT v2.1 — COUPLED LISS / “TRICKS WHILE LEVITATING”
    // - Direction-normalized omega (so orbit is about geometry, not force)
    // - Orbit only counts inside a stability envelope (smooth+groove+speed)
    // - Orbit is explicitly anti-shake (shake suppresses orbit charge)
    // =========================================================================
    const ORBIT_FLOOR = 0.25;

    const ORBIT_BALANCE_POW = 1.80;

    const ORBIT_COUPLE_GAIN = 1.9;
    const ORBIT_COUPLE_POW  = 1.6;

    const ORBIT_AX2_MIN = 0.16;
    const ORBIT_AX3_MIN = 0.08;

    const ORBIT_AX2_POW = 1.6;
    const ORBIT_AX3_POW = 1.3;

    const ORBIT_GATE_POW = 1.0;
    const ORBIT_GATE_FLOOR = 0.06;

    // UI shaping for published orbit01 (meter feel)
    const ORBIT_UI_EXP   = 0.40;  // was 0.55  (lift small values)
    const ORBIT_UI_GAIN  = 8.0;   // NEW       (4..10 typical)
    const ORBIT_UI_FLOOR = 0.02;  // NEW       (tiny visible floor once alive)

    // ✅ “tricks while levitating” envelope (loosened slightly)
    const ORBIT_GROOVE_MIN   = 0.22;  // was 0.26
    const ORBIT_SMOOTH_MIN   = 0.22;  // was 0.28
    const ORBIT_SPEED_MIN01  = 0.08;  // was 0.10
    const ORBIT_ENV_POW      = 1.00;  // was 1.25

    // ✅ anti-shake suppression (orbit is not brute force) (softened slightly)
    const ORBIT_ANTISHAKE_POW = 1.4;  // was 2.2

    const ENERGY_GAIN_LOCKED = 1.25;
    const ENERGY_GAIN_FREE   = 0.65;

    const ENERGY_DECAY       = 0.040;

    const UI_SMOOTH   = 0.10;
    const LOCK_SMOOTH = 0.14;

    const GRACE_SEC = 0.75;

    const RECENTER_SEC = 0.85;
    const RECENTER_GROOVE_MAX = 0.22;

    const NORM_ALPHA = 0.10;

    // ============================================================================
    // SPEED METER — tuned for “force” (rotationRate magnitude, deg/sec)
    // ============================================================================
    const SPEED_DEAD_DPS = 8.0;
    const SPEED_CAP_DPS  = 360.0;

    const SPEED_EMA_CUTOFF_FAST_HZ = 1.5;
    const SPEED_EMA_CUTOFF_SLOW_HZ = .10;

    const SPEED_ADAPT_START_DPS = 18.0;
    const SPEED_ADAPT_END_DPS   = 130.0;

    const SPEED_ADAPT_POW = 1.0;

    const SPEED_NORM_DPS = 300.0;
    const SPEED_MAP_POW  = 1.10;

    const SPEED_ATTACK_HZ  = 5.0;
    const SPEED_RELEASE_HZ = 8.0;

    // =========================================================================
    // SSOT MOBILE 2.0 — ENERGY MODEL
    // =========================================================================
    const GROOVE_EXP = 0.70;
    const SMOOTH_EXP = 0.70;
    const ORBIT_EXP  = 1.00;

    const EARN_SCALE = 1.00;

    const COAST_QUALITY_MIN  = 0.28;
    const COAST_DECAY_MULT   = 0.65;

    // =========================================================================
    // ✅ ANTI-EXPLOIT: SMOOTH KILL SWITCH
    // =========================================================================
    const SMOOTH_KILL_THRESH     = 0.12;
    const SMOOTH_KILL_DECAY_MULT = 3.25;
    const SMOOTH_KILL_UNLOCK     = true;

    // =========================================================================
    // DISRUPTOR METER v1 — SHAKE
    // =========================================================================
    const SHAKE_BASELINE_HZ   = 0.65;
    const SHAKE_DEADZONE     = 0.85;
    const SHAKE_GAIN         = 3.20;
    const SHAKE_DECAY        = 2.10;
    const SHAKE_HIT_THRESH   = 0.85;
    const SHAKE_ARM_THRESH   = 0.65;
    const SHAKE_COOLDOWN_SEC = 0.55;
    const SHAKE_CADENCE_SEC  = 0.28;
    const SHAKE_SPIKE_GATE   = 2.2;

    // =========================================================================
    // AUDIO MAPPING (preserved)
    // =========================================================================
    const AUDIO_GATE   = 0.02;
    const AUDIO_MIN_DB = -42;
    const AUDIO_MAX_DB = -6;
    const AUDIO_EXP    = 1.15;

    const MASTER_GAIN  = 2.2;

    const TONE_BASE_HZ    = 180;
    const TONE_MAX_ADD_HZ = 220;

    // =========================================================================
    // Helpers
    // =========================================================================
    const clamp01 = (x) => Math.max(0, Math.min(1, x));
    const lerp = (a,b,t) => a + (b-a)*t;
    const mag3 = (x,y,z) => Math.sqrt(x*x+y*y+z*z);
    const dbToGain = (db) => Math.pow(10, db/20);

    function alphaFromCutoff(dt, cutoffHz){
      const tau = 1 / (2 * Math.PI * cutoffHz);
      return 1 / (1 + tau / Math.max(1e-4, dt));
    }

    const invLerp01 = (a, b, v) => {
      if (Math.abs(b - a) < 1e-9) return 0;
      return clamp01((v - a) / (b - a));
    };

    function median(arr) {
      if (!arr.length) return 0;
      const a = arr.slice().sort((x,y) => x - y);
      const mid = (a.length - 1) / 2;
      const lo = Math.floor(mid), hi = Math.ceil(mid);
      return (a[lo] + a[hi]) / 2;
    }

    function energyToGain(e) {
      if (e <= AUDIO_GATE) return 0;
      const x = (e - AUDIO_GATE) / (1 - AUDIO_GATE);
      const shaped = Math.pow(clamp01(x), AUDIO_EXP);
      const db = AUDIO_MIN_DB + (AUDIO_MAX_DB - AUDIO_MIN_DB) * shaped;
      return dbToGain(db);
    }

    function eigenvaluesSym3(m00,m01,m02,m11,m12,m22) {
      let a00=m00, a01=m01, a02=m02, a11=m11, a12=m12, a22=m22;

      const iters = 10;
      for (let k=0;k<iters;k++) {
        let p=0,q=1;
        let apq = Math.abs(a01);
        const a02abs = Math.abs(a02);
        const a12abs = Math.abs(a12);
        if (a02abs > apq) { apq = a02abs; p=0; q=2; }
        if (a12abs > apq) { apq = a12abs; p=1; q=2; }
        if (apq < 1e-12) break;

        let app, aqq, apqv;
        if (p===0 && q===1) { app=a00; aqq=a11; apqv=a01; }
        else if (p===0 && q===2) { app=a00; aqq=a22; apqv=a02; }
        else { app=a11; aqq=a22; apqv=a12; }

        const phi = 0.5 * Math.atan2(2*apqv, (aqq - app));
        const c = Math.cos(phi);
        const s = Math.sin(phi);

        function rot(xp, xq) { return [c*xp - s*xq, s*xp + c*xq]; }

        const appNew = c*c*app - 2*s*c*apqv + s*s*aqq;
        const aqqNew = s*s*app + 2*s*c*apqv + c*c*aqq;

        if (p===0 && q===1) {
          const [a02n, a12n] = rot(a02, a12);
          a02=a02n; a12=a12n;
          a00=appNew; a11=aqqNew; a01=0;
        } else if (p===0 && q===2) {
          const [a01n, a12n] = rot(a01, a12);
          a01=a01n; a12=a12n;
          a00=appNew; a22=aqqNew; a02=0;
        } else {
          const [a01n, a02n] = rot(a01, a02);
          a01=a01n; a02=a02n;
          a11=appNew; a22=aqqNew; a12=0;
        }
      }

      let l1=a00, l2=a11, l3=a22;
      if (l1 < l2) [l1,l2]=[l2,l1];
      if (l2 < l3) [l2,l3]=[l3,l2];
      if (l1 < l2) [l1,l2]=[l2,l1];
      return [l1,l2,l3];
    }

    function autocorrPeak(signal, dt) {
      const n = signal.length;
      if (n < 24) return {peak: 0, lag: 0, hz: 0};

      let mean=0;
      for (let i=0;i<n;i++) mean += signal[i];
      mean /= n;

      let varr=0;
      for (let i=0;i<n;i++) {
        const d = signal[i]-mean;
        varr += d*d;
      }
      if (varr < 1e-9) return {peak: 0, lag: 0, hz: 0};

      const minLag = Math.max(2, Math.floor(1/(MAX_HZ*dt)));
      const maxLag = Math.min(n-3, Math.floor(1/(MIN_HZ*dt)));

      let best = -1;
      let bestLag = 0;

      for (let lag=minLag; lag<=maxLag; lag++) {
        let c=0;
        for (let i=0;i<n-lag;i++) {
          c += (signal[i]-mean) * (signal[i+lag]-mean);
        }
        const r = c / varr;
        if (r > best) { best = r; bestLag = lag; }
      }

      const hz = bestLag > 0 ? (1/(bestLag*dt)) : 0;
      return {peak: clamp01(best), lag: bestLag, hz};
    }

    function smoothnessFromJerk(avgJerk) {
      const t = (JERK_LOOSE - avgJerk) / (JERK_LOOSE - JERK_TIGHT);
      return clamp01(t);
    }

    // =========================================================================
    // ✅ ORBIT helpers
    // =========================================================================
    function covOmega3(vecs) {
      const n = vecs.length;
      if (n < 10) return {xx:0,xy:0,xz:0,yy:0,yz:0,zz:0, trace:0};

      let mx=0,my=0,mz=0;
      for (const v of vecs) { mx+=v.x; my+=v.y; mz+=v.z; }
      mx/=n; my/=n; mz/=n;

      let xx=0,xy=0,xz=0,yy=0,yz=0,zz=0;
      for (const v of vecs) {
        const x=v.x-mx, y=v.y-my, z=v.z-mz;
        xx += x*x; xy += x*y; xz += x*z;
        yy += y*y; yz += y*z; zz += z*z;
      }
      const inv = 1/(n-1);
      xx*=inv; xy*=inv; xz*=inv; yy*=inv; yz*=inv; zz*=inv;
      return {xx,xy,xz,yy,yz,zz, trace:(xx+yy+zz)};
    }

    // Base orbit from covariance (geometry) — returns the *raw* ingredients
    function orbitFromOmegaCov(cov) {
      const eps = 1e-12;
      const tr = cov.trace;
      if (tr < 1e-12) {
        return { core01: 0, r2:0, r3:0, planeGate:0, balance:0, couple:0 };
      }

      const [l1,l2,l3] = eigenvaluesSym3(cov.xx,cov.xy,cov.xz,cov.yy,cov.yz,cov.zz);
      const s = (l1 + l2 + l3) + eps;

      const r2 = clamp01(l2 / (l1 + eps));
      const r3 = clamp01(l3 / (l1 + eps));

      const g2 = Math.pow(
        clamp01((r2 - ORBIT_AX2_MIN) / (1 - ORBIT_AX2_MIN)),
        ORBIT_AX2_POW
      );

      const g3 = Math.pow(
        clamp01((r3 - ORBIT_AX3_MIN) / (1 - ORBIT_AX3_MIN)),
        ORBIT_AX3_POW
      );

      // plane/tri-axis gate (pure geometry)
      let planeGate = clamp01(g2 * g3);
      planeGate = ORBIT_GATE_FLOOR + (1 - ORBIT_GATE_FLOOR) * planeGate;
      planeGate = Math.pow(planeGate, ORBIT_GATE_POW);

      // Balance (entropy)
      const p1 = Math.max(eps, l1 / s);
      const p2 = Math.max(eps, l2 / s);
      const p3 = Math.max(eps, l3 / s);
      const H  = -(p1*Math.log(p1) + p2*Math.log(p2) + p3*Math.log(p3));
      const Hn = clamp01(H / Math.log(3));
      const balance = Math.pow(Hn, ORBIT_BALANCE_POW);

      // Coupling (off-diagonal energy)
      const coupleRaw = (Math.abs(cov.xy) + Math.abs(cov.xz) + Math.abs(cov.yz)) / (tr + eps);
      const couple = Math.pow(clamp01(coupleRaw * ORBIT_COUPLE_GAIN), ORBIT_COUPLE_POW);

      // Core “lissajousness”
      const core01 = clamp01(balance * couple);

      return { core01, r2, r3, planeGate, balance, couple };
    }

    // ✅ stability envelope gate (tricks while levitating)
    function orbitEnvelopeGate({ groove01, smooth01, speed01, shake01 }) {
      // must be moving, smooth, and groovy enough
      const g = Math.pow(clamp01((groove01 - ORBIT_GROOVE_MIN) / (1 - ORBIT_GROOVE_MIN)), ORBIT_ENV_POW);
      const s = Math.pow(clamp01((smooth01 - ORBIT_SMOOTH_MIN) / (1 - ORBIT_SMOOTH_MIN)), ORBIT_ENV_POW);
      const v = Math.pow(clamp01((speed01  - ORBIT_SPEED_MIN01) / (1 - ORBIT_SPEED_MIN01)), ORBIT_ENV_POW);

      // anti-shake: orbit is NOT brute force
      const anti = Math.pow(1 - clamp01(shake01), ORBIT_ANTISHAKE_POW);

      return clamp01(g * s * v * anti);
    }

    function computeAvg(arr) {
      if (!arr.length) return 0;
      let s=0;
      for (const x of arr) s+=x;
      return s/arr.length;
    }

    function trimToWindow(dtMean, targetSec, omegaMag, omegaNorm, omegaVec, jerkBuf, dtBuf) {
      let targetN = dtMean > 1e-4 ? Math.round(targetSec / dtMean) : MAX_WINDOW_SAMPLES;
      targetN = Math.max(MIN_WINDOW_SAMPLES, Math.min(MAX_WINDOW_SAMPLES, targetN));

      while (omegaMag.length  > targetN) omegaMag.shift();
      while (omegaNorm.length > targetN) omegaNorm.shift();
      while (omegaVec.length  > targetN) omegaVec.shift();
      while (jerkBuf.length   > targetN) jerkBuf.shift();
      while (dtBuf.length     > targetN) dtBuf.shift();

      return targetN;
    }

    // =========================================================================
    // ✅ Meter continuity (logic preserved; no UI)
    // =========================================================================
    const METER_HOLD_SEC = 0.55;
    const METER_FADE_HZ  = 3.0;

    // =========================================================================
    // State
    // =========================================================================
    let running = false;
    let lastT = null;

    let ox=0, oy=0, oz=0;

    const omegaMag  = [];
    const omegaNorm = [];
    const omegaVec  = [];   // ✅ stores DIRECTION-NORMALIZED omega (unit vectors)
    const jerkBuf   = [];
    const dtBuf     = [];

    let emaMean = 0;
    let emaVar  = 1;

    let lock = false;
    let lockStrength = 0;
    let grooveHz = 0;

    let graceLeft = 0;
    let recenterBadTime = 0;

    let energy = 0;
    let energyUI = 0;

    // ✅ SPEED v0 state (deg/s)
    let mSpeedEMA = 0;
    let speedOut  = 0;

    // continuity memory for meters (NOT speed)
    let meterHoldLeft = 0;
    let lastGrooveUI = 0;
    let lastOrbitUI  = 0;
    let lastSmoothUI = 0;

    // SHAKE state
    let shake01 = 0;
    let accelBaseMag = 9.81;
    let shakeCooldownLeft = 0;
    let lastSpikeTime = -1e9;
    let hadRecentSpike = false;

    let audioCtx = null, osc = null, gainNode = null;

    function ensureAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      gainNode = audioCtx.createGain();
      gainNode.gain.value = 0;

      osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = TONE_BASE_HZ;

      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      osc.start();
    }

    function setAudio(eUI, groove, locked) {
      if (!audioCtx || !gainNode || !osc) return;

      const gBase = energyToGain(clamp01(eUI));
      const gGroove = locked ? (0.30 + 0.70*groove) : (0.08 + 0.22*groove);
      const g = MASTER_GAIN * gBase * gGroove;

      const f = TONE_BASE_HZ
              + TONE_MAX_ADD_HZ * (locked ? groove : 0.30*groove)
              + 60 * clamp01(eUI);

      const now = audioCtx.currentTime;
      gainNode.gain.cancelScheduledValues(now);
      gainNode.gain.setTargetAtTime(g, now, 0.06);

      osc.frequency.cancelScheduledValues(now);
      osc.frequency.setTargetAtTime(f, now, 0.06);
    }

    function flushHistorySoft() {
      const keep = Math.min(18, omegaMag.length);
      omegaMag.splice(0, Math.max(0, omegaMag.length - keep));
      omegaNorm.splice(0, Math.max(0, omegaNorm.length - keep));
      omegaVec.splice(0, Math.max(0, omegaVec.length - keep));
      jerkBuf.splice(0, Math.max(0, jerkBuf.length - keep));
      dtBuf.splice(0, Math.max(0, dtBuf.length - keep));
    }

    function meterHoldOrFade(dt) {
      if (dt > 0) meterHoldLeft = Math.max(0, meterHoldLeft - dt);

      const dtFade = Math.max(1e-3, dt || computeAvg(dtBuf.slice(-50)) || 1/60);
      const aFade = alphaFromCutoff(dtFade, METER_FADE_HZ);
      const holding = meterHoldLeft > 0;

      const grooveOut = holding ? lastGrooveUI : (1 - aFade) * lastGrooveUI;
      const orbitOut  = holding ? lastOrbitUI  : (1 - aFade) * lastOrbitUI;
      const smoothOut = holding ? lastSmoothUI : (1 - aFade) * lastSmoothUI;

      lastGrooveUI = grooveOut;
      lastOrbitUI  = orbitOut;
      lastSmoothUI = smoothOut;

      return { grooveOut, orbitOut, smoothOut };
    }

    function updateSpeedV0(wRawDps, dt) {
      const dtSafe = Math.max(1e-3, dt || 1/60);

      const wRaw = Math.max(0, wRawDps || 0);
      const cap  = SPEED_CAP_DPS;
      const wCap = Math.min(wRaw, cap);

      const wDz = Math.max(0, wCap - SPEED_DEAD_DPS);

      const denom = Math.max(1e-6, (SPEED_ADAPT_END_DPS - SPEED_ADAPT_START_DPS));
      let tAdapt = (wDz - SPEED_ADAPT_START_DPS) / denom;
      tAdapt = clamp01(tAdapt);
      tAdapt = Math.pow(tAdapt, SPEED_ADAPT_POW);

      const cutoffHz = lerp(SPEED_EMA_CUTOFF_FAST_HZ, SPEED_EMA_CUTOFF_SLOW_HZ, tAdapt);
      const aE = alphaFromCutoff(dtSafe, cutoffHz);

      mSpeedEMA = (mSpeedEMA === 0) ? wDz : ((1 - aE) * mSpeedEMA + aE * wDz);
      const wFilt = mSpeedEMA;

      const n = clamp01(wFilt / SPEED_NORM_DPS);
      const target = Math.pow(n, SPEED_MAP_POW);

      const aAtk = alphaFromCutoff(dtSafe, SPEED_ATTACK_HZ);
      const aRel = alphaFromCutoff(dtSafe, SPEED_RELEASE_HZ);
      const a = (target >= speedOut) ? aAtk : aRel;
      speedOut = (1 - a) * speedOut + a * target;

      return { cap, dt: dtSafe, wRaw, wCap, wDz, wFilt, speed: speedOut, cutoffHz, tAdapt };
    }

    function updateShake(e, t, dt){
      const acc = e.accelerationIncludingGravity || e.acceleration;
      if (!acc) {
        if (dt > 0) shake01 = Math.max(0, shake01 - SHAKE_DECAY * dt);
        if (dt > 0) shakeCooldownLeft = Math.max(0, shakeCooldownLeft - dt);
        return { shake01, shakeHit:false, spike:0, amag:0 };
      }

      const ax = Number(acc.x) || 0;
      const ay = Number(acc.y) || 0;
      const az = Number(acc.z) || 0;
      const amag = mag3(ax, ay, az);

      const dtSafe = Math.max(1e-3, dt || 1/60);

      const aBase = alphaFromCutoff(dtSafe, SHAKE_BASELINE_HZ);
      accelBaseMag = (isFinite(accelBaseMag) ? accelBaseMag : amag);
      accelBaseMag = (1 - aBase) * accelBaseMag + aBase * amag;

      const rawSpike = Math.abs(amag - accelBaseMag);
      const spike = Math.max(0, rawSpike - SHAKE_DEADZONE);

      if (spike > SHAKE_SPIKE_GATE) {
        if ((t - lastSpikeTime) <= SHAKE_CADENCE_SEC) hadRecentSpike = true;
        lastSpikeTime = t;
      }
      if ((t - lastSpikeTime) > SHAKE_CADENCE_SEC) hadRecentSpike = false;

      shake01 = clamp01(shake01 + spike * SHAKE_GAIN * dtSafe - SHAKE_DECAY * dtSafe);

      shakeCooldownLeft = Math.max(0, shakeCooldownLeft - dtSafe);

      let shakeHit = false;
      const armed = (shake01 >= SHAKE_ARM_THRESH);
      const cadenceOk = hadRecentSpike;
      if (armed && cadenceOk && shakeCooldownLeft <= 0 && shake01 >= SHAKE_HIT_THRESH) {
        shakeHit = true;
        shakeCooldownLeft = SHAKE_COOLDOWN_SEC;
        shake01 = Math.max(0, shake01 - 0.40);
      }

      return { shake01, shakeHit, spike, amag };
    }

    function onMotion(e) {
      if (!running) return;

      const t = performance.now() / 1000;
      const dt = (lastT == null) ? 0 : (t - lastT);
      lastT = t;

      if (dt > 0) dtBuf.push(dt);

      const sh = updateShake(e, t, dt);
      const rr = e.rotationRate;

      // if no rr, still coast + publish
      if (!rr) {
        const dtMean = Math.max(1e-3, computeAvg(dtBuf.slice(-50)) || 1/60);
        const dtForFilter = (dt > 0) ? dt : dtMean;
        const sv = updateSpeedV0(0, dtForFilter);

        if (dt > 0) {
          energy = Math.max(0, energy - ENERGY_DECAY * dt);
          energyUI = lerp(energyUI, energy, UI_SMOOTH);
        }

        const held = meterHoldOrFade(dt);

        publishOrb({
          room,
          t: performance.now(),
          dt: sv.dt,
          wRaw: sv.wRaw,
          wCap: sv.wCap,
          wFilt: sv.wFilt,
          cap: sv.cap,
          energy01: energyUI,
          groove01: held.grooveOut,
          orbit01: held.orbitOut,
          smooth01: held.smoothOut,
          speed01: sv.speed,
          shake01: sh.shake01,
          shakeHit: sh.shakeHit,
          locked: false,
          hz: 0,

          o_r2: 0, o_r3: 0, o_gate: 0, o_balance: 0, o_couple: 0
        }, dt);

        setBgFromEnergy(clamp01(energyUI));
        setAudio(energyUI, held.grooveOut, false);
        return;
      }

      const x = rr.beta ?? 0;
      const y = rr.gamma ?? 0;
      const z = rr.alpha ?? 0;

      const prevOx=ox, prevOy=oy, prevOz=oz;

      ox = lerp(ox, x, OMEGA_LPF);
      oy = lerp(oy, y, OMEGA_LPF);
      oz = lerp(oz, z, OMEGA_LPF);

      const mStability = mag3(ox,oy,oz);
      const dtMean = Math.max(1e-3, computeAvg(dtBuf.slice(-50)));
      const dtForFilter = (dt > 0) ? dt : dtMean;

      const wRaw = mag3(x, y, z);
      const sv = updateSpeedV0(wRaw, dtForFilter);

      if (dt > 0) graceLeft = Math.max(0, graceLeft - dt);

      if (mStability > MIN_OMEGA) {
        omegaMag.push(mStability);

        const d0 = mStability - emaMean;
        emaMean = emaMean + NORM_ALPHA * d0;

        const d2 = (mStability - emaMean);
        emaVar = emaVar + NORM_ALPHA * (d2*d2 - emaVar);

        const rms = Math.sqrt(Math.max(1e-6, emaVar));
        omegaNorm.push((mStability - emaMean) / rms);

        // ✅ ORBIT v2.1: store DIRECTION-NORMALIZED omega (unit vector)
        const invM = 1 / Math.max(1e-6, mStability);
        omegaVec.push({ x: ox*invM, y: oy*invM, z: oz*invM });

        if (dt > 0) {
          const dtSafe = Math.max(dt, dtMean * 0.5, 1/120);
          jerkBuf.push(mag3(ox-prevOx, oy-prevOy, oz-prevOz) / dtSafe);
        }
      } else {
        if (omegaMag.length) omegaMag.shift();
        if (omegaNorm.length) omegaNorm.shift();
        if (omegaVec.length) omegaVec.shift();
        if (jerkBuf.length)  jerkBuf.shift();
      }

      const inStableMode = lock || graceLeft > 0;
      const windowSec = inStableMode ? STABLE_WINDOW_SEC : HUNT_WINDOW_SEC;
      const nTarget = trimToWindow(dtMean, windowSec, omegaMag, omegaNorm, omegaVec, jerkBuf, dtBuf);

      if (omegaNorm.length < Math.min(MIN_WINDOW_SAMPLES, nTarget)) {
        if (dt > 0) {
          energy = Math.max(0, energy - ENERGY_DECAY * dt);
          energyUI = lerp(energyUI, energy, UI_SMOOTH);
        }

        const held = meterHoldOrFade(dt);

        publishOrb({
          room,
          t: performance.now(),
          dt: sv.dt,
          wRaw: sv.wRaw,
          wCap: sv.wCap,
          wFilt: sv.wFilt,
          cap: sv.cap,
          energy01: energyUI,
          groove01: held.grooveOut,
          orbit01: held.orbitOut,
          smooth01: held.smoothOut,
          speed01: sv.speed,
          shake01: sh.shake01,
          shakeHit: sh.shakeHit,
          locked: false,
          hz: 0,

          o_r2: 0, o_r3: 0, o_gate: 0, o_balance: 0, o_couple: 0
        }, dt);

        setBgFromEnergy(clamp01(energyUI));
        setAudio(energyUI, held.grooveOut, false);
        return;
      }

      const ac = autocorrPeak(omegaNorm, dtMean);
      lockStrength = lerp(lockStrength, ac.peak, LOCK_SMOOTH);
      grooveHz = ac.hz;

      const jerkWindow = jerkBuf.slice(-Math.min(jerkBuf.length, 70));
      const avgJerk = median(jerkWindow);
      const smoothScore = smoothnessFromJerk(avgJerk);

      // ✅ ORBIT v2.1 compute (raw ingredients)
      const omegaCov = covOmega3(omegaVec);
      const oRaw = orbitFromOmegaCov(omegaCov);

      // ✅ envelope gate: only “tricks” inside stable levitation, and anti-shake
      const envGate = orbitEnvelopeGate({
        groove01: lockStrength,
        smooth01: smoothScore,
        speed01:  sv.speed,
        shake01:  sh.shake01
      });

      // Combine: liss core * plane gate * envelope gate
      const shapedCore = clamp01(oRaw.core01 * oRaw.planeGate * envGate);

      // Energy uses ORBIT_FLOOR..1
      const orbitBonus = ORBIT_FLOOR + (1 - ORBIT_FLOOR) * shapedCore;

      // UI published is 0..1, shaped + scaled for visibility
      let orbitUI = Math.pow(shapedCore, ORBIT_UI_EXP);
      orbitUI = clamp01(orbitUI * ORBIT_UI_GAIN);
      if (orbitUI > 0) orbitUI = Math.max(orbitUI, ORBIT_UI_FLOOR);

      meterHoldLeft = METER_HOLD_SEC;
      lastGrooveUI = lockStrength;
      lastOrbitUI  = orbitUI;
      lastSmoothUI = smoothScore;

      if (!lock) {
        if (lockStrength > LOCK_ON) { lock = true; graceLeft = 0; }
      } else {
        if (lockStrength < LOCK_OFF) { lock = false; graceLeft = GRACE_SEC; }
      }

      const inGrace = (!lock && graceLeft > 0);
      if (inGrace && lockStrength > LOCK_ON) { lock = true; graceLeft = 0; }

      if (dt > 0) {
        const badGroove = lockStrength <= RECENTER_GROOVE_MAX;
        const notLockedNow = !lock;
        if (badGroove && notLockedNow) recenterBadTime += dt;
        else recenterBadTime = Math.max(0, recenterBadTime - 1.5*dt);

        if (recenterBadTime >= RECENTER_SEC) {
          flushHistorySoft();
          recenterBadTime = 0;
        }
      }

      if (dt > 0) {
        const grooveTerm = Math.pow(clamp01(lockStrength), GROOVE_EXP);
        const smoothTerm = Math.pow(clamp01(smoothScore), SMOOTH_EXP);
        const orbitTerm  = Math.pow(clamp01(orbitBonus),  ORBIT_EXP); // ✅ energy uses orbitBonus

        const qualityTerm = grooveTerm * smoothTerm;
        const earnBase = EARN_SCALE * grooveTerm * smoothTerm * orbitTerm;

        const effectivelyLocked = lock || inGrace;
        const gain = effectivelyLocked ? ENERGY_GAIN_LOCKED : ENERGY_GAIN_FREE;

        const smoothKill = (smoothScore < SMOOTH_KILL_THRESH);
        const earn = smoothKill ? 0 : (gain * earnBase);

        let decay = ENERGY_DECAY;
        if (qualityTerm >= COAST_QUALITY_MIN) decay *= COAST_DECAY_MULT;

        if (smoothKill) {
          decay *= SMOOTH_KILL_DECAY_MULT;
          if (SMOOTH_KILL_UNLOCK) { lock = false; graceLeft = 0; }
        }

        energy = Math.max(0, energy + (earn - decay) * dt);
        energyUI = lerp(energyUI, energy, UI_SMOOTH);
      }

      const lockedNow = !!(lock || inGrace);

      publishOrb({
        room,
        t: performance.now(),
        dt: sv.dt,
        wRaw: sv.wRaw,
        wCap: sv.wCap,
        wFilt: sv.wFilt,
        cap: sv.cap,
        energy01: energyUI,
        groove01: lockStrength,
        orbit01: orbitUI,
        smooth01: smoothScore,
        speed01: sv.speed,
        shake01: sh.shake01,
        shakeHit: sh.shakeHit,
        locked: lockedNow,
        hz: grooveHz,

        // ✅ ORBIT DEBUG:
        // r2/r3/balance/couple remain “shape” diagnostics.
        // o_gate now reflects the REAL “orbit availability” (planeGate * envelope gate).
        o_r2: oRaw.r2,
        o_r3: oRaw.r3,
        o_gate: clamp01(oRaw.planeGate * envGate),
        o_balance: oRaw.balance,
        o_couple: oRaw.couple
      }, dt);

      setBgFromEnergy(clamp01(energyUI));
      setAudio(energyUI, lockStrength, lockedNow);
    }

    // =========================================================================
    // iOS permission gate (UI-less)
    // =========================================================================
    async function requestMotionPermissionIfNeeded() {
      const needs = (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function')
                 || (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function');

      if (!needs) return true;

      const reqs = [];

      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        reqs.push(DeviceMotionEvent.requestPermission().then(s => s === 'granted').catch(() => false));
      }

      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        reqs.push(DeviceOrientationEvent.requestPermission().then(s => s === 'granted').catch(() => false));
      }

      const results = await Promise.all(reqs);
      return results.every(Boolean);
    }

    // =========================================================================
    // Start/Stop (button label toggles only)
    // =========================================================================
    async function start() {
      if (!window.isSecureContext) return;

      startBtn.disabled = true;
      try {
        const ok = await requestMotionPermissionIfNeeded();
        if (!ok) return;

        ensureAudio();
        try { await audioCtx.resume(); } catch(e) {}

        nextSendAtMs = 0;
        lastSig = null;
        await connectRelay(); // ok if false; can run locally

        running = true;
        lastT = null;

        ox=oy=oz=0;
        omegaMag.length  = 0;
        omegaNorm.length = 0;
        omegaVec.length  = 0;
        jerkBuf.length   = 0;
        dtBuf.length     = 0;

        emaMean = 0;
        emaVar  = 1;

        lock = false;
        lockStrength = 0;
        grooveHz = 0;

        graceLeft = 0;
        recenterBadTime = 0;

        energy = 0;
        energyUI = 0;

        mSpeedEMA = 0;
        speedOut  = 0;

        meterHoldLeft = 0;
        lastGrooveUI = 0;
        lastOrbitUI  = 0;
        lastSmoothUI = 0;

        shake01 = 0;
        accelBaseMag = 9.81;
        shakeCooldownLeft = 0;
        lastSpikeTime = -1e9;
        hadRecentSpike = false;

        setAudio(0,0,false);
        setBgFromEnergy(0);

        window.addEventListener('devicemotion', onMotion, { passive: true });
        startBtn.textContent = 'Stop';
      } finally {
        startBtn.disabled = false;
      }

      // Attempt to lock to portrait (best-effort; may fail on iOS depending on context)
      if (screen.orientation && screen.orientation.lock) {
        try { await screen.orientation.lock('portrait-primary'); }
        catch (e) { /* no-op */ }
      }
    }

    function stop() {
      running = false;
      window.removeEventListener('devicemotion', onMotion);

      if (audioCtx && gainNode) {
        const now = audioCtx.currentTime;
        gainNode.gain.cancelScheduledValues(now);
        gainNode.gain.setTargetAtTime(0, now, 0.05);
      }

      disconnectRelay();
      startBtn.textContent = 'Start';
      setBgFromEnergy(0);
    }

    startBtn.addEventListener('click', () => {
      if (!running) start();
      else stop();
    });
  })();
  </script>
</body>
</html>
