<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Groove Orbit</title>
  <style>
    :root {
      --green:#7dd35f;
      --over:#ffd400; /* bright yellow for overcharge */
    }

    html, body {
      height: 100%;
      margin: 0;
      background: #000; /* overridden dynamically */
      color: var(--green);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      transition: background-color 80ms linear;
    }

    .app {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding: 18px 14px 22px;
      box-sizing: border-box;
      text-align: center;
      gap: 14px;
    }

    .bigCharge {
      font-weight: 900;
      font-size: clamp(72px, 18vw, 180px);
      letter-spacing: -0.05em;
      color: var(--green);
      line-height: 0.95;
      text-shadow: 0 0 18px rgba(125,211,95,0.16);
      margin-top: 4px;
    }
    .bigSub {
      margin-top: -6px;
      font-size: 14px;
      opacity: 0.78;
    }

    /* overcharge styling */
    .over { color: var(--over) !important; }
    .bigCharge.over { text-shadow: 0 0 18px rgba(255, 212, 0, 0.22); }
    .fill.over { background: var(--over) !important; }

    .panel {
      width: min(560px, 92vw);
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 6px;
    }

    .metric {
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: center;
    }
    .label {
      font-size: 16px;
      display: flex;
      gap: 10px;
      align-items: baseline;
      justify-content: center;
      flex-wrap: wrap;
    }
    .label .muted {
      opacity: 0.72;
      font-size: 13px;
    }

    .bar {
      height: 18px;
      width: 100%;
      border: 1px solid rgba(125,211,95,0.60);
      border-radius: 10px;
      overflow: hidden;
      background: rgba(125,211,95,0.08);
      box-sizing: border-box;
    }
    .fill {
      height: 100%;
      width: 0%;
      background: var(--green);
      transition: width 80ms linear;
    }

    .small {
      width: min(560px, 92vw);
      opacity: 0.75;
      font-size: 13px;
      line-height: 1.35;
      margin-top: 2px;
    }
    code {
      background: rgba(125,211,95,0.08);
      border: 1px solid rgba(125,211,95,0.35);
      padding: 2px 6px;
      border-radius: 6px;
    }

    button {
      font-size: 18px;
      padding: 12px 16px;
      background: transparent;
      border: 1px solid var(--green);
      color: var(--green);
      border-radius: 10px;
      width: min(560px, 92vw);
    }
    button:disabled { opacity: 0.55; }

    /* ============================================================
       DIAGNOSTICS HUD (in-app “console”)
       ============================================================ */
    .diag {
      width: min(560px, 92vw);
      border: 1px solid rgba(125,211,95,0.35);
      background: rgba(0,0,0,0.28);
      border-radius: 12px;
      padding: 10px 10px;
      text-align: left;
      font: 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      line-height: 1.35;
    }
    .diag .row { display:flex; flex-wrap:wrap; gap:10px; align-items:baseline; }
    .diag .k { opacity:0.80; }
    .diag .v { font-weight:800; }
    .diag .ok { color:#7dffab; font-weight:900; }
    .diag .warn { color:#ffd37d; font-weight:900; }
    .diag .bad { color:#ff6b6b; font-weight:900; }
    .diag .log {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(125,211,95,0.18);
      max-height: 180px;
      overflow: auto;
      white-space: pre-wrap;
      word-break: break-word;
      color: rgba(125,211,95,0.92);
    }
    .diag .log .muted { opacity:0.70; }
  </style>
</head>
<body>
  <main class="app">
    <div>
      <div id="bigCharge" class="bigCharge">0%</div>
      <div class="bigSub">energy</div>
    </div>

    <section class="panel">
      <div class="metric">
        <div class="label">
          Groove <span id="groove">0</span>
          <span class="muted">(periodicity / lock strength)</span>
        </div>
        <div class="bar"><div id="grooveBar" class="fill"></div></div>
      </div>

      <div class="metric">
        <div class="label">
          Orbit <span id="orbit">0</span>
          <span class="muted">(multi-axis bonus)</span>
        </div>
        <div class="bar"><div id="orbitBar" class="fill"></div></div>
      </div>

      <div class="metric">
        <div class="label">
          Smooth <span id="smooth">0</span>
          <span class="muted">(low jerk)</span>
        </div>
        <div class="bar"><div id="smoothBar" class="fill"></div></div>
      </div>

      <div class="metric">
        <div class="label">
          Speed <span id="speed">0</span>
          <span class="muted">(FORCE / raw-ish)</span>
        </div>
        <div class="bar"><div id="speedBar" class="fill"></div></div>
      </div>

      <div class="metric">
        <div class="label">Energy <span id="energy">0</span></div>
        <div class="bar"><div id="energyBar" class="fill"></div></div>
      </div>

      <br>
      <button id="startBtn">Start</button>

      <div class="small">
        Requires <code>https</code> + motion permission + audio started from the button (iOS).<br>
        Relay: pass <code>?room=orb:XXXX</code> or <code>?room=XXXX</code> in the URL to pair with the game.
      </div>

      <div id="diag" class="diag" aria-label="Diagnostics">
        <div class="row">
          <span class="k">Run:</span> <span id="dRun" class="v dim">idle</span>
          <span class="k">Secure:</span> <span id="dSecure" class="v dim">?</span>
          <span class="k">Permission:</span> <span id="dPerm" class="v dim">?</span>
        </div>
        <div class="row" style="margin-top:6px;">
          <span class="k">Relay:</span> <span id="dRelay" class="v dim">idle</span>
          <span class="k">Motion:</span> <span id="dMotion" class="v dim">0</span>
          <span class="k">Last dt:</span> <span id="dDt" class="v dim">0</span>
        </div>
        <div class="row" style="margin-top:6px;">
          <span class="k">Last rr:</span> <span id="dRR" class="v dim">none</span>
        </div>

        <!-- ✅ updated: includes ω cap so we can see clamp behavior -->
        <div class="row" style="margin-top:6px;">
          <span class="k">ω raw:</span> <span id="dOmega" class="v dim">0</span>
          <span class="k">ω cap:</span> <span id="dOmegaC" class="v dim">0</span>
          <span class="k">ω filt:</span> <span id="dOmegaF" class="v dim">0</span>
          <span class="k">speed:</span> <span id="dSpeed" class="v dim">0</span>
        </div>

        <div class="row" style="margin-top:6px;">
          <span class="k">Start stage:</span> <span id="dStage" class="v dim">—</span>
        </div>
        <div class="row" style="margin-top:6px;">
          <span class="k">Last error:</span> <span id="dErr" class="v dim">—</span>
        </div>
        <div id="dLog" class="log"><span class="muted">(log)</span></div>
      </div>
    </section>
  </main>

  <!-- Ably JS -->
  <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>

  <script>
  (() => {
    // =========================================================================
    // Diagnostics helpers
    // =========================================================================
    const $ = (id) => document.getElementById(id);

    const d = {
      run: $("dRun"),
      secure: $("dSecure"),
      perm: $("dPerm"),
      relay: $("dRelay"),
      motion: $("dMotion"),
      dt: $("dDt"),
      rr: $("dRR"),
      stage: $("dStage"),
      err: $("dErr"),
      log: $("dLog"),

      omega: $("dOmega"),
      omegaC: $("dOmegaC"), // ✅ NEW
      omegaF: $("dOmegaF"),
      speed: $("dSpeed"),
    };

    const t0 = performance.now();
    function nowMs(){ return Math.round(performance.now() - t0); }

    function cls(el, c){
      el.classList.remove("ok","warn","bad","dim");
      if (c) el.classList.add(c);
    }

    function setRun(text, level="dim"){ d.run.textContent = text; cls(d.run, level); }
    function setSecure(v){ d.secure.textContent = v ? "yes" : "no"; cls(d.secure, v ? "ok" : "bad"); }
    function setPerm(text, level="dim"){ d.perm.textContent = text; cls(d.perm, level); }
    function setRelay(text, level="dim"){ d.relay.textContent = text; cls(d.relay, level); }
    function setStage(text, level="dim"){ d.stage.textContent = text; cls(d.stage, level); }
    function setErr(text, level="dim"){ d.err.textContent = text; cls(d.err, level); }

    function log(msg, obj){
      let line = `[${nowMs()}ms] ${msg}`;
      if (obj !== undefined) {
        try { line += " " + JSON.stringify(obj); }
        catch(e){ line += " " + String(obj); }
      }
      const div = document.createElement("div");
      div.textContent = line;
      d.log.appendChild(div);
      d.log.scrollTop = d.log.scrollHeight;
      console.log(line);
    }

    log("boot url=" + window.location.href);
    log("ua=" + navigator.userAgent);
    log("secureContext=" + !!window.isSecureContext);

    setSecure(!!window.isSecureContext);
    setPerm("unknown", "dim");
    setRelay("idle", "dim");
    setRun("idle", "dim");
    setStage("—", "dim");
    setErr("—", "dim");

    // =========================================================================
    // UI
    // =========================================================================
    const startBtn = document.getElementById('startBtn');
    const bigChargeEl = document.getElementById('bigCharge');

    const grooveEl = document.getElementById('groove');
    const orbitEl  = document.getElementById('orbit');
    const smoothEl = document.getElementById('smooth');
    const speedEl  = document.getElementById('speed');
    const energyEl = document.getElementById('energy');

    const grooveBar = document.getElementById('grooveBar');
    const orbitBar  = document.getElementById('orbitBar');
    const smoothBar = document.getElementById('smoothBar');
    const speedBar  = document.getElementById('speedBar');
    const energyBar = document.getElementById('energyBar');

    const BG0 = { r: 0,   g: 0,  b: 0  };
    const BG1 = { r: 255, g: 42, b: 0  };
    function setBgFromEnergy(e01) {
      const t = Math.max(0, Math.min(1, e01));
      const r = Math.round(BG0.r + (BG1.r - BG0.r) * t);
      const g = Math.round(BG0.g + (BG1.g - BG0.g) * t);
      const b = Math.round(BG0.b + (BG1.b - BG0.b) * t);
      document.body.style.backgroundColor = `rgb(${r},${g},${b})`;
    }
    setBgFromEnergy(0);

    // =========================================================================
    // RELAY (Ably via Cloudflare Worker token)
    // =========================================================================
    const WORKER_BASE = "https://orb-token.mrgarthwilliams.workers.dev";
    const TOKEN_URL = WORKER_BASE + "/token";

    function parseRoom() {
      const u = new URL(window.location.href);
      const raw = (u.searchParams.get("room") || "test").trim();
      const roomCode = raw.startsWith("orb:") ? raw.slice(4) : raw;
      const channelName = "orb:" + roomCode;
      return { raw, roomCode, channelName };
    }

    let ably = null;
    let ablyChannel = null;

    const roomInfo = parseRoom();
    const room = roomInfo.channelName;
    const roomCode = roomInfo.roomCode;

    log("room parsed", { room, roomCode });

    async function connectRelay() {
      log("connectRelay: begin", { room, roomCode });

      try { if (ablyChannel) ablyChannel.detach(); } catch(e) {}
      try { if (ably) ably.close(); } catch(e) {}
      ably = null; ablyChannel = null;

      setRelay("minting token…", "warn");

      const authUrl =
        TOKEN_URL +
        "?room=" + encodeURIComponent(roomCode) +
        "&clientId=" + encodeURIComponent("phone-" + Math.random().toString(16).slice(2,6));

      log("token authUrl", authUrl);

      try {
        const r = await fetch(authUrl, { method: "GET", cache: "no-store" });
        const j = await r.json();
        log("token preflight", { ok: r.ok, status: r.status, keys: Object.keys(j || {}) });

        if (!r.ok || !j.token) {
          setRelay("token FAILED", "bad");
          console.error("TOKEN ERROR:", r.status, j);
          setErr("token FAILED (see console)", "bad");
          return false;
        }
        setRelay("token ok, connecting…", "warn");
      } catch (e) {
        setRelay("token fetch FAILED", "bad");
        console.error("TOKEN FETCH FAILED:", e);
        setErr("token fetch FAILED: " + (e?.message || String(e)), "bad");
        return false;
      }

      ably = new Ably.Realtime({ authUrl, autoConnect: true });

      ably.connection.on("connected", () => {
        log("ably connected");
        setRelay("ably connected ✓", "ok");
      });
      ably.connection.on("failed", (st) => {
        log("ably FAILED", st);
        setRelay("ably FAILED", "bad");
        setErr("ably FAILED (see console)", "bad");
        console.error("ABLY FAILED:", st);
      });
      ably.connection.on("disconnected", (st) => {
        log("ably disconnected", st);
        setRelay("ably disconnected", "warn");
        console.warn("ABLY disconnected:", st);
      });

      ablyChannel = ably.channels.get(room);
      ablyChannel.attach((err) => {
        if (err) {
          log("channel attach FAILED", err);
          setRelay("channel attach FAILED", "bad");
          setErr("channel attach FAILED (see console)", "bad");
          console.error("CHANNEL ATTACH ERROR:", err);
        } else {
          log("channel attached " + room);
          setRelay("channel attached ✓", "ok");
        }
      });

      return true;
    }

    function disconnectRelay() {
      try { if (ablyChannel) ablyChannel.detach(); } catch(e) {}
      try { if (ably) ably.close(); } catch(e) {}
      ably = null; ablyChannel = null;
      setRelay("idle", "dim");
      log("disconnectRelay");
    }

    // Publish throttle (~25 Hz)
    const PUBLISH_HZ = 25;
    const PUBLISH_DT = 1 / PUBLISH_HZ;
    let publishAcc = 0;

    function publishOrb(payload, dt) {
      if (!ablyChannel) return;

      publishAcc += (dt || 0);
      if (publishAcc < PUBLISH_DT) return;
      publishAcc = 0;

      ablyChannel.publish("orb", payload, (err) => {
        if (err) {
          setRelay("publish error", "bad");
          setErr("publish error (see console)", "bad");
          console.error("PUBLISH ERROR:", err);
        }
      });
    }

    // =========================================================================
    // DIAL PACK v4 — base detection (PRESERVED)
    // =========================================================================
    const OMEGA_LPF = 0.22;

    const HUNT_WINDOW_SEC   = 1.35;
    const STABLE_WINDOW_SEC = 3.10;

    const MIN_WINDOW_SAMPLES = 55;
    const MAX_WINDOW_SAMPLES = 260;

    const MIN_OMEGA = 0.08;

    // OLD speed mapping constants (kept for groove lock behavior thresholds etc.)
    const SPEED_NORM  = 120.0;
    const SPEED_SHAPE = 1.20;

    const SPEED_MIN_CUTOFF = 0.20;
    const SPEED_BETA       = 0.015;
    const SPEED_D_CUTOFF   = 1.20;
    const SPEED_LOW_EXP    = 0.70;

    const SPEED_RELEASE_CUTOFF = 8.0;
    const SPEED_STOP_SNAP      = 1.0;

    // =========================================================================
    // ✅ NEW: SPEED (FORCE) — spike-resistant + fast brake
    // =========================================================================
    const SPEED_FORCE_NORM   = 180.0; // raise = gentler, lower = stronger
    const SPEED_FORCE_POW    = 1.7;   // >1 suppresses low speeds, keeps high reachable
    const SPEED_FORCE_SHAPE  = 5.2;   // higher helps reach 1.0 at high motion

    const SPEED_FORCE_LPF    = 0.55;  // fast smoothing on raw omega magnitude
    const SPEED_FORCE_DEAD   = 8.0;   // deg/s deadzone (prevents tiny noise giving “force”)

    const SPEED_FORCE_MIN_CUTOFF = 0.45;
    const SPEED_FORCE_BETA       = 0.030;
    const SPEED_FORCE_D_CUTOFF   = 1.40;

    const SPEED_FORCE_RELEASE_CUTOFF = 12.0; // fast fall when slowing

    // --- SPIKE RESIST + BRAKE (the actual “runaway train” fix) ---
    const SPEED_SPIKE_WINDOW_SEC = 0.35;
    const SPEED_SPIKE_MULT       = 2.1;
    const SPEED_SPIKE_ADD        = 18.0;
    const SPEED_BRAKE_CUTOFF     = 18.0;

    const LOCK_ON  = 0.30;
    const LOCK_OFF = 0.22;

    const MIN_HZ = 0.55;
    const MAX_HZ = 2.30;

    const JERK_TIGHT = 220.0;
    const JERK_LOOSE = 2600.0;

    const ORBIT_FLOOR      = 0.25;
    const ORBIT_STRICTNESS = 1.0;

    const ENERGY_GAIN_LOCKED = 1.25;
    const ENERGY_GAIN_FREE   = 0.65;

    const ENERGY_DECAY       = 0.040;
    const STOP_SPEED_THRESH  = 0.07;
    const STOP_DECAY_MULT    = 10.;

    const UI_SMOOTH   = 0.10;
    const LOCK_SMOOTH = 0.14;

    const GRACE_SEC = 0.75;
    const GRACE_SPEED_MIN = 0.12;

    const RECENTER_SEC = 0.85;
    const RECENTER_SPEED_MIN = 0.18;
    const RECENTER_GROOVE_MAX = 0.22;

    const NORM_ALPHA = 0.10;

    // =========================================================================
    // SSOT MOBILE 2.0 — ENERGY MODEL (INDEPENDENT PRODUCT METERS)
    // =========================================================================
    const GROOVE_EXP = 0.70;
    const SMOOTH_EXP = 0.70;
    const SPEED_EXP  = 1.00;
    const ORBIT_EXP  = 1.00;

    const EARN_SCALE = 1.00;

    const COAST_QUALITY_MIN  = 0.28;
    const COAST_DECAY_MULT   = 0.65;

    // =========================================================================
    // ✅ ANTI-EXPLOIT: SMOOTH KILL SWITCH (deal-breaker)
    // =========================================================================
    const SMOOTH_KILL_THRESH     = 0.12;
    const SMOOTH_KILL_DECAY_MULT = 3.25;
    const SMOOTH_KILL_UNLOCK     = true;

    // =========================================================================
    // DISRUPTOR METER v1 — SHAKE
    // =========================================================================
    const SHAKE_BASELINE_HZ   = 0.65;
    const SHAKE_DEADZONE     = 0.85;
    const SHAKE_GAIN         = 3.20;
    const SHAKE_DECAY        = 2.10;
    const SHAKE_HIT_THRESH   = 0.85;
    const SHAKE_ARM_THRESH   = 0.65;
    const SHAKE_COOLDOWN_SEC = 0.55;
    const SHAKE_CADENCE_SEC  = 0.28;
    const SHAKE_SPIKE_GATE   = 2.2;

    // =========================================================================
    // AUDIO MAPPING
    // =========================================================================
    const AUDIO_GATE   = 0.02;
    const AUDIO_MIN_DB = -42;
    const AUDIO_MAX_DB = -6;
    const AUDIO_EXP    = 1.15;

    const MASTER_GAIN  = 2.2;

    const TONE_BASE_HZ    = 180;
    const TONE_MAX_ADD_HZ = 220;

    // =========================================================================
    // Helpers
    // =========================================================================
    const clamp01 = (x) => Math.max(0, Math.min(1, x));
    const lerp = (a,b,t) => a + (b-a)*t;
    const mag3 = (x,y,z) => Math.sqrt(x*x+y*y+z*z);
    const dbToGain = (db) => Math.pow(10, db/20);

    function speedCurve(norm01) {
      const x = Math.max(0, norm01);
      return clamp01(1 - Math.exp(-SPEED_SHAPE * x));
    }

    function alphaFromCutoff(dt, cutoffHz){
      const tau = 1 / (2 * Math.PI * cutoffHz);
      return 1 / (1 + tau / Math.max(1e-4, dt));
    }

    // One Euro step for a scalar signal (omega magnitude) — OLD (kept for debug/compat)
    function oneEuroStep(x, dt, state){
      const dtSafe = Math.max(1e-3, dt);

      const dx = (state.xPrev == null) ? 0 : (x - state.xPrev) / dtSafe;
      state.xPrev = x;

      const aD = alphaFromCutoff(dtSafe, SPEED_D_CUTOFF);
      state.dxHat = (state.dxHat == null) ? dx : (1 - aD) * state.dxHat + aD * dx;

      const cutoff = SPEED_MIN_CUTOFF + SPEED_BETA * Math.abs(state.dxHat);

      const aX = alphaFromCutoff(dtSafe, cutoff);
      state.xHat = (state.xHat == null) ? x : (1 - aX) * state.xHat + aX * x;

      return state.xHat;
    }

    // ✅ NEW One-Euro for FORCE speed path
    function oneEuroStepForce(x, dt, state){
      const dtSafe = Math.max(1e-3, dt);

      const dx = (state.xPrev == null) ? 0 : (x - state.xPrev) / dtSafe;
      state.xPrev = x;

      const aD = alphaFromCutoff(dtSafe, SPEED_FORCE_D_CUTOFF);
      state.dxHat = (state.dxHat == null) ? dx : (1 - aD) * state.dxHat + aD * dx;

      const cutoff = SPEED_FORCE_MIN_CUTOFF + SPEED_FORCE_BETA * Math.abs(state.dxHat);

      const aX = alphaFromCutoff(dtSafe, cutoff);
      state.xHat = (state.xHat == null) ? x : (1 - aX) * state.xHat + aX * x;

      return state.xHat;
    }

    // --- Robust statistics helpers for Smooth meter ---
    function median(arr) {
      if (!arr.length) return 0;
      const a = arr.slice().sort((x,y) => x - y);
      const mid = (a.length - 1) / 2;
      const lo = Math.floor(mid), hi = Math.ceil(mid);
      return (a[lo] + a[hi]) / 2;
    }

    // ✅ rolling window helper for spike clamp
    function trimRollingWindowByTime(maxSec, hist, histDt, timeRefObj){
      while (hist.length && timeRefObj.t > maxSec) {
        timeRefObj.t -= (histDt.shift() || 0);
        hist.shift();
      }
    }

    function energyToGain(e) {
      if (e <= AUDIO_GATE) return 0;
      const x = (e - AUDIO_GATE) / (1 - AUDIO_GATE);
      const shaped = Math.pow(clamp01(x), AUDIO_EXP);
      const db = AUDIO_MIN_DB + (AUDIO_MAX_DB - AUDIO_MIN_DB) * shaped;
      return dbToGain(db);
    }

    function eigenvaluesSym3(m00,m01,m02,m11,m12,m22) {
      let a00=m00, a01=m01, a02=m02, a11=m11, a12=m12, a22=m22;

      const iters = 10;
      for (let k=0;k<iters;k++) {
        let p=0,q=1;
        let apq = Math.abs(a01);
        const a02abs = Math.abs(a02);
        const a12abs = Math.abs(a12);
        if (a02abs > apq) { apq = a02abs; p=0; q=2; }
        if (a12abs > apq) { apq = a12abs; p=1; q=2; }
        if (apq < 1e-12) break;

        let app, aqq, apqv;
        if (p===0 && q===1) { app=a00; aqq=a11; apqv=a01; }
        else if (p===0 && q===2) { app=a00; aqq=a22; apqv=a02; }
        else { app=a11; aqq=a22; apqv=a12; }

        const phi = 0.5 * Math.atan2(2*apqv, (aqq - app));
        const c = Math.cos(phi);
        const s = Math.sin(phi);

        function rot(xp, xq) { return [c*xp - s*xq, s*xp + c*xq]; }

        const appNew = c*c*app - 2*s*c*apqv + s*s*aqq;
        const aqqNew = s*s*app + 2*s*c*apqv + c*c*aqq;

        if (p===0 && q===1) {
          const [a02n, a12n] = rot(a02, a12);
          a02=a02n; a12=a12n;
          a00=appNew; a11=aqqNew; a01=0;
        } else if (p===0 && q===2) {
          const [a01n, a12n] = rot(a01, a12);
          a01=a01n; a12=a12n;
          a00=appNew; a22=aqqNew; a02=0;
        } else {
          const [a01n, a02n] = rot(a01, a02);
          a01=a01n; a02=a02n;
          a11=appNew; a22=aqqNew; a12=0;
        }
      }

      let l1=a00, l2=a11, l3=a22;
      if (l1 < l2) [l1,l2]=[l2,l1];
      if (l2 < l3) [l2,l3]=[l3,l2];
      if (l1 < l2) [l1,l2]=[l2,l1];
      return [l1,l2,l3];
    }

    function autocorrPeak(signal, dt) {
      const n = signal.length;
      if (n < 24) return {peak: 0, lag: 0, hz: 0};

      let mean=0;
      for (let i=0;i<n;i++) mean += signal[i];
      mean /= n;

      let varr=0;
      for (let i=0;i<n;i++) {
        const d = signal[i]-mean;
        varr += d*d;
      }
      if (varr < 1e-9) return {peak: 0, lag: 0, hz: 0};

      const minLag = Math.max(2, Math.floor(1/(MAX_HZ*dt)));
      const maxLag = Math.min(n-3, Math.floor(1/(MIN_HZ*dt)));

      let best = -1;
      let bestLag = 0;

      for (let lag=minLag; lag<=maxLag; lag++) {
        let c=0;
        for (let i=0;i<n-lag;i++) {
          c += (signal[i]-mean) * (signal[i+lag]-mean);
        }
        const r = c / varr;
        if (r > best) { best = r; bestLag = lag; }
      }

      const hz = bestLag > 0 ? (1/(bestLag*dt)) : 0;
      return {peak: clamp01(best), lag: bestLag, hz};
    }

    function smoothnessFromJerk(avgJerk) {
      const t = (JERK_LOOSE - avgJerk) / (JERK_LOOSE - JERK_TIGHT);
      return clamp01(t);
    }

    function cov3(vecs) {
      const n = vecs.length;
      if (n < 10) return {xx:0,xy:0,xz:0,yy:0,yz:0,zz:0, trace:0};

      let mx=0,my=0,mz=0;
      for (const v of vecs) { mx+=v.x; my+=v.y; mz+=v.z; }
      mx/=n; my/=n; mz/=n;

      let xx=0,xy=0,xz=0,yy=0,yz=0,zz=0;
      for (const v of vecs) {
        const x=v.x-mx, y=v.y-my, z=v.z-mz;
        xx += x*x; xy += x*y; xz += x*z;
        yy += y*y; yz += y*z; zz += z*z;
      }
      const inv = 1/(n-1);
      xx*=inv; xy*=inv; xz*=inv; yy*=inv; yz*=inv; zz*=inv;
      return {xx,xy,xz,yy,yz,zz, trace:(xx+yy+zz)};
    }

    function orbitBonusFromDirCov(cov) {
      const eps = 1e-9;
      if (cov.trace < 1e-6) return ORBIT_FLOOR;
      const [l1,l2,l3] = eigenvaluesSym3(cov.xx,cov.xy,cov.xz,cov.yy,cov.yz,cov.zz);
      const iso = clamp01(1 - ((l1 - l3) / (l1 + eps)));
      const shaped = Math.pow(iso, ORBIT_STRICTNESS);
      return ORBIT_FLOOR + (1 - ORBIT_FLOOR) * shaped;
    }

    function computeAvg(arr) {
      if (!arr.length) return 0;
      let s=0;
      for (const x of arr) s+=x;
      return s/arr.length;
    }

    function trimToWindow(dtMean, targetSec, omegaMag, omegaNorm, omegaDir, jerkBuf, dtBuf) {
      let targetN = dtMean > 1e-4 ? Math.round(targetSec / dtMean) : MAX_WINDOW_SAMPLES;
      targetN = Math.max(MIN_WINDOW_SAMPLES, Math.min(MAX_WINDOW_SAMPLES, targetN));

      while (omegaMag.length  > targetN) omegaMag.shift();
      while (omegaNorm.length > targetN) omegaNorm.shift();
      while (omegaDir.length  > targetN) omegaDir.shift();
      while (jerkBuf.length   > targetN) jerkBuf.shift();
      while (dtBuf.length     > targetN) dtBuf.shift();

      return targetN;
    }

    // =========================================================================
    // ✅ Meter continuity
    // =========================================================================
    const METER_HOLD_SEC = 0.55;
    const METER_FADE_HZ  = 3.0;

    // =========================================================================
    // State
    // =========================================================================
    let running = false;
    let lastT = null;

    let ox=0, oy=0, oz=0;

    const omegaMag  = [];
    const omegaNorm = [];
    const omegaDir  = [];
    const jerkBuf   = [];
    const dtBuf     = [];

    let emaMean = 0;
    let emaVar  = 1;

    let lock = false;
    let lockStrength = 0;
    let grooveHz = 0;

    let graceLeft = 0;
    let recenterBadTime = 0;

    let energy = 0;
    let energyUI = 0;

    // OLD One Euro filter state (kept for ω filt debug readout)
    const speedFilter = { xPrev: null, xHat: null, dxHat: null };

    // ✅ NEW speed force filter state
    const speedForceFilter = { xPrev: null, xHat: null, dxHat: null };
    let mForceLPF = 0;

    // ✅ rolling ω history for spike clamp (FORCE path)
    const mHist = [];
    const mHistDt = [];
    const mHistTime = { t: 0 };

    // continuity memory for meters (including speed)
    let meterHoldLeft = 0;
    let lastGrooveUI = 0;
    let lastOrbitUI  = 0;
    let lastSmoothUI = 0;
    let lastSpeedUI  = 0;

    // SHAKE state
    let shake01 = 0;
    let accelBaseMag = 9.81;
    let shakeCooldownLeft = 0;
    let lastSpikeTime = -1e9;
    let hadRecentSpike = false;

    let audioCtx = null, osc = null, gainNode = null;

    function ensureAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      gainNode = audioCtx.createGain();
      gainNode.gain.value = 0;

      osc = audioCtx.createOscillator();
      osc.type = 'sine';
      osc.frequency.value = TONE_BASE_HZ;

      osc.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      osc.start();
      log("audio: created");
    }

    function energyToGainSafe(eUI) {
      return energyToGain(clamp01(eUI));
    }

    function setAudio(eUI, groove, locked) {
      if (!audioCtx || !gainNode || !osc) return;

      const gBase = energyToGainSafe(eUI);
      const gGroove = locked ? (0.30 + 0.70*groove) : (0.08 + 0.22*groove);

      const g = MASTER_GAIN * gBase * gGroove;

      const f = TONE_BASE_HZ
              + TONE_MAX_ADD_HZ * (locked ? groove : 0.30*groove)
              + 60 * clamp01(eUI);

      const now = audioCtx.currentTime;
      gainNode.gain.cancelScheduledValues(now);
      gainNode.gain.setTargetAtTime(g, now, 0.06);

      osc.frequency.cancelScheduledValues(now);
      osc.frequency.setTargetAtTime(f, now, 0.06);
    }

    function updateUI(vals) {
      const toPct01 = (x) => Math.round(clamp01(x) * 100);
      const toPctRaw = (x) => Math.round(Math.max(0, x) * 100);

      const grooveP = toPct01(vals.groove);
      const orbitP  = toPct01(vals.orbit);
      const smoothP = toPct01(vals.smooth);
      const speedP  = toPct01(vals.speed);

      const energyPText = toPctRaw(vals.energy);
      const energyPBar  = toPct01(vals.energy);

      grooveEl.textContent = grooveP;
      orbitEl.textContent  = orbitP;
      smoothEl.textContent = smoothP;
      speedEl.textContent  = speedP;

      energyEl.textContent = energyPText;

      grooveBar.style.width = `${grooveP}%`;
      orbitBar.style.width  = `${orbitP}%`;
      smoothBar.style.width = `${smoothP}%`;
      speedBar.style.width  = `${speedP}%`;
      energyBar.style.width = `${energyPBar}%`;

      bigChargeEl.textContent = `${energyPText}%`;

      const over = (vals.energy > 1);
      bigChargeEl.classList.toggle("over", over);
      energyEl.classList.toggle("over", over);
      energyBar.classList.toggle("over", over);

      setBgFromEnergy(clamp01(vals.energy));
    }

    function flushHistorySoft() {
      const keep = Math.min(18, omegaMag.length);
      omegaMag.splice(0, Math.max(0, omegaMag.length - keep));
      omegaNorm.splice(0, Math.max(0, omegaNorm.length - keep));
      omegaDir.splice(0, Math.max(0, omegaDir.length - keep));
      jerkBuf.splice(0, Math.max(0, jerkBuf.length - keep));
      dtBuf.splice(0, Math.max(0, dtBuf.length - keep));
    }

    function meterHoldOrFade(dt, fallbackSpeed) {
      if (dt > 0) meterHoldLeft = Math.max(0, meterHoldLeft - dt);

      const dtFade = Math.max(1e-3, dt || computeAvg(dtBuf.slice(-50)) || 1/60);
      const aFade = alphaFromCutoff(dtFade, METER_FADE_HZ);
      const holding = meterHoldLeft > 0;

      const grooveOut = holding ? lastGrooveUI : (1 - aFade) * lastGrooveUI;
      const orbitOut  = holding ? lastOrbitUI  : (1 - aFade) * lastOrbitUI;
      const smoothOut = holding ? lastSmoothUI : (1 - aFade) * lastSmoothUI;
      const speedOut  = holding ? lastSpeedUI  : (1 - aFade) * lastSpeedUI;

      lastGrooveUI = grooveOut;
      lastOrbitUI  = orbitOut;
      lastSmoothUI = smoothOut;
      lastSpeedUI  = speedOut;

      return {
        grooveOut,
        orbitOut,
        smoothOut,
        speedOut: (fallbackSpeed != null ? fallbackSpeed : speedOut)
      };
    }

    let motionCount = 0;

    function updateShake(e, t, dt){
      const acc = e.accelerationIncludingGravity || e.acceleration;
      if (!acc) {
        if (dt > 0) shake01 = Math.max(0, shake01 - SHAKE_DECAY * dt);
        if (dt > 0) shakeCooldownLeft = Math.max(0, shakeCooldownLeft - dt);
        return { shake01, shakeHit:false, spike:0, amag:0 };
      }

      const ax = Number(acc.x) || 0;
      const ay = Number(acc.y) || 0;
      const az = Number(acc.z) || 0;
      const amag = mag3(ax, ay, az);

      const dtSafe = Math.max(1e-3, dt || 1/60);

      const aBase = alphaFromCutoff(dtSafe, SHAKE_BASELINE_HZ);
      accelBaseMag = (isFinite(accelBaseMag) ? accelBaseMag : amag);
      accelBaseMag = (1 - aBase) * accelBaseMag + aBase * amag;

      const rawSpike = Math.abs(amag - accelBaseMag);
      const spike = Math.max(0, rawSpike - SHAKE_DEADZONE);

      if (spike > SHAKE_SPIKE_GATE) {
        if ((t - lastSpikeTime) <= SHAKE_CADENCE_SEC) {
          hadRecentSpike = true;
        }
        lastSpikeTime = t;
      }
      if ((t - lastSpikeTime) > SHAKE_CADENCE_SEC) {
        hadRecentSpike = false;
      }

      shake01 = clamp01(shake01 + spike * SHAKE_GAIN * dtSafe - SHAKE_DECAY * dtSafe);

      shakeCooldownLeft = Math.max(0, shakeCooldownLeft - dtSafe);

      let shakeHit = false;
      const armed = (shake01 >= SHAKE_ARM_THRESH);
      const cadenceOk = hadRecentSpike;
      if (armed && cadenceOk && shakeCooldownLeft <= 0 && shake01 >= SHAKE_HIT_THRESH) {
        shakeHit = true;
        shakeCooldownLeft = SHAKE_COOLDOWN_SEC;
        shake01 = Math.max(0, shake01 - 0.40);
      }

      return { shake01, shakeHit, spike, amag };
    }

    function onMotion(e) {
      if (!running) return;

      const t = performance.now() / 1000;
      const dt = (lastT == null) ? 0 : (t - lastT);
      lastT = t;

      if (dt > 0) d.dt.textContent = dt.toFixed(3);
      motionCount++;
      d.motion.textContent = String(motionCount);

      if (dt > 0) dtBuf.push(dt);

      const sh = updateShake(e, t, dt);

      const rr = e.rotationRate;

      if (!rr) {
        d.rr.textContent = "none";

        if (dt > 0) {
          const ddec = ENERGY_DECAY * STOP_DECAY_MULT;
          energy = Math.max(0, energy - ddec * dt);
          energyUI = lerp(energyUI, energy, UI_SMOOTH);
        }

        const held = meterHoldOrFade(dt, null);

        const payload = {
          room,
          t: performance.now(),
          energy01: energyUI,
          groove01: held.grooveOut,
          orbit01: held.orbitOut,
          smooth01: held.smoothOut,
          speed01: held.speedOut,
          shake01: sh.shake01,
          shakeHit: sh.shakeHit,
          locked: false,
          hz: 0
        };
        publishOrb(payload, dt);

        updateUI({
          groove: held.grooveOut,
          orbit: held.orbitOut,
          smooth: held.smoothOut,
          speed: held.speedOut,
          energy: energyUI
        });
        setAudio(energyUI, held.grooveOut, false);
        return;
      }

      const x = rr.beta ?? 0;
      const y = rr.gamma ?? 0;
      const z = rr.alpha ?? 0;

      d.rr.textContent = `β:${x.toFixed(2)} γ:${y.toFixed(2)} α:${z.toFixed(2)}`;

      const prevOx=ox, prevOy=oy, prevOz=oz;

      // smoothed omega for groove/smooth/orbit stability computations
      ox = lerp(ox, x, OMEGA_LPF);
      oy = lerp(oy, y, OMEGA_LPF);
      oz = lerp(oz, z, OMEGA_LPF);

      const m = mag3(ox,oy,oz);
      const dtMean = Math.max(1e-3, computeAvg(dtBuf.slice(-50)));
      const dtForFilter = (dt > 0) ? dt : dtMean;

      // OLD omega filter kept only for the ω filt debug line (legacy)
      let mFiltLegacy = oneEuroStep(m, dtForFilter, speedFilter);
      if (m < mFiltLegacy) {
        const aRel = alphaFromCutoff(dtForFilter, SPEED_RELEASE_CUTOFF);
        mFiltLegacy = (1 - aRel) * mFiltLegacy + aRel * m;
      }
      if (m < (MIN_OMEGA * SPEED_STOP_SNAP)) {
        const aRel2 = alphaFromCutoff(dtForFilter, SPEED_RELEASE_CUTOFF * 1.25);
        mFiltLegacy = (1 - aRel2) * mFiltLegacy;
      }

      // =========================================================================
      // ✅ SPEED (FORCE): spike-resistant + fast brake
      // =========================================================================
      const mRaw = mag3(x, y, z);
      const mRawDz = Math.max(0, mRaw - SPEED_FORCE_DEAD);

      // fast LPF on raw omega
      mForceLPF = (mForceLPF === 0) ? mRawDz : lerp(mForceLPF, mRawDz, SPEED_FORCE_LPF);

      // ---- rolling median clamp (resists brief spikes) ----
      const dtHist = Math.max(1e-3, dtForFilter);
      mHist.push(mForceLPF);
      mHistDt.push(dtHist);
      mHistTime.t += dtHist;
      trimRollingWindowByTime(SPEED_SPIKE_WINDOW_SEC, mHist, mHistDt, mHistTime);

      const mMed = median(mHist);
      const mCap = Math.max(0, mMed * SPEED_SPIKE_MULT + SPEED_SPIKE_ADD);
      const mClamped = Math.min(mForceLPF, mCap);

      // One Euro on clamped ω
      let mForceFilt = oneEuroStepForce(mClamped, dtForFilter, speedForceFilter);

      // fast release when slowing
      if (mClamped < mForceFilt) {
        const aRelF = alphaFromCutoff(dtForFilter, SPEED_FORCE_RELEASE_CUTOFF);
        mForceFilt = (1 - aRelF) * mForceFilt + aRelF * mClamped;
      }

      // extra brake when near-stopping (kills lingering “runaway”)
      if (mRawDz < 2.0) {
        const aBrake = alphaFromCutoff(dtForFilter, SPEED_BRAKE_CUTOFF);
        mForceFilt = (1 - aBrake) * mForceFilt;
      }

      // map to 0..1 speed
      const nForce = Math.max(0, mForceFilt / SPEED_FORCE_NORM);
      const shaped = Math.pow(clamp01(nForce), SPEED_FORCE_POW);
      const speedScore = clamp01(1 - Math.exp(-SPEED_FORCE_SHAPE * shaped));

      // ✅ debug row:
      // ω raw  = stability-path magnitude (smoothed rr)
      // ω cap  = spike clamp cap (on force path)
      // ω filt = force filtered ω (post clamp)
      d.omega.textContent  = m.toFixed(2);
      d.omegaC.textContent = mCap.toFixed(2);
      d.omegaF.textContent = mForceFilt.toFixed(2);
      d.speed.textContent  = speedScore.toFixed(3);

      if (dt > 0) graceLeft = Math.max(0, graceLeft - dt);

      // history accumulation uses m (stability path)
      if (m > MIN_OMEGA) {
        omegaMag.push(m);

        const d0 = m - emaMean;
        emaMean = emaMean + NORM_ALPHA * d0;

        const d2 = (m - emaMean);
        emaVar = emaVar + NORM_ALPHA * (d2*d2 - emaVar);

        const rms = Math.sqrt(Math.max(1e-6, emaVar));
        omegaNorm.push((m - emaMean) / rms);

        const inv = 1/m;
        omegaDir.push({x:ox*inv, y:oy*inv, z:oz*inv});

        if (dt > 0) {
          const dtSafe = Math.max(dt, dtMean * 0.5, 1/120);
          jerkBuf.push(mag3(ox-prevOx, oy-prevOy, oz-prevOz) / dtSafe);
        }
      } else {
        if (omegaMag.length) omegaMag.shift();
        if (omegaNorm.length) omegaNorm.shift();
        if (omegaDir.length) omegaDir.shift();
        if (jerkBuf.length)  jerkBuf.shift();
      }

      const inStableMode = lock || graceLeft > 0;
      const windowSec = inStableMode ? STABLE_WINDOW_SEC : HUNT_WINDOW_SEC;
      const nTarget = trimToWindow(dtMean, windowSec, omegaMag, omegaNorm, omegaDir, jerkBuf, dtBuf);

      if (omegaNorm.length < Math.min(MIN_WINDOW_SAMPLES, nTarget)) {
        if (dt > 0) {
          const ddec = ENERGY_DECAY * STOP_DECAY_MULT;
          energy = Math.max(0, energy - ddec * dt);
          energyUI = lerp(energyUI, energy, UI_SMOOTH);
        }

        lastSpeedUI = speedScore;

        const held = meterHoldOrFade(dt, speedScore);

        const payload = {
          room,
          t: performance.now(),
          energy01: energyUI,
          groove01: held.grooveOut,
          orbit01: held.orbitOut,
          smooth01: held.smoothOut,
          speed01: held.speedOut,
          shake01: sh.shake01,
          shakeHit: sh.shakeHit,
          locked: false,
          hz: 0
        };
        publishOrb(payload, dt);

        updateUI({
          groove: held.grooveOut,
          orbit: held.orbitOut,
          smooth: held.smoothOut,
          speed: held.speedOut,
          energy: energyUI
        });
        setAudio(energyUI, held.grooveOut, false);
        return;
      }

      const ac = autocorrPeak(omegaNorm, dtMean);
      lockStrength = lerp(lockStrength, ac.peak, LOCK_SMOOTH);
      grooveHz = ac.hz;

      const jerkWindow = jerkBuf.slice(-Math.min(jerkBuf.length, 70));
      const avgJerk = median(jerkWindow);
      const smoothScore = smoothnessFromJerk(avgJerk);

      const dirCov = cov3(omegaDir);
      const orbitBonus = orbitBonusFromDirCov(dirCov);
      const orbitShown = (orbitBonus - ORBIT_FLOOR) / (1 - ORBIT_FLOOR);

      meterHoldLeft = METER_HOLD_SEC;
      lastGrooveUI = lockStrength;
      lastOrbitUI  = orbitShown;
      lastSmoothUI = smoothScore;
      lastSpeedUI  = speedScore;

      if (!lock) {
        if (lockStrength > LOCK_ON && speedScore > 0.16) {
          lock = true;
          graceLeft = 0;
        }
      } else {
        const shouldDrop = (lockStrength < LOCK_OFF) || (speedScore < 0.08);
        if (shouldDrop) {
          lock = false;
          graceLeft = GRACE_SEC;
        }
      }

      const inGrace = (!lock && graceLeft > 0);
      if (inGrace) {
        if (lockStrength > LOCK_ON && speedScore > GRACE_SPEED_MIN) {
          lock = true;
          graceLeft = 0;
        }
      }

      if (dt > 0) {
        const moving = speedScore >= RECENTER_SPEED_MIN;
        const badGroove = lockStrength <= RECENTER_GROOVE_MAX;
        const notLockedNow = !lock;

        if (moving && badGroove && notLockedNow) recenterBadTime += dt;
        else recenterBadTime = Math.max(0, recenterBadTime - 1.5*dt);

        if (recenterBadTime >= RECENTER_SEC) {
          flushHistorySoft();
          recenterBadTime = 0;
        }
      }

      if (dt > 0) {
        const grooveTerm = Math.pow(clamp01(lockStrength), GROOVE_EXP);
        const smoothTerm = Math.pow(clamp01(smoothScore), SMOOTH_EXP);
        const speedTerm  = Math.pow(clamp01(speedScore),  SPEED_EXP);
        const orbitTerm  = Math.pow(clamp01(orbitBonus),  ORBIT_EXP);

        const qualityTerm = grooveTerm * smoothTerm;
        const earnBase = EARN_SCALE * grooveTerm * smoothTerm * speedTerm * orbitTerm;

        const effectivelyLocked = lock || inGrace;
        const gain = effectivelyLocked ? ENERGY_GAIN_LOCKED : ENERGY_GAIN_FREE;

        const smoothKill = (smoothScore < SMOOTH_KILL_THRESH);
        const earn = smoothKill ? 0 : (gain * earnBase);

        let decay = ENERGY_DECAY;
        if (speedScore < STOP_SPEED_THRESH) decay *= STOP_DECAY_MULT;
        if (inGrace) decay *= 0.70;

        if (speedScore >= STOP_SPEED_THRESH && qualityTerm >= COAST_QUALITY_MIN) {
          decay *= COAST_DECAY_MULT;
        }

        if (smoothKill) {
          decay *= SMOOTH_KILL_DECAY_MULT;
          if (SMOOTH_KILL_UNLOCK) {
            lock = false;
            graceLeft = 0;
          }
        }

        energy = Math.max(0, energy + (earn - decay) * dt);
        energyUI = lerp(energyUI, energy, UI_SMOOTH);
      }

      const lockedNow = !!(lock || inGrace);

      const payload = {
        room,
        t: performance.now(),
        energy01: energyUI,
        groove01: lockStrength,
        orbit01: orbitShown,
        smooth01: smoothScore,
        speed01: speedScore,
        shake01: sh.shake01,
        shakeHit: sh.shakeHit,
        locked: lockedNow,
        hz: grooveHz
      };
      publishOrb(payload, dt);

      updateUI({
        groove: lockStrength,
        orbit: orbitShown,
        smooth: smoothScore,
        speed: speedScore,
        energy: energyUI
      });

      setAudio(energyUI, lockStrength, lockedNow);
    }

    // =========================================================================
    // iOS permission gate
    // =========================================================================
    async function requestMotionPermissionIfNeeded() {
      const needs = (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function')
                 || (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function');

      if (!needs) {
        setPerm("not required", "ok");
        log("motion permission: not required");
        return true;
      }

      setPerm("requesting…", "warn");
      log("motion permission: requesting…");

      const reqs = [];

      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        reqs.push(
          DeviceMotionEvent.requestPermission()
            .then(s => (log("DeviceMotionEvent permission result", { s }), s === 'granted'))
            .catch(e => (log("DeviceMotionEvent permission error", { message: e?.message || String(e) }), false))
        );
      }

      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        reqs.push(
          DeviceOrientationEvent.requestPermission()
            .then(s => (log("DeviceOrientationEvent permission result", { s }), s === 'granted'))
            .catch(e => (log("DeviceOrientationEvent permission error", { message: e?.message || String(e) }), false))
        );
      }

      const results = await Promise.all(reqs);
      const ok = results.every(Boolean);

      if (ok) setPerm("granted", "ok");
      else setPerm("denied", "bad");

      return ok;
    }

    // =========================================================================
    // Start/Stop
    // =========================================================================
    async function start() {
      setRun("starting…", "warn");
      setStage("start(): click", "warn");
      setErr("—", "dim");

      if (!window.isSecureContext) {
        setRun("error", "bad");
        setErr("Not a secure context (https required)", "bad");
        log("start(): blocked (not secure)");
        return;
      }

      startBtn.disabled = true;

      try {
        setStage("motion permission", "warn");
        const ok = await requestMotionPermissionIfNeeded();
        if (!ok) {
          setRun("error", "bad");
          setStage("start(): permission denied", "bad");
          setErr("Motion permission denied", "bad");
          return;
        }

        setStage("audio init/resume", "warn");
        ensureAudio();
        try { await audioCtx.resume(); log("audio: resumed"); }
        catch(e){ log("audio: resume failed", { message: e?.message || String(e) }); }

        setStage("relay connect", "warn");
        publishAcc = 0;
        const okRelay = await connectRelay();
        if (!okRelay) {
          log("Relay connect failed; running locally only.");
        }

        running = true;
        lastT = null;
        motionCount = 0;
        d.motion.textContent = "0";
        d.dt.textContent = "0";
        d.rr.textContent = "none";

        d.omega.textContent = "0";
        d.omegaC.textContent = "0";
        d.omegaF.textContent = "0";
        d.speed.textContent = "0";

        ox=oy=oz=0;

        omegaMag.length  = 0;
        omegaNorm.length = 0;
        omegaDir.length  = 0;
        jerkBuf.length   = 0;
        dtBuf.length     = 0;

        emaMean = 0;
        emaVar  = 1;

        lock = false;
        lockStrength = 0;
        grooveHz = 0;

        graceLeft = 0;
        recenterBadTime = 0;

        energy = 0;
        energyUI = 0;

        // reset OLD filter (debug)
        speedFilter.xPrev = null;
        speedFilter.xHat  = null;
        speedFilter.dxHat = null;

        // ✅ reset NEW force speed filter
        speedForceFilter.xPrev = null;
        speedForceFilter.xHat  = null;
        speedForceFilter.dxHat = null;
        mForceLPF = 0;

        // ✅ reset spike clamp history
        mHist.length = 0;
        mHistDt.length = 0;
        mHistTime.t = 0;

        meterHoldLeft = 0;
        lastGrooveUI = 0;
        lastOrbitUI  = 0;
        lastSmoothUI = 0;
        lastSpeedUI  = 0;

        shake01 = 0;
        accelBaseMag = 9.81;
        shakeCooldownLeft = 0;
        lastSpikeTime = -1e9;
        hadRecentSpike = false;

        setAudio(0,0,false);
        setBgFromEnergy(0);

        setStage("listening devicemotion", "ok");
        window.addEventListener('devicemotion', onMotion, { passive: true });

        startBtn.textContent = 'Stop';
        setRun("running", "ok");
        log("start(): running ✓");
      } catch (e) {
        const msg = e?.message || String(e);
        setRun("error", "bad");
        setStage("start(): exception", "bad");
        setErr(msg, "bad");
        log("✖ START FAILED:", { message: msg, name: e?.name, stack: e?.stack ? String(e.stack).slice(0, 280) : undefined });
        console.error("START FAILED:", e);
      } finally {
        startBtn.disabled = false;
      }
    }

    function stop() {
      setStage("stop()", "warn");
      running = false;
      window.removeEventListener('devicemotion', onMotion);

      if (audioCtx && gainNode) {
        const now = audioCtx.currentTime;
        gainNode.gain.cancelScheduledValues(now);
        gainNode.gain.setTargetAtTime(0, now, 0.05);
      }

      disconnectRelay();
      startBtn.textContent = 'Start';
      setRun("idle", "dim");
      setStage("—", "dim");
      log("stop(): idle");
    }

    startBtn.addEventListener('click', () => {
      log("start(): click", { secure: !!window.isSecureContext, href: window.location.href });
      if (!running) start();
      else stop();
    });
  })();
  </script>
</body>
</html>
